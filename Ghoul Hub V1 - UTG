-- Ghoul Hub V1 - UTG
-- Made by Ghoul Scripts
-- Netless by Ace
-- Respawn & Anti-Fling by Blukez
-- Subscribe to my YouTube channel : https://www.youtube.com/channel/UCqiDt4odmGjSGfj58XX5oAg

-- Instances:

local UTG = Instance.new("ScreenGui")
local frame = Instance.new("Frame")
local UICorner = Instance.new("UICorner")
local Border = Instance.new("Frame")
local UICorner_2 = Instance.new("UICorner")
local BorderLine = Instance.new("Frame")
local Title = Instance.new("TextLabel")
local Border_2 = Instance.new("Frame")
local UICorner_3 = Instance.new("UICorner")
local BorderLine_2 = Instance.new("Frame")
local Pages = Instance.new("Frame")
local ScrollingFrame = Instance.new("ScrollingFrame")
local AmongUs = Instance.new("TextButton")
local UICorner_4 = Instance.new("UICorner")
local Chips = Instance.new("TextButton")
local UICorner_5 = Instance.new("UICorner")
local Spider = Instance.new("TextButton")
local UICorner_6 = Instance.new("UICorner")
local ShadowBlade = Instance.new("TextButton")
local UICorner_7 = Instance.new("UICorner")
local RbNeptunion = Instance.new("TextButton")
local UICorner_8 = Instance.new("UICorner")
local Neptunion = Instance.new("TextButton")
local UICorner_9 = Instance.new("UICorner")
local NekoMaid = Instance.new("TextButton")
local UICorner_10 = Instance.new("UICorner")
local ServerAdmin = Instance.new("TextButton")
local UICorner_11 = Instance.new("UICorner")
local GaleFighter = Instance.new("TextButton")
local UICorner_12 = Instance.new("UICorner")
local joy = Instance.new("TextButton")
local UICorner_13 = Instance.new("UICorner")
local KillBot = Instance.new("TextButton")
local UICorner_14 = Instance.new("UICorner")
local Grapple = Instance.new("TextButton")
local UICorner_15 = Instance.new("UICorner")
local TextButton = Instance.new("TextButton")
local UICorner_16 = Instance.new("UICorner")
local TextButton_2 = Instance.new("TextButton")
local UICorner_17 = Instance.new("UICorner")
local TextButton_3 = Instance.new("TextButton")
local UICorner_18 = Instance.new("UICorner")
local TextButton_4 = Instance.new("TextButton")
local UICorner_19 = Instance.new("UICorner")
local TextButton_5 = Instance.new("TextButton")
local UICorner_20 = Instance.new("UICorner")
local TextButton_6 = Instance.new("TextButton")
local UICorner_21 = Instance.new("UICorner")
local TextButton_7 = Instance.new("TextButton")
local UICorner_22 = Instance.new("UICorner")
local TextButton_8 = Instance.new("TextButton")
local UICorner_23 = Instance.new("UICorner")
local UltraClickers4 = Instance.new("TextButton")
local UICorner_24 = Instance.new("UICorner")
local UtgV1 = Instance.new("TextButton")
local UICorner_25 = Instance.new("UICorner")
local UtgV2 = Instance.new("TextButton")
local UICorner_26 = Instance.new("UICorner")
local UtgRebirth = Instance.new("TextButton")
local UICorner_27 = Instance.new("UICorner")
local TextLabel = Instance.new("TextLabel")
local Close = Instance.new("TextButton")
local UICorner_28 = Instance.new("UICorner")
local Netless = Instance.new("TextButton")
local UICorner_29 = Instance.new("UICorner")
local Respawn = Instance.new("TextButton")
local UICorner_30 = Instance.new("UICorner")
local AntiFling = Instance.new("TextButton")
local UICorner_31 = Instance.new("UICorner")

--Properties:

UTG.Name = "UTG"
UTG.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
UTG.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
UTG.ResetOnSpawn = false

frame.Name = "frame"
frame.Parent = UTG
frame.Active = true
frame.BackgroundColor3 = Color3.fromRGB(75, 75, 75)
frame.BorderSizePixel = 0
frame.Position = UDim2.new(0, 746, 0, 336)
frame.Selectable = true
frame.Size = UDim2.new(0, 550, 0, 310)

UICorner.Parent = frame

Border.Name = "Border"
Border.Parent = frame
Border.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
Border.Position = UDim2.new(3.20157123e-05, 0, -0.00194953184, 0)
Border.Size = UDim2.new(0, 549, 0, 44)
Border.ZIndex = 2

UICorner_2.Parent = Border

BorderLine.Name = "BorderLine"
BorderLine.Parent = Border
BorderLine.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
BorderLine.BorderSizePixel = 0
BorderLine.Position = UDim2.new(0, 0, 0, 38)
BorderLine.Size = UDim2.new(0, 549, 0, 5)

Title.Name = "Title"
Title.Parent = Border
Title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Title.BackgroundTransparency = 1.000
Title.BorderSizePixel = 0
Title.Position = UDim2.new(0, 0, 0.0137353381, 0)
Title.Size = UDim2.new(0, 254, 0, 42)
Title.Font = Enum.Font.SourceSans
Title.Text = "Ghoul Hub - UTG"
Title.TextColor3 = Color3.fromRGB(235, 235, 235)
Title.TextScaled = true
Title.TextSize = 14.000
Title.TextWrapped = true

Border_2.Name = "Border"
Border_2.Parent = frame
Border_2.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
Border_2.Position = UDim2.new(3.20157123e-05, 0, 0.912779212, 0)
Border_2.Size = UDim2.new(0, 549, 0, 33)
Border_2.ZIndex = 2

UICorner_3.Parent = Border_2

BorderLine_2.Name = "BorderLine"
BorderLine_2.Parent = Border_2
BorderLine_2.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
BorderLine_2.BorderSizePixel = 0
BorderLine_2.Position = UDim2.new(0.00142101292, 0, 0, 0)
BorderLine_2.Size = UDim2.new(0, 549, 0, 6)

Pages.Name = "Pages"
Pages.Parent = frame
Pages.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Pages.BackgroundTransparency = 1.000
Pages.BorderSizePixel = 0
Pages.Position = UDim2.new(0, 0, 0.139985904, 0)
Pages.Size = UDim2.new(0, 549, 0, 239)

ScrollingFrame.Parent = Pages
ScrollingFrame.Active = true
ScrollingFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
ScrollingFrame.BackgroundTransparency = 1.000
ScrollingFrame.BorderSizePixel = 0
ScrollingFrame.Position = UDim2.new(-0.0346082672, 19, 0.00599996001, 0)
ScrollingFrame.Size = UDim2.new(0, 549, 0, 238)
ScrollingFrame.CanvasSize = UDim2.new(0, 0, 2, 9)
ScrollingFrame.ScrollBarThickness = 7

AmongUs.Name = "AmongUs"
AmongUs.Parent = ScrollingFrame
AmongUs.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
AmongUs.Position = UDim2.new(0.24470073, 10, 0.886703372, -280)
AmongUs.Selectable = false
AmongUs.Size = UDim2.new(0, 124, 0, 48)
AmongUs.Font = Enum.Font.SourceSans
AmongUs.Text = "Amogus"
AmongUs.TextColor3 = Color3.fromRGB(235, 235, 235)
AmongUs.TextSize = 18.000
AmongUs.TextWrapped = true

UICorner_4.Parent = AmongUs

Chips.Name = "Chips"
Chips.Parent = ScrollingFrame
Chips.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
Chips.Position = UDim2.new(0.00200000033, 10, 0.886703372, -280)
Chips.Selectable = false
Chips.Size = UDim2.new(0, 124, 0, 48)
Chips.Font = Enum.Font.SourceSans
Chips.Text = "Chips"
Chips.TextColor3 = Color3.fromRGB(235, 235, 235)
Chips.TextSize = 18.000
Chips.TextWrapped = true

UICorner_5.Parent = Chips

Spider.Name = "Spider"
Spider.Parent = ScrollingFrame
Spider.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
Spider.Position = UDim2.new(0.733751833, 10, 0.886703372, -280)
Spider.Selectable = false
Spider.Size = UDim2.new(0, 124, 0, 48)
Spider.Font = Enum.Font.SourceSans
Spider.Text = "Spider"
Spider.TextColor3 = Color3.fromRGB(235, 235, 235)
Spider.TextSize = 18.000
Spider.TextWrapped = true

UICorner_6.Parent = Spider

ShadowBlade.Name = "ShadowBlade"
ShadowBlade.Parent = ScrollingFrame
ShadowBlade.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
ShadowBlade.Position = UDim2.new(0.489226282, 10, 0.768493712, -280)
ShadowBlade.Selectable = false
ShadowBlade.Size = UDim2.new(0, 124, 0, 48)
ShadowBlade.Font = Enum.Font.SourceSans
ShadowBlade.Text = "Shadow Blade"
ShadowBlade.TextColor3 = Color3.fromRGB(235, 235, 235)
ShadowBlade.TextSize = 18.000
ShadowBlade.TextWrapped = true

UICorner_7.Parent = ShadowBlade

RbNeptunion.Name = "RbNeptunion"
RbNeptunion.Parent = ScrollingFrame
RbNeptunion.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
RbNeptunion.Position = UDim2.new(0.24470073, 10, 0.768493712, -280)
RbNeptunion.Selectable = false
RbNeptunion.Size = UDim2.new(0, 124, 0, 48)
RbNeptunion.Font = Enum.Font.SourceSans
RbNeptunion.Text = "RB Neptunion"
RbNeptunion.TextColor3 = Color3.fromRGB(235, 235, 235)
RbNeptunion.TextSize = 18.000
RbNeptunion.TextWrapped = true

UICorner_8.Parent = RbNeptunion

Neptunion.Name = "Neptunion"
Neptunion.Parent = ScrollingFrame
Neptunion.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
Neptunion.Position = UDim2.new(0.00200000033, 10, 0.768493712, -280)
Neptunion.Selectable = false
Neptunion.Size = UDim2.new(0, 124, 0, 48)
Neptunion.Font = Enum.Font.SourceSans
Neptunion.Text = "Neptunion"
Neptunion.TextColor3 = Color3.fromRGB(235, 235, 235)
Neptunion.TextSize = 18.000
Neptunion.TextWrapped = true

UICorner_9.Parent = Neptunion

NekoMaid.Name = "NekoMaid"
NekoMaid.Parent = ScrollingFrame
NekoMaid.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
NekoMaid.Position = UDim2.new(0.127076864, 75, 0.65156883, -280)
NekoMaid.Selectable = false
NekoMaid.Size = UDim2.new(0, 124, 0, 48)
NekoMaid.Font = Enum.Font.SourceSans
NekoMaid.Text = "Neko Maid"
NekoMaid.TextColor3 = Color3.fromRGB(235, 235, 235)
NekoMaid.TextSize = 18.000
NekoMaid.TextWrapped = true

UICorner_10.Parent = NekoMaid

ServerAdmin.Name = "ServerAdmin"
ServerAdmin.Parent = ScrollingFrame
ServerAdmin.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
ServerAdmin.Position = UDim2.new(0.185035318, 311, 0.65156883, -280)
ServerAdmin.Selectable = false
ServerAdmin.Size = UDim2.new(0, 124, 0, 48)
ServerAdmin.Font = Enum.Font.SourceSans
ServerAdmin.Text = "Server Admin"
ServerAdmin.TextColor3 = Color3.fromRGB(235, 235, 235)
ServerAdmin.TextSize = 18.000
ServerAdmin.TextWrapped = true

UICorner_11.Parent = ServerAdmin

GaleFighter.Name = "GaleFighter"
GaleFighter.Parent = ScrollingFrame
GaleFighter.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
GaleFighter.Position = UDim2.new(0.00219381228, 10, 0.65156883, -280)
GaleFighter.Selectable = false
GaleFighter.Size = UDim2.new(0, 124, 0, 48)
GaleFighter.Font = Enum.Font.SourceSans
GaleFighter.Text = "Gale Fighter"
GaleFighter.TextColor3 = Color3.fromRGB(235, 235, 235)
GaleFighter.TextSize = 18.000
GaleFighter.TextWrapped = true

UICorner_12.Parent = GaleFighter

joy.Name = "joy"
joy.Parent = ScrollingFrame
joy.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
joy.Position = UDim2.new(0.733751833, 10, 0.768493712, -280)
joy.Selectable = false
joy.Size = UDim2.new(0, 124, 0, 48)
joy.Font = Enum.Font.SourceSans
joy.Text = ":joy:"
joy.TextColor3 = Color3.fromRGB(235, 235, 235)
joy.TextSize = 18.000
joy.TextWrapped = true

UICorner_13.Parent = joy

KillBot.Name = "KillBot"
KillBot.Parent = ScrollingFrame
KillBot.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
KillBot.Position = UDim2.new(0.156056091, 193, 0.65156883, -280)
KillBot.Selectable = false
KillBot.Size = UDim2.new(0, 124, 0, 48)
KillBot.Font = Enum.Font.SourceSans
KillBot.Text = "Kill Bot"
KillBot.TextColor3 = Color3.fromRGB(235, 235, 235)
KillBot.TextSize = 18.000
KillBot.TextWrapped = true

UICorner_14.Parent = KillBot

Grapple.Name = "Grapple"
Grapple.Parent = ScrollingFrame
Grapple.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
Grapple.Position = UDim2.new(0.489226282, 10, 0.886703372, -280)
Grapple.Selectable = false
Grapple.Size = UDim2.new(0, 124, 0, 48)
Grapple.Font = Enum.Font.SourceSans
Grapple.Text = "Grapple"
Grapple.TextColor3 = Color3.fromRGB(235, 235, 235)
Grapple.TextSize = 18.000
Grapple.TextWrapped = true

UICorner_15.Parent = Grapple

TextButton.Parent = ScrollingFrame
TextButton.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
TextButton.Position = UDim2.new(0.49104777, 10, 1.28941441, -280)
TextButton.Selectable = false
TextButton.Size = UDim2.new(0, 124, 0, 48)
TextButton.Font = Enum.Font.SourceSans
TextButton.TextColor3 = Color3.fromRGB(235, 235, 235)
TextButton.TextSize = 18.000
TextButton.TextWrapped = true

UICorner_16.Parent = TextButton

TextButton_2.Parent = ScrollingFrame
TextButton_2.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
TextButton_2.Position = UDim2.new(0.00382149406, 10, 1.28941441, -280)
TextButton_2.Selectable = false
TextButton_2.Size = UDim2.new(0, 124, 0, 48)
TextButton_2.Font = Enum.Font.SourceSans
TextButton_2.TextColor3 = Color3.fromRGB(235, 235, 235)
TextButton_2.TextSize = 18.000
TextButton_2.TextWrapped = true

UICorner_17.Parent = TextButton_2

TextButton_3.Parent = ScrollingFrame
TextButton_3.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
TextButton_3.Position = UDim2.new(0.735573351, 10, 1.28941441, -280)
TextButton_3.Selectable = false
TextButton_3.Size = UDim2.new(0, 124, 0, 48)
TextButton_3.Font = Enum.Font.SourceSans
TextButton_3.TextColor3 = Color3.fromRGB(235, 235, 235)
TextButton_3.TextSize = 18.000
TextButton_3.TextWrapped = true

UICorner_18.Parent = TextButton_3

TextButton_4.Parent = ScrollingFrame
TextButton_4.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
TextButton_4.Position = UDim2.new(0.00382149406, 10, 1.40762401, -280)
TextButton_4.Selectable = false
TextButton_4.Size = UDim2.new(0, 124, 0, 48)
TextButton_4.Font = Enum.Font.SourceSans
TextButton_4.TextColor3 = Color3.fromRGB(235, 235, 235)
TextButton_4.TextSize = 18.000
TextButton_4.TextWrapped = true

UICorner_19.Parent = TextButton_4

TextButton_5.Parent = ScrollingFrame
TextButton_5.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
TextButton_5.Position = UDim2.new(0.246522218, 10, 1.28941441, -280)
TextButton_5.Selectable = false
TextButton_5.Size = UDim2.new(0, 124, 0, 48)
TextButton_5.Font = Enum.Font.SourceSans
TextButton_5.TextColor3 = Color3.fromRGB(235, 235, 235)
TextButton_5.TextSize = 18.000
TextButton_5.TextWrapped = true

UICorner_20.Parent = TextButton_5

TextButton_6.Parent = ScrollingFrame
TextButton_6.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
TextButton_6.Position = UDim2.new(0.735573351, 10, 1.40762401, -280)
TextButton_6.Selectable = false
TextButton_6.Size = UDim2.new(0, 124, 0, 48)
TextButton_6.Font = Enum.Font.SourceSans
TextButton_6.TextColor3 = Color3.fromRGB(235, 235, 235)
TextButton_6.TextSize = 18.000
TextButton_6.TextWrapped = true

UICorner_21.Parent = TextButton_6

TextButton_7.Parent = ScrollingFrame
TextButton_7.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
TextButton_7.Position = UDim2.new(0.246522218, 10, 1.40762401, -280)
TextButton_7.Selectable = false
TextButton_7.Size = UDim2.new(0, 124, 0, 48)
TextButton_7.Font = Enum.Font.SourceSans
TextButton_7.TextColor3 = Color3.fromRGB(235, 235, 235)
TextButton_7.TextSize = 18.000
TextButton_7.TextWrapped = true

UICorner_22.Parent = TextButton_7

TextButton_8.Parent = ScrollingFrame
TextButton_8.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
TextButton_8.Position = UDim2.new(0.49104777, 10, 1.40762401, -280)
TextButton_8.Selectable = false
TextButton_8.Size = UDim2.new(0, 124, 0, 48)
TextButton_8.Font = Enum.Font.SourceSans
TextButton_8.TextColor3 = Color3.fromRGB(235, 235, 235)
TextButton_8.TextSize = 18.000
TextButton_8.TextWrapped = true

UICorner_23.Parent = TextButton_8

UltraClickers4.Name = "UltraClickers4"
UltraClickers4.Parent = ScrollingFrame
UltraClickers4.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
UltraClickers4.Position = UDim2.new(0.00401530601, 10, 1.1724894, -280)
UltraClickers4.Selectable = false
UltraClickers4.Size = UDim2.new(0, 124, 0, 48)
UltraClickers4.Font = Enum.Font.SourceSans
UltraClickers4.Text = "Ultra Clickers 4"
UltraClickers4.TextColor3 = Color3.fromRGB(235, 235, 235)
UltraClickers4.TextSize = 18.000
UltraClickers4.TextWrapped = true

UICorner_24.Parent = UltraClickers4

UtgV1.Name = "UtgV1"
UtgV1.Parent = ScrollingFrame
UtgV1.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
UtgV1.Position = UDim2.new(0.128898352, 75, 1.1724894, -280)
UtgV1.Selectable = false
UtgV1.Size = UDim2.new(0, 124, 0, 48)
UtgV1.Font = Enum.Font.SourceSans
UtgV1.Text = "UTG V1"
UtgV1.TextColor3 = Color3.fromRGB(235, 235, 235)
UtgV1.TextSize = 18.000
UtgV1.TextWrapped = true

UICorner_25.Parent = UtgV1

UtgV2.Name = "UtgV2"
UtgV2.Parent = ScrollingFrame
UtgV2.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
UtgV2.Position = UDim2.new(0.157877579, 193, 1.1724894, -280)
UtgV2.Selectable = false
UtgV2.Size = UDim2.new(0, 124, 0, 48)
UtgV2.Font = Enum.Font.SourceSans
UtgV2.Text = "UTG V2"
UtgV2.TextColor3 = Color3.fromRGB(235, 235, 235)
UtgV2.TextSize = 18.000
UtgV2.TextWrapped = true

UICorner_26.Parent = UtgV2

UtgRebirth.Name = "UtgRebirth"
UtgRebirth.Parent = ScrollingFrame
UtgRebirth.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
UtgRebirth.Position = UDim2.new(0.186856806, 311, 1.1724894, -280)
UtgRebirth.Selectable = false
UtgRebirth.Size = UDim2.new(0, 124, 0, 48)
UtgRebirth.Font = Enum.Font.SourceSans
UtgRebirth.Text = "UTG Re-Birth"
UtgRebirth.TextColor3 = Color3.fromRGB(235, 235, 235)
UtgRebirth.TextSize = 18.000
UtgRebirth.TextWrapped = true

UICorner_27.Parent = UtgRebirth

TextLabel.Parent = ScrollingFrame
TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.BackgroundTransparency = 1.000
TextLabel.Position = UDim2.new(0.318761408, 0, 0.453974903, 0)
TextLabel.Size = UDim2.new(0, 200, 0, 50)
TextLabel.Font = Enum.Font.SourceSans
TextLabel.Text = "-- Game Hub --"
TextLabel.TextColor3 = Color3.fromRGB(235, 235, 235)
TextLabel.TextSize = 30.000

Close.Name = "Close"
Close.Parent = frame
Close.BackgroundColor3 = Color3.fromRGB(75, 75, 75)
Close.Position = UDim2.new(0.886932254, 10, 0.917949438, -280)
Close.Size = UDim2.new(0, 44, 0, 32)
Close.ZIndex = 2
Close.Font = Enum.Font.SourceSans
Close.Text = "X"
Close.TextColor3 = Color3.fromRGB(235, 235, 235)
Close.TextScaled = true
Close.TextSize = 14.000
Close.TextWrapped = true

UICorner_28.Parent = Close

Netless.Name = "Netless"
Netless.Parent = frame
Netless.BackgroundColor3 = Color3.fromRGB(75, 75, 75)
Netless.Position = UDim2.new(0.125114083, 10, 1.83535981, -280)
Netless.Size = UDim2.new(0, 120, 0, 21)
Netless.ZIndex = 2
Netless.Font = Enum.Font.SourceSans
Netless.Text = "Netless"
Netless.TextColor3 = Color3.fromRGB(235, 235, 235)
Netless.TextScaled = true
Netless.TextSize = 14.000
Netless.TextWrapped = true

UICorner_29.Parent = Netless

Respawn.Name = "Respawn"
Respawn.Parent = frame
Respawn.BackgroundColor3 = Color3.fromRGB(75, 75, 75)
Respawn.Position = UDim2.new(0.366932273, 10, 1.83535981, -280)
Respawn.Size = UDim2.new(0, 120, 0, 21)
Respawn.ZIndex = 2
Respawn.Font = Enum.Font.SourceSans
Respawn.Text = "Respawn"
Respawn.TextColor3 = Color3.fromRGB(235, 235, 235)
Respawn.TextScaled = true
Respawn.TextSize = 14.000
Respawn.TextWrapped = true

UICorner_30.Parent = Respawn

AntiFling.Name = "AntiFling"
AntiFling.Parent = frame
AntiFling.BackgroundColor3 = Color3.fromRGB(75, 75, 75)
AntiFling.Position = UDim2.new(0.617841363, 10, 1.83535981, -280)
AntiFling.Size = UDim2.new(0, 120, 0, 21)
AntiFling.ZIndex = 2
AntiFling.Font = Enum.Font.SourceSans
AntiFling.Text = "Anti-Fling"
AntiFling.TextColor3 = Color3.fromRGB(235, 235, 235)
AntiFling.TextScaled = true
AntiFling.TextSize = 14.000
AntiFling.TextWrapped = true

UICorner_31.Parent = AntiFling

-- Scripts:

local function GNZW_fake_script() -- AmongUs.LocalScript 
	local script = Instance.new('LocalScript', AmongUs)

	AmongUs.MouseButton1Down:connect(function()
		loadstring(game:HttpGet("https://pastebin.com/raw/JXUMavf3", true))()
	end)
end
coroutine.wrap(GNZW_fake_script)()
local function TEWOGV_fake_script() -- Chips.LocalScript 
	local script = Instance.new('LocalScript', Chips)

	Chips.MouseButton1Down:connect(function()
		HumanDied = false
		local CountSCIFIMOVIELOL = 1
		function SCIFIMOVIELOL(Part0,Part1,Position,Angle)
			local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL
			AlignPos.ApplyAtCenterOfMass = true;
			AlignPos.MaxForce = 5772000--67752;
			AlignPos.MaxVelocity = math.huge/9e110;
			AlignPos.ReactionForceEnabled = false;
			AlignPos.Responsiveness = 200;
			AlignPos.RigidityEnabled = false;
			local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL
			AlignOri.MaxAngularVelocity = math.huge/9e110;
			AlignOri.MaxTorque = 5772000
			AlignOri.PrimaryAxisOnly = false;
			AlignOri.ReactionTorqueEnabled = false;
			AlignOri.Responsiveness = 200;
			AlignOri.RigidityEnabled = false;
			local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "Ath_"..CountSCIFIMOVIELOL
			local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "Ath_"..CountSCIFIMOVIELOL
			AttachmentA.Orientation = Angle or Vector3.new(0,0,0)
			AttachmentA.Position = Position or Vector3.new(0,0,0)
			AlignPos.Attachment1 = AttachmentA;
			AlignPos.Attachment0 = AttachmentB;
			AlignOri.Attachment1 = AttachmentA;
			AlignOri.Attachment0 = AttachmentB;
			CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1
			return {AlignPos,AlignOri,AttachmentA,AttachmentB}
		end

		if _G.netted ~= true then
			_G.netted = true
			coroutine.wrap(function()
				settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
				settings().Physics.AllowSleep = false
				game:GetService("RunService").RenderStepped:Connect(function()
					game:FindFirstChildOfClass("Players").LocalPlayer.MaximumSimulationRadius=math.pow(math.huge,math.huge)
					sethiddenproperty(game:FindFirstChildOfClass("Players").LocalPlayer,"SimulationRadius",math.huge*math.huge)
				end)
			end)()
		end

		game:FindFirstChildOfClass("Players").LocalPlayer["Character"].Archivable = true
		local hatnameclone = {}
		for _,v in next, game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:GetChildren() do
			if v:IsA("Accessory") then
				if hatnameclone[v.Name] then
					if hatnameclone[v.Name] == "s" then
						hatnameclone[v.Name] = {}
					end
					table.insert(hatnameclone[v.Name],v)
				else
					hatnameclone[v.Name] = "s"
				end
			end
		end
		for _,v in pairs(hatnameclone) do
			if type(v) == "table" then
				local num = 1
				for _,w in pairs(v) do
					w.Name = w.Name..num
					num = num + 1
				end
			end
		end
		hatnameclone = nil

		local DeadChar = game:FindFirstChildOfClass("Players").LocalPlayer.Character

		local fldr = Instance.new("Folder",game:FindFirstChildOfClass("Players").LocalPlayer["Character"])
		fldr.Name = "DMYF"
		local CloneChar = DeadChar:Clone()
		local ANIMATIONHERE
		if CloneChar:FindFirstChild("Animate") then
			ANIMATIONHERE = CloneChar:FindFirstChild("Animate"):Clone()
			CloneChar:FindFirstChild("Animate"):Destroy()
		end
		if CloneChar:FindFirstChildOfClass("Folder") then CloneChar:FindFirstChildOfClass("Folder"):Destroy() end
		if CloneChar.Torso:FindFirstChild("Neck") then
			local Clonessss = CloneChar.Torso:FindFirstChild("Neck"):Clone()
			Clonessss.Part0 = nil
			Clonessss.Part1 = DeadChar.Head
			Clonessss.Parent = DeadChar.Torso
		end
		CloneChar.Parent = fldr
		CloneChar.HumanoidRootPart.CFrame = DeadChar.HumanoidRootPart.CFrame
		CloneChar.Humanoid.BreakJointsOnDeath = false
		CloneChar.Name = "non"
		CloneChar.Humanoid.DisplayDistanceType = "None"

		for _,v in next, DeadChar:GetChildren() do
			if v:IsA("Accessory") then
				local topacc = false
				if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
				v.Handle.Massless = true
				v.Handle.CanCollide = false
				if v.Handle:FindFirstChildOfClass("Attachment") then
					local ath__ = v.Handle:FindFirstChildOfClass("Attachment")
					if ath__.Name == "HatAttachment" or ath__.Name == "HairAttachment" or ath__.Name == "FaceFrontAttachment" or ath__.Name == "FaceCenterAttachment" then
						topacc = ath__.Name
					end
				end
				local bv = Instance.new("BodyVelocity",v.Handle)
				bv.Velocity = Vector3.new(0,0,0)
				coroutine.wrap(function()
					if topacc then
						local allthings = SCIFIMOVIELOL(v.Handle,DeadChar.Torso,Vector3.new(0,1.5,0)+ (DeadChar.Head[topacc].Position + (v.Handle[topacc].Position*-1)),Vector3.new(0,0,0))
						local normaltop = allthings[1].Attachment1
						local alipos = allthings[1]
						local alirot = allthings[2]
						local p0 = v.Handle
						local p1 = DeadChar.Head
						alipos.Parent = CloneChar:FindFirstChild(v.Name).Handle
						alirot.Parent = CloneChar:FindFirstChild(v.Name).Handle
						while true do
							game:GetService("RunService").RenderStepped:wait()
							if HumanDied then break end
							coroutine.wrap(function()
								if alipos.Attachment1 == normaltop then
									p0.CFrame = p0.CFrame:lerp((((DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)) * p1[topacc].CFrame) * p0[topacc].CFrame:inverse()),1)
								else
									v.Handle.CFrame = v.Handle.CFrame:lerp(alipos.Attachment1.Parent.CFrame * CFrame.new(alipos.Attachment1.Position) * CFrame.Angles(math.rad(alipos.Attachment1.Rotation.X),math.rad(alipos.Attachment1.Rotation.Y),math.rad(alipos.Attachment1.Rotation.Z)),1)
								end
							end)()
						end
					else
						SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
					end
				end)()
			end
		end

		local a = DeadChar.Torso
		local b = DeadChar.HumanoidRootPart
		local c = DeadChar.Humanoid
		a.Parent = game:FindFirstChildOfClass("Workspace")
		c.Parent = game:FindFirstChildOfClass("Workspace")
		local told = a:Clone()
		local told1 = c:Clone()
		b["RootJoint"].Part0 = told
		b["RootJoint"].Part1 = DeadChar.Head
		a.Name = "torso"
		a.Neck:Destroy()
		c.Name = "Mizt Hub Best"
		told.Parent = DeadChar
		told1.Parent = DeadChar
		DeadChar.PrimaryPart = told
		told1.Health = 0
		b:Destroy()
		a.Parent = DeadChar
		c.Parent = DeadChar
		told:Destroy()
		told1:Destroy()
		a.Name = "Torso"

		if CloneChar.Head:FindFirstChildOfClass("Decal") then CloneChar.Head:FindFirstChildOfClass("Decal").Transparency = 1 end
		if DeadChar:FindFirstChild("Animate") then DeadChar:FindFirstChild("Animate"):Destroy() end

		local Collider
		function UnCollide()
			if HumanDied then Collider:Disconnect(); return end
    --[[for _,Parts in next, CloneChar:GetChildren() do
        if Parts:IsA("BasePart") then
            Parts.CanCollide = false 
        end 
    end]]
			for _,Parts in next, DeadChar:GetChildren() do
				if Parts:IsA("BasePart") then
					Parts.CanCollide = false
				end 
			end 
		end
		Collider = game:GetService("RunService").Stepped:Connect(UnCollide)

		local resetBindable = Instance.new("BindableEvent")
		resetBindable.Event:connect(function()
			game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
			resetBindable:Destroy()
			HumanDied = true
			pcall(function()
				game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
				DeadChar.Head:Destroy()
				DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
				game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
				if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
			end)
		end)
		game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChildOfClass("Humanoid") or CloneChar:FindFirstChildOfClass("Humanoid").Health <= 0 and not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChildOfClass("Humanoid") or DeadChar:FindFirstChildOfClass("Humanoid").Health <= 0 then 
					HumanDied = true
					pcall(function()
						game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
						DeadChar.Head:Destroy()
						DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
						game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
						if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
					end)
					if resetBindable then
						game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
						resetBindable:Destroy()
					end
					break
				end		
			end
		end)()


		SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"])
		SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"])
		SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"])
		SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"])
		SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"])
		SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"])

		for _,v in pairs(DeadChar:GetChildren()) do
			if v:IsA("BasePart") and v.Name ~= "Head" then
		--[[local bv = Instance.new("BodyVelocity",v)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then break end
				v.CFrame = CloneChar[v.Name].CFrame
			end
		end)()]]
			elseif v:IsA("BasePart") and v.Name == "Head" then
				local bv = Instance.new("BodyVelocity",v)
				bv.Velocity = Vector3.new(0,0,0)
				coroutine.wrap(function()
					while true do
						game:GetService("RunService").RenderStepped:wait()
						if HumanDied then break end
						v.CFrame = DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)
					end
				end)()
			end
		end

		for _,BodyParts in next, CloneChar:GetDescendants() do
			if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
				BodyParts.Transparency = 1 end end
		game:GetService("RunService").RenderStepped:wait()
		game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
		game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Camera").CameraSubject = CloneChar.Humanoid

		for _,v in next, DeadChar:GetChildren() do
			if v:IsA("Accessory") then
				if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
			end
		end

		if ANIMATIONHERE then ANIMATIONHERE.Parent = CloneChar end

		-----------------------
		--[[ Name : Chips ]]--
		--[[ Description : I think I found my specialty in scripts ]]--
		--[[ \ None / ]]--
		-------------------------------------------------------
		--A script By Creterisk/makhail07
		--Discord Creterisk#2958 
		-------------------------------------------------------

		--Everything is Meaningless.....

		wait(1 / 60)

		loadstring(game:GetObjects("rbxassetid://5425999987")[1].Source)()

		local plr = game.Players.LocalPlayer
		local mouse = plr:GetMouse()
		local char = plr.Character
		local hum = char:FindFirstChildOfClass'Humanoid'
		local hed = char.Head
		local root = char:FindFirstChild'HumanoidRootPart'
		local rootj = root.RootJoint
		local tors = char.Torso
		local ra = char["Right Arm"]
		local la = char["Left Arm"]
		local rl = char["Right Leg"]
		local ll = char["Left Leg"]
		local neck = tors["Neck"]
		local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
		local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
		local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
		local maincolor = BrickColor.new("Institutional white")
		-------------------------------------------------------
		--Start Good Stuff--
		-------------------------------------------------------
		cam = game.Workspace.CurrentCamera
		CF = CFrame.new
		angles = CFrame.Angles
		attack = false
		Euler = CFrame.fromEulerAnglesXYZ
		Rad = math.rad
		IT = Instance.new
		BrickC = BrickColor.new
		Cos = math.cos
		Acos = math.acos
		Sin = math.sin
		Asin = math.asin
		Abs = math.abs
		Mrandom = math.random
		Floor = math.floor
		-------------------------------------------------------
		--End Good Stuff--
		-------------------------------------------------------
		necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
		RSH, LSH = nil, nil 
		RW = Instance.new("Weld") 
		LW = Instance.new("Weld")
		RH = tors["Right Hip"]
		LH = tors["Left Hip"]
		RSH = tors["Right Shoulder"] 
		LSH = tors["Left Shoulder"] 
		RSH.Parent = nil 
		LSH.Parent = nil 
		RW.Name = "RW"
		RW.Part0 = tors 
		RW.C0 = CF(1.5, 0.5, 0)
		RW.C1 = CF(0, 0.5, 0) 
		RW.Part1 = ra
		RW.Parent = tors 
		LW.Name = "LW"
		LW.Part0 = tors 
		LW.C0 = CF(-1.5, 0.5, 0)
		LW.C1 = CF(0, 0.5, 0) 
		LW.Part1 = la
		LW.Parent = tors
		Effects = {}
		newWeld = function(wp0, wp1, wc0x, wc0y, wc0z)
			local wld = Instance.new("Weld", wp1)
			wld.Part0 = wp0
			wld.Part1 = wp1
			wld.C0 = CFrame.new(wc0x, wc0y, wc0z)
		end
		newWeld(tors, ll, -0.5, -1, 0)
		ll.Weld.C1 = CFrame.new(0, 1, 0)
		newWeld(tors, rl, 0.5, -1, 0)
		rl.Weld.C1 = CFrame.new(0, 1, 0)
		-------------------------------------------------------
		--Start Important Functions--
		-------------------------------------------------------
		function swait(num)
			if num == 0 or num == nil then
				game:service("RunService").Stepped:wait(0)
			else
				for i = 0, num do
					game:service("RunService").Stepped:wait(0)
				end
			end
		end
		function thread(f)
			coroutine.resume(coroutine.create(f))
		end
		function clerp(a, b, t)
			local qa = {
				QuaternionFromCFrame(a)
			}
			local qb = {
				QuaternionFromCFrame(b)
			}
			local ax, ay, az = a.x, a.y, a.z
			local bx, by, bz = b.x, b.y, b.z
			local _t = 1 - t
			return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
		end
		function QuaternionFromCFrame(cf)
			local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
			local trace = m00 + m11 + m22
			if trace > 0 then
				local s = math.sqrt(1 + trace)
				local recip = 0.5 / s
				return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
			else
				local i = 0
				if m00 < m11 then
					i = 1
				end
				if m22 > (i == 0 and m00 or m11) then
					i = 2
				end
				if i == 0 then
					local s = math.sqrt(m00 - m11 - m22 + 1)
					local recip = 0.5 / s
					return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
				elseif i == 1 then
					local s = math.sqrt(m11 - m22 - m00 + 1)
					local recip = 0.5 / s
					return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
				elseif i == 2 then
					local s = math.sqrt(m22 - m00 - m11 + 1)
					local recip = 0.5 / s
					return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
				end
			end
		end
		function QuaternionToCFrame(px, py, pz, x, y, z, w)
			local xs, ys, zs = x + x, y + y, z + z
			local wx, wy, wz = w * xs, w * ys, w * zs
			local xx = x * xs
			local xy = x * ys
			local xz = x * zs
			local yy = y * ys
			local yz = y * zs
			local zz = z * zs
			return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
		end
		function QuaternionSlerp(a, b, t)
			local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
			local startInterp, finishInterp
			if cosTheta >= 1.0E-4 then
				if 1 - cosTheta > 1.0E-4 then
					local theta = math.acos(cosTheta)
					local invSinTheta = 1 / Sin(theta)
					startInterp = Sin((1 - t) * theta) * invSinTheta
					finishInterp = Sin(t * theta) * invSinTheta
				else
					startInterp = 1 - t
					finishInterp = t
				end
			elseif 1 + cosTheta > 1.0E-4 then
				local theta = math.acos(-cosTheta)
				local invSinTheta = 1 / Sin(theta)
				startInterp = Sin((t - 1) * theta) * invSinTheta
				finishInterp = Sin(t * theta) * invSinTheta
			else
				startInterp = t - 1
				finishInterp = t
			end
			return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
		end
		function rayCast(Position, Direction, Range, Ignore)
			return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
		end
		local RbxUtility = LoadLibrary("RbxUtility")
		local Create = RbxUtility.Create

		-------------------------------------------------------
		--Start Damage Function--
		-------------------------------------------------------
		function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
			return true
		end
		-------------------------------------------------------
		--End Damage Function--
		-------------------------------------------------------

		-------------------------------------------------------
		--Start Damage Function Customization--
		-------------------------------------------------------
		function ShowDamage(Pos, Text, Time, Color)
			local Rate = (1 / 30)
			local Pos = (Pos or Vector3.new(0, 0, 0))
			local Text = (Text or "")
			local Time = (Time or 2)
			local Color = (Color or Color3.new(1, 0, 1))
			local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
			EffectPart.Anchored = true
			local BillboardGui = Create("BillboardGui"){
				Size = UDim2.new(3, 0, 3, 0),
				Adornee = EffectPart,
				Parent = EffectPart,
			}
			local TextLabel = Create("TextLabel"){
				BackgroundTransparency = 1,
				Size = UDim2.new(1, 0, 1, 0),
				Text = Text,
				Font = "Bodoni",
				TextColor3 = Color,
				TextScaled = true,
				TextStrokeColor3 = Color3.fromRGB(0,0,0),
				Parent = BillboardGui,
			}
			game.Debris:AddItem(EffectPart, (Time))
			EffectPart.Parent = game:GetService("Workspace")
			delay(0, function()
				local Frames = (Time / Rate)
				for Frame = 1, Frames do
					wait(Rate)
					local Percent = (Frame / Frames)
					EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
					TextLabel.TextTransparency = Percent
				end
				if EffectPart and EffectPart.Parent then
					EffectPart:Destroy()
				end
			end)
		end
		-------------------------------------------------------
		--End Damage Function Customization--
		-------------------------------------------------------

		function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
			for _, c in pairs(workspace:children()) do
				local hum = c:findFirstChild("Humanoid")
				if hum ~= nil then
					local head = c:findFirstChild("Head")
					if head ~= nil then
						local targ = head.Position - Part.Position
						local mag = targ.magnitude
						if magni >= mag and c.Name ~= plr.Name then
							Damage(head, head, mindam, maxdam, knock, Type, root, 0.1, "http://www.roblox.com/asset/?id=0", 1.2)
						end
					end
				end
			end
		end


		CFuncs = {
			Part = {
				Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
					local Part = Create("Part")({
						Parent = Parent,
						Reflectance = Reflectance,
						Transparency = Transparency,
						CanCollide = false,
						Locked = true,
						BrickColor = BrickColor.new(tostring(BColor)),
						Name = Name,
						Size = Size,
						Material = Material
					})
					RemoveOutlines(Part)
					return Part
				end
			},
			Mesh = {
				Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
					local Msh = Create(Mesh)({
						Parent = Part,
						Offset = OffSet,
						Scale = Scale
					})
					if Mesh == "SpecialMesh" then
						Msh.MeshType = MeshType
						Msh.MeshId = MeshId
					end
					return Msh
				end
			},
			Mesh = {
				Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
					local Msh = Create(Mesh)({
						Parent = Part,
						Offset = OffSet,
						Scale = Scale
					})
					if Mesh == "SpecialMesh" then
						Msh.MeshType = MeshType
						Msh.MeshId = MeshId
					end
					return Msh
				end
			},
			Weld = {
				Create = function(Parent, Part0, Part1, C0, C1)
					local Weld = Create("Weld")({
						Parent = Parent,
						Part0 = Part0,
						Part1 = Part1,
						C0 = C0,
						C1 = C1
					})
					return Weld
				end
			},
			Sound = {
				Create = function(id, par, vol, pit)
					coroutine.resume(coroutine.create(function()
						local S = Create("Sound")({
							Volume = vol,
							Pitch = pit or 1,
							SoundId = id,
							Parent = par or workspace
						})
						wait()
						S:play()
						game:GetService("Debris"):AddItem(S, 6)
					end))
				end
			},
			ParticleEmitter = {
				Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
					local fp = Create("ParticleEmitter")({
						Parent = Parent,
						Color = ColorSequence.new(Color1, Color2),
						LightEmission = LightEmission,
						Size = Size,
						Texture = Texture,
						Transparency = Transparency,
						ZOffset = ZOffset,
						Acceleration = Accel,
						Drag = Drag,
						LockedToPart = LockedToPart,
						VelocityInheritance = VelocityInheritance,
						EmissionDirection = EmissionDirection,
						Enabled = Enabled,
						Lifetime = LifeTime,
						Rate = Rate,
						Rotation = Rotation,
						RotSpeed = RotSpeed,
						Speed = Speed,
						VelocitySpread = VelocitySpread
					})
					return fp
				end
			}
		}
		function RemoveOutlines(part)
			part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
		end
		function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part")({
				formFactor = FormFactor,
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material
			})
			RemoveOutlines(Part)
			return Part
		end
		function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
		function CreateWeld(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld")({
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1
			})
			return Weld
		end


		-------------------------------------------------------
		--Start Effect Function--
		-------------------------------------------------------
		EffectModel = Instance.new("Model", char)
		Effects = {
			Block = {
				Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
					local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
					prt.Anchored = true
					prt.CFrame = cframe
					local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
					game:GetService("Debris"):AddItem(prt, 10)
					if Type == 1 or Type == nil then
						table.insert(Effects, {
							prt,
							"Block1",
							delay,
							x3,
							y3,
							z3,
							msh
						})
					elseif Type == 2 then
						table.insert(Effects, {
							prt,
							"Block2",
							delay,
							x3,
							y3,
							z3,
							msh
						})
					else
						table.insert(Effects, {
							prt,
							"Block3",
							delay,
							x3,
							y3,
							z3,
							msh
						})
					end
				end
			},
			Sphere = {
				Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
					local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
					prt.Anchored = true
					prt.CFrame = cframe
					local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
					game:GetService("Debris"):AddItem(prt, 10)
					table.insert(Effects, {
						prt,
						"Cylinder",
						delay,
						x3,
						y3,
						z3,
						msh
					})
				end
			},
			Cylinder = {
				Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
					local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
					prt.Anchored = true
					prt.CFrame = cframe
					local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
					game:GetService("Debris"):AddItem(prt, 10)
					table.insert(Effects, {
						prt,
						"Cylinder",
						delay,
						x3,
						y3,
						z3,
						msh
					})
				end
			},
			Wave = {
				Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
					local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
					prt.Anchored = true
					prt.CFrame = cframe
					local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
					game:GetService("Debris"):AddItem(prt, 10)
					table.insert(Effects, {
						prt,
						"Cylinder",
						delay,
						x3 / 60,
						y3 / 60,
						z3 / 60,
						msh
					})
				end
			},
			Ring = {
				Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
					local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
					prt.Anchored = true
					prt.CFrame = cframe
					local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
					game:GetService("Debris"):AddItem(prt, 10)
					table.insert(Effects, {
						prt,
						"Cylinder",
						delay,
						x3,
						y3,
						z3,
						msh
					})
				end
			},
			Break = {
				Create = function(brickcolor, cframe, x1, y1, z1)
					local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
					prt.Anchored = true
					prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
					local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
					local num = math.random(10, 50) / 1000
					game:GetService("Debris"):AddItem(prt, 10)
					table.insert(Effects, {
						prt,
						"Shatter",
						num,
						prt.CFrame,
						math.random() - math.random(),
						0,
						math.random(50, 100) / 100
					})
				end
			},
			Spiral = {
				Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
					local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
					prt.Anchored = true
					prt.CFrame = cframe
					local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
					game:GetService("Debris"):AddItem(prt, 10)
					table.insert(Effects, {
						prt,
						"Cylinder",
						delay,
						x3,
						y3,
						z3,
						msh
					})
				end
			},
			Push = {
				Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
					local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
					prt.Anchored = true
					prt.CFrame = cframe
					local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
					game:GetService("Debris"):AddItem(prt, 10)
					table.insert(Effects, {
						prt,
						"Cylinder",
						delay,
						x3,
						y3,
						z3,
						msh
					})
				end
			}
		}
		function part(formfactor ,parent, reflectance, transparency, brickcolor, name, size)
			local fp = IT("Part")
			fp.formFactor = formfactor 
			fp.Parent = parent
			fp.Reflectance = reflectance
			fp.Transparency = transparency
			fp.CanCollide = false 
			fp.Locked = true
			fp.BrickColor = brickcolor
			fp.Name = name
			fp.Size = size
			fp.Position = tors.Position 
			RemoveOutlines(fp)
			fp.Material = "SmoothPlastic"
			fp:BreakJoints()
			return fp 
		end 

		function mesh(Mesh,part,meshtype,meshid,offset,scale)
			local mesh = IT(Mesh) 
			mesh.Parent = part
			if Mesh == "SpecialMesh" then
				mesh.MeshType = meshtype
				if meshid ~= "nil" then
					mesh.MeshId = "http://www.roblox.com/asset/?id="..meshid
				end
			end
			mesh.Offset = offset
			mesh.Scale = scale
			return mesh
		end

		function Magic(bonuspeed, type, pos, scale, value, color, MType)
			local type = type
			local rng = Instance.new("Part", char)
			rng.Anchored = true
			rng.BrickColor = color
			rng.CanCollide = false
			rng.FormFactor = 3
			rng.Name = "Ring"
			rng.Material = "Neon"
			rng.Size = Vector3.new(1, 1, 1)
			rng.Transparency = 0
			rng.TopSurface = 0
			rng.BottomSurface = 0
			rng.CFrame = pos
			local rngm = Instance.new("SpecialMesh", rng)
			rngm.MeshType = MType
			rngm.Scale = scale
			local scaler2 = 1
			if type == "Add" then
				scaler2 = 1 * value
			elseif type == "Divide" then
				scaler2 = 1 / value
			end
			coroutine.resume(coroutine.create(function()
				for i = 0, 10 / bonuspeed, 0.1 do
					swait()
					if type == "Add" then
						scaler2 = scaler2 - 0.01 * value / bonuspeed
					elseif type == "Divide" then
						scaler2 = scaler2 - 0.01 / value * bonuspeed
					end
					rng.Transparency = rng.Transparency + 0.01 * bonuspeed
					rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
				end
				rng:Destroy()
			end))
		end

		function Eviscerate(dude)
			if dude.Name ~= char then
				local bgf = IT("BodyGyro", dude.Head)
				bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
				local val = IT("BoolValue", dude)
				val.Name = "IsHit"
				local ds = coroutine.wrap(function()
					dude:WaitForChild("Head"):BreakJoints()
					wait(0.5)
					target = nil
					coroutine.resume(coroutine.create(function()
						for i, v in pairs(dude:GetChildren()) do
							if v:IsA("Accessory") then
								v:Destroy()
							end
							if v:IsA("Humanoid") then
								v:Destroy()
							end
							if v:IsA("CharacterMesh") then
								v:Destroy()
							end
							if v:IsA("Model") then
								v:Destroy()
							end
							if v:IsA("Part") or v:IsA("MeshPart") then
								for x, o in pairs(v:GetChildren()) do
									if o:IsA("Decal") then
										o:Destroy()
									end
								end
								coroutine.resume(coroutine.create(function()
									v.Material = "Neon"
									v.CanCollide = false
									local PartEmmit1 = IT("ParticleEmitter", v)
									PartEmmit1.LightEmission = 1
									PartEmmit1.Texture = "rbxassetid://284205403"
									PartEmmit1.Color = ColorSequence.new(maincolor.Color)
									PartEmmit1.Rate = 150
									PartEmmit1.Lifetime = NumberRange.new(1)
									PartEmmit1.Size = NumberSequence.new({
										NumberSequenceKeypoint.new(0, 0.75, 0),
										NumberSequenceKeypoint.new(1, 0, 0)
									})
									PartEmmit1.Transparency = NumberSequence.new({
										NumberSequenceKeypoint.new(0, 0, 0),
										NumberSequenceKeypoint.new(1, 1, 0)
									})
									PartEmmit1.Speed = NumberRange.new(0, 0)
									PartEmmit1.VelocitySpread = 30000
									PartEmmit1.Rotation = NumberRange.new(-500, 500)
									PartEmmit1.RotSpeed = NumberRange.new(-500, 500)
									local BodPoss = IT("BodyPosition", v)
									BodPoss.P = 3000
									BodPoss.D = 1000
									BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
									BodPoss.position = v.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
									v.Color = maincolor.Color
									coroutine.resume(coroutine.create(function()
										for i = 0, 49 do
											swait(1)
											v.Transparency = v.Transparency + 0.08
										end
										wait(0.5)
										PartEmmit1.Enabled = false
										wait(3)
										v:Destroy()
										dude:Destroy()
									end))
								end))
							end
						end
					end))
				end)
				ds()
			end
		end

		function FindNearestHead(Position, Distance, SinglePlayer)
			if SinglePlayer then
				return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
			end
			local List = {}
			for i, v in pairs(workspace:GetChildren()) do
				if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
					table.insert(List, v)
				end
			end
			return List
		end

		function Aura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos, MType)
			local type = type
			local rng = Instance.new("Part", char)
			rng.Anchored = true
			rng.BrickColor = color
			rng.CanCollide = false
			rng.FormFactor = 3
			rng.Name = "Ring"
			rng.Material = "Neon"
			rng.Size = Vector3.new(1, 1, 1)
			rng.Transparency = 0
			rng.TopSurface = 0
			rng.BottomSurface = 0
			rng.CFrame = pos
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
			local rngm = Instance.new("SpecialMesh", rng)
			rngm.MeshType = MType
			rngm.Scale = Vector3.new(x1, y1, z1)
			local scaler2 = 1
			local speeder = FastSpeed
			if type == "Add" then
				scaler2 = 1 * value
			elseif type == "Divide" then
				scaler2 = 1 / value
			end
			coroutine.resume(coroutine.create(function()
				for i = 0, 10 / bonuspeed, 0.1 do
					swait()
					if type == "Add" then
						scaler2 = scaler2 - 0.01 * value / bonuspeed
					elseif type == "Divide" then
						scaler2 = scaler2 - 0.01 / value * bonuspeed
					end
					speeder = speeder - 0.01 * FastSpeed * bonuspeed
					rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
					rng.Transparency = rng.Transparency + 0.01 * bonuspeed
					rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
				end
				rng:Destroy()
			end))
		end

		function SoulSteal(dude)
			if dude.Name ~= char then
				local bgf = IT("BodyGyro", dude.Head)
				bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
				local val = IT("BoolValue", dude)
				val.Name = "IsHit"
				local torso = (dude:FindFirstChild'Head' or dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso' or dude:FindFirstChild'LowerTorso' or dude:FindFirstChild'HumanoidRootPart')
				local soulst = coroutine.wrap(function()
					local soul = Instance.new("Part",dude)
					soul.Size = Vector3.new(1,1,1)
					soul.CanCollide = false
					soul.Anchored = false
					soul.Position = torso.Position
					soul.Transparency = 1
					local PartEmmit1 = IT("ParticleEmitter", soul)
					PartEmmit1.LightEmission = 1
					PartEmmit1.Texture = "rbxassetid://569507414"
					PartEmmit1.Color = ColorSequence.new(maincolor.Color)
					PartEmmit1.Rate = 250
					PartEmmit1.Lifetime = NumberRange.new(1.6)
					PartEmmit1.Size = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 1, 0),
						NumberSequenceKeypoint.new(1, 0, 0)
					})
					PartEmmit1.Transparency = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0, 0),
						NumberSequenceKeypoint.new(1, 1, 0)
					})
					PartEmmit1.Speed = NumberRange.new(0, 0)
					PartEmmit1.VelocitySpread = 30000
					PartEmmit1.Rotation = NumberRange.new(-360, 360)
					PartEmmit1.RotSpeed = NumberRange.new(-360, 360)
					local BodPoss = IT("BodyPosition", soul)
					BodPoss.P = 3000
					BodPoss.D = 1000
					BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
					BodPoss.position = torso.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
					wait(1.6)
					soul.Touched:connect(function(hit)
						if hit.Parent == char then
							soul:Destroy()
						end
					end)
					wait(1.2)
					while soul do
						swait()
						PartEmmit1.Color = ColorSequence.new(maincolor.Color)
						BodPoss.Position = tors.Position
					end
				end)
				soulst()
			end
		end
		function FaceMouse()
			local	Cam = workspace.CurrentCamera
			return {
				CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
				Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
			}
		end
		Effects = {
			Block = function(cf,partsize,meshstart,meshadd,matr,colour,spin,inverse,factor)
				local p = Instance.new("Part",EffectModel)
				p.BrickColor = BrickColor.new(colour)
				p.Size = partsize
				p.Anchored = true
				p.CanCollide = false
				p.Material = matr
				p.CFrame = cf
				if inverse == true then
					p.Transparency = 1
				else
					p.Transparency = 0
				end
				local m = Instance.new("BlockMesh",p)
				m.Scale = meshstart
				coroutine.wrap(function()
					for i = 0, 1, factor do
						swait()
						if inverse == true then
							p.Transparency = 1-i
						else
							p.Transparency = i
						end
						m.Scale = m.Scale + meshadd
						if spin == true then
							p.CFrame = p.CFrame * CFrame.Angles(math.random(-50,50),math.random(-50,50),math.random(-50,50))
						end
					end
					p:Destroy()
				end)()
				return p
			end,
			Sphere = function(cf,partsize,meshstart,meshadd,matr,colour,inverse,factor)
				local p = Instance.new("Part",EffectModel)
				p.BrickColor = BrickColor.new(colour)
				p.Size = partsize
				p.Anchored = true
				p.CanCollide = false
				p.Material = matr
				p.CFrame = cf
				if inverse == true then
					p.Transparency = 1
				else
					p.Transparency = 0
				end
				local m = Instance.new("SpecialMesh",p)
				m.MeshType = "Sphere"
				m.Scale = meshstart
				coroutine.wrap(function()
					for i=0,1,factor do
						swait()
						if inverse == true then
							p.Transparency = 1-i
						else
							p.Transparency = i
						end
						m.Scale = m.Scale + meshadd
					end
					p:Destroy()
				end)()
				return p
			end,

			Cylinder = function(cf,partsize,meshstart,meshadd,matr,colour,inverse,factor)
				local p = Instance.new("Part",EffectModel)
				p.BrickColor = BrickColor.new(colour)
				p.Size = partsize
				p.Anchored = true
				p.CanCollide = false
				p.Material = matr
				p.CFrame = cf
				if inverse == true then
					p.Transparency = 1
				else
					p.Transparency = 0
				end
				local m = Instance.new("CylinderMesh",p)
				m.Scale = meshstart
				coroutine.wrap(function()
					for i=0,1,factor do
						swait()
						if inverse == true then
							p.Transparency = 1-i
						else
							p.Transparency = i
						end
						m.Scale = m.Scale + meshadd
					end
					p:Destroy()
				end)()
				return p
			end,

			Wave = function(cf,meshstart,meshadd,colour,spin,inverse,factor)
				local p = Instance.new("Part",EffectModel)
				p.BrickColor = BrickColor.new(colour)
				p.Size = Vector3.new()
				p.Anchored = true
				p.CanCollide = false
				p.CFrame = cf
				if inverse == true then
					p.Transparency = 1
				else
					p.Transparency = 0
				end
				local m = Instance.new("SpecialMesh",p)
				m.MeshId = "rbxassetid://20329976"
				m.Scale = meshstart
				coroutine.wrap(function()
					for i=0,1,factor do
						swait()
						if inverse == true then
							p.Transparency = 1-i
						else
							p.Transparency = i
						end
						m.Scale = m.Scale + meshadd
						p.CFrame = p.CFrame * CFrame.Angles(0,math.rad(spin),0)
					end
					p:Destroy()
				end)()
				return p
			end,

			Ring = function(cf,meshstart,meshadd,colour,inverse,factor)
				local p = Instance.new("Part",EffectModel)
				p.BrickColor = BrickColor.new(colour)
				p.Size = Vector3.new()
				p.Anchored = true
				p.CanCollide = false
				p.CFrame = cf
				if inverse == true then
					p.Transparency = 1
				else
					p.Transparency = 0
				end
				local m = Instance.new("SpecialMesh",p)
				m.MeshId = "rbxassetid://3270017"
				m.Scale = meshstart
				coroutine.wrap(function()
					for i=0,1,factor do
						swait()
						if inverse == true then
							p.Transparency = 1-i
						else
							p.Transparency = i
						end
						m.Scale = m.Scale + meshadd
					end
					p:Destroy()
				end)()
				return p
			end,

			Meshed = function(cf,meshstart,meshadd,colour,meshid,textid,spin,inverse,factor)
				local p = Instance.new("Part",EffectModel)
				p.BrickColor = BrickColor.new(colour)
				p.Size = Vector3.new()
				p.Anchored = true
				p.CanCollide = false
				p.CFrame = cf
				if inverse == true then
					p.Transparency = 1
				else
					p.Transparency = 0
				end
				local m = Instance.new("SpecialMesh",p)
				m.MeshId = meshid
				m.TextureId = textid
				m.Scale = meshstart
				coroutine.wrap(function()
					for i=0,1,factor do
						swait()
						if inverse == true then
							p.Transparency = 1-i
						else
							p.Transparency = i
						end
						m.Scale = m.Scale + meshadd
						p.CFrame = p.CFrame * CFrame.Angles(0,math.rad(spin),0)
					end
					p:Destroy()
				end)()
				return p
			end,

			Explode = function(cf,partsize,meshstart,meshadd,matr,colour,move,inverse,factor)
				local p = Instance.new("Part",EffectModel)
				p.BrickColor = BrickColor.new(colour)
				p.Size = partsize
				p.Anchored = true
				p.CanCollide = false
				p.Material = matr
				p.CFrame = cf * CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
				if inverse == true then
					p.Transparency = 1
				else
					p.Transparency = 0
				end
				local m = Instance.new("SpecialMesh",p)
				m.MeshType = "Sphere"
				m.Scale = meshstart
				coroutine.wrap(function()
					for i=0,1,factor do
						swait()
						if inverse == true then
							p.Transparency = 1-i
						else
							p.Transparency = i
						end
						m.Scale = m.Scale + meshadd
						p.CFrame = p.CFrame * CFrame.new(0,move,0)
					end
					p:Destroy()
				end)()
				return p
			end,

		}
		-------------------------------------------------------
		--End Effect Function--
		-------------------------------------------------------
		function Cso(ID, PARENT, VOLUME, PITCH)
			local NSound = nil
			coroutine.resume(coroutine.create(function()
				NSound = IT("Sound", PARENT)
				NSound.Volume = VOLUME
				NSound.Pitch = PITCH
				NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
				swait()
				NSound:play()
				game:GetService("Debris"):AddItem(NSound, 10)
			end))
			return NSound
		end
		function CamShake(Length, Intensity)
			coroutine.resume(coroutine.create(function()
				local intensity = 1 * Intensity
				local rotM = 0.01 * Intensity
				for i = 0, Length, 0.1 do
					swait()
					intensity = intensity - 0.05 * Intensity / Length
					rotM = rotM - 5.0E-4 * Intensity / Length
					hum.CameraOffset = Vector3.new(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)))
					cam.CFrame = cam.CFrame * CF(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity))) * Euler(Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM)
				end
				hum.CameraOffset = Vector3.new(0, 0, 0)
			end))
		end
		NewInstance = function(instance,parent,properties)
			local inst = Instance.new(instance)
			inst.Parent = parent
			if(properties)then
				for i,v in next, properties do
					pcall(function() inst[i] = v end)
				end
			end
			return inst;
		end
		hum.MaxHealth = 1.0E298
		hum.Health = 1.0E298
		game:GetService("RunService"):BindToRenderStep("HOT", 0, function()
			if hum.Health > 0.1 and hum.Health < 1.0E298 then
				hum.MaxHealth = 1.0E298
				hum.Health = 1.0E298
			end
		end)
		-------------------------------------------------------
		--End Important Functions--
		-------------------------------------------------------


		-------------------------------------------------------
		--Start Customization--
		-------------------------------------------------------
		local Player_Size = 1
		if Player_Size ~= 1 then
			root.Size = root.Size * Player_Size
			tors.Size = tors.Size * Player_Size
			hed.Size = hed.Size * Player_Size
			ra.Size = ra.Size * Player_Size
			la.Size = la.Size * Player_Size
			rl.Size = rl.Size * Player_Size
			ll.Size = ll.Size * Player_Size
			----------------------------------------------------------------------------------
			rootj.Parent = root
			neck.Parent = tors
			RW.Parent = tors
			LW.Parent = tors
			RH.Parent = tors
			LH.Parent = tors
			----------------------------------------------------------------------------------
			rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
			rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
			neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
			neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
			RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
			LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
			----------------------------------------------------------------------------------
			RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
			LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
			RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
			LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
			--hat.Parent = Character
		end
		----------------------------------------------------------------------------------
		local SONG = 525565668
		local SONG2 = 0
		local Music = Instance.new("Sound",tors)
		Music.Volume = 2.5
		Music.Looped = true
		Music.Pitch = 1 --Pitcher
		----------------------------------------------------------------------------------
		local equipped = false
		local idle = 0
		local change = 1
		local val = 0
		local toim = 0
		local idleanim = 0.4
		local sine = 0
		local Sit = 1
		local WasAir = false
		local InAir = false
		local LandTick = 0
		local movelegs = false
		local FF = Instance.new("ForceField",char)
		FF.Visible = false
		local Speed = 56
		local Chips = "onebearnakedwoman"
		----------------------------------------------------------------------------------
		hum.JumpPower = 55
		hum.Animator.Parent = nil
		----------------------------------------------------------------------------------
		Chips = IT("Model")
		Chips.Parent = char
		Chips.Name = "Chips"
		RHe = IT("Part")
		RHe.Parent = Chips
		RHe.BrickColor = BrickColor.new("Really black")
		RHe.Locked = true
		RHe.CanCollide = false
		RHe.Transparency = 0
		PMesh = IT("SpecialMesh")
		RHe.formFactor =  "Symmetric"
		PMesh.MeshType = "FileMesh"
		PMesh.MeshId = "rbxassetid://19106014"
		PMesh.TextureId = "rbxassetid://342435650"
		PMesh.Scale = Vector3.new(1, 1.4, 0.8)
		PMesh.Parent = RHe
		local RWeld = IT("Weld")
		RWeld.Parent = RHe
		RWeld.Part0 = RHe
		RWeld.Part1 = ra
		RWeld.C0 = CF(-1.2, -0.5, 0) * angles(Rad(90), Rad(0), Rad(90))
		-------------------------------------------------------
		--End Customization--
		-------------------------------------------------------


		-------------------------------------------------------
		--Start Attacks N Stuff--
		-------------------------------------------------------
		function AttackTemplate()
			attack = true
			for i = 0, 2, 0.1 do
				swait()
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.1)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.1)
				ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0 + 5 * Sin(sine / 20)), Rad(10 + 5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.1)
			end
			attack = false
		end
		function HitboxFunction(Pose, lifetime, siz1, siz2, siz3, Radie, Min, Max, kb, atype)
			local Hitboxpart = Instance.new("Part", EffectModel)
			RemoveOutlines(Hitboxpart)
			Hitboxpart.Size = Vector3.new(siz1, siz2, siz3)
			Hitboxpart.CanCollide = false
			Hitboxpart.Transparency = 1
			Hitboxpart.Anchored = true
			Hitboxpart.CFrame = Pose
			game:GetService("Debris"):AddItem(Hitboxpart, lifetime)
			MagniDamage(Hitboxpart, Radie, Min, Max, kb, atype)
		end
		wait2 = false
		combo = 1
		mouse.Button1Down:connect(function(key)
			if attack == false then
				attack = true
				Speed = 3.01
				if combo == 1 and wait2 == false then
					wait2 = true
					for i = 0, 1.6, 0.1 do
						swait()
						rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-45)), 0.2)
						neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(45)), 0.2)
						rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-45), Rad(0)) * angles(Rad(0), Rad(0), Rad(15)), 0.2)
						ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-15)), 0.2)
						RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(180), Rad(0 + 5 * Sin(sine / 20)), Rad(25 + 5 * Sin(sine / 20))), 0.2)
						LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.2)
					end
					Cso("138097048", ra, 1.2, 0.8)
					HitboxFunction(ra.CFrame, 0.01, 1, 1, 1, 7, 6, 9, 3, "Normal")
					for i = 0, 1.2, 0.1 do
						swait()
						rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(20), Rad(0), Rad(45)), 0.3)
						neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(20 - 5 * Sin(sine / 20)), Rad(0), Rad(-45)), 0.3)
						rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(20), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(15)), 0.3)
						ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(45), Rad(0)) * angles(Rad(0), Rad(0), Rad(-15)), 0.3)
						RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(85), Rad(0 + 5 * Sin(sine / 20)), Rad(45 + 5 * Sin(sine / 20))), 0.3)
						LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-45), Rad(0 - 5 * Sin(sine / 20)), Rad(-25 - 5 * Sin(sine / 20))), 0.3)
					end
					combo = 1
				end
				Speed = 56
				wait2 = false
				attack = false
			end
		end)
		function Taunt()
			attack = true
			Speed = 3
			if Chips == "onebearnakedwoman" then
				local Munch = Cso("1575472350", hed, 5, 1)
				swait(2)
				repeat
					swait()
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.2 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.3)
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-35 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.3)
					rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.3)
					ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.3)
					RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.1 + 0.1 * Sin(sine / 20)* Player_Size, -0.6* Player_Size) * angles(Rad(160), Rad(0), Rad(-35)), 0.1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.3)
				until Munch.Playing == false
			elseif Chips == "layonme" then
				for i = 0, 6, 0.1 do
					swait()
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0 - 255.45 * i)), 0.15)
					rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.1)
					ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(30 + 5 * Sin(sine / 20)), Rad(45 + 5 * Sin(sine / 20))), 0.1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(-30 - 5 * Sin(sine / 20)), Rad(-45 - 5 * Sin(sine / 20))), 0.1)
				end
			elseif Chips == "howitfeelstochew5gum" then
				local Munch = Cso("1575472350", hed, 5, 1)
				swait(2)
				repeat
					swait()
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.2 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.3)
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-35 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.3)
					rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.3)
					ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.3)
					RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.1 + 0.1 * Sin(sine / 20)* Player_Size, -0.6* Player_Size) * angles(Rad(160), Rad(0), Rad(-35)), 0.1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.3)
				until Munch.Playing == false
				Cso("172324194", hed, 5, 1)
				for i = 0, 5, 0.1 do
					swait()
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.2 * Player_Size) * angles(Rad(-20), Rad(0), Rad(0)), 0.3)
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-35), Rad(0), Rad(0)), 0.3)
					rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 * Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.3)
					ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 * Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.3)
					RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.1* Player_Size, -0.6* Player_Size) * angles(Rad(160), Rad(0), Rad(-35)), 0.1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(0), Rad(-10)), 0.3)
				end
				local RUN = Cso("957655044", hed, 5, 1)
				swait(2)
				repeat
					swait()
					Speed = 56
					local WALKSPEEDVALUE = 6 / (hum.WalkSpeed / 16)
					root.Velocity = root.CFrame.lookVector * 75
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.3 - 0.65 * Cos(sine / ( WALKSPEEDVALUE / 2 ))) * angles(Rad(-25), Rad(0), Rad(0 - 1.75 * Cos(sine / ( WALKSPEEDVALUE / 2))) + root.RotVelocity.Y / 75), 0.1)
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-20 + 5 * Sin(sine / (WALKSPEEDVALUE / 2))), Rad(0), Rad(0) + root.RotVelocity.Y / 13), 0.1)
					rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.8 - 0.5 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size, 0.6 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size)  * angles(Rad(-15 - 95 * Cos(sine / WALKSPEEDVALUE)) - root.RotVelocity.Y / 75 + -Sin(sine / WALKSPEEDVALUE) / 2.5, Rad(0 - 10 * Cos(sine / WALKSPEEDVALUE)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / WALKSPEEDVALUE)), Rad(0), Rad(0)), 0.3)
					ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.8 + 0.5 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size, -0.6 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size) * angles(Rad(-15 + 95 * Cos(sine / WALKSPEEDVALUE)) + root.RotVelocity.Y / -75 + Sin(sine / WALKSPEEDVALUE) / 2.5, Rad(0 - 10 * Cos(sine / WALKSPEEDVALUE)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / WALKSPEEDVALUE)), Rad(0), Rad(0)), 0.3)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / WALKSPEEDVALUE)* Player_Size, 0* Player_Size) * angles(Rad(215), Rad(0), Rad(45)), 0.1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / WALKSPEEDVALUE)* Player_Size, 0* Player_Size) * angles(Rad(215), Rad(0), Rad(-45)), 0.1)
				until RUN.Playing == false
			elseif Chips == "5gumdowngrade" then
				Cso("1826625760", hed, 5, 1)
				for i = 0, 5, 0.1 do
					swait()
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(20 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.1)
					rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.1)
					ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0 + 5 * Sin(sine / 20)), Rad(10 + 5 * Sin(sine / 20))), 0.1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.1)
				end
			end
			Speed = 56
			movelegs = false
			attack = false
		end
		function Gum()
			attack = true
			Speed = 0
			local Senses = Cso("605297168", hed, 6, 1)
			swait(2)
			repeat
				swait()
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(20)), 0.2)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(-20)), 0.2)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.2)
				ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.2)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0 + 5 * Sin(sine / 20)), Rad(10 + 5 * Sin(sine / 20))), 0.2)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(-90)), 0.2)
			until Senses.TimePosition > 2.7
			for i = 0, 3, 0.1 do
				swait()
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size) * angles(Rad(-30), Rad(0), Rad(0)), 0.5)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 0.5)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.5)
				ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(10)), 0.5)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(-90)), 0.5)
			end
			root.Anchored = true
			repeat
				swait()
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -2.7 + 0.1* Player_Size) * angles(Rad(90), Rad(0), Rad(0)), 0.5)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 0.5)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.5)
				ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(10)), 0.5)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(-90)), 0.5)
			until Senses.Playing == false
			Speed = 56
			attack = false
			root.Anchored = false
		end
		function OHHHHHHH()
			attack = true
			Speed = 0
			Cso("663306786", tors, 3, 1)
			for i = 0, 12, 0.1 do
				swait()
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0 + 1 * i * Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.1)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(20 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.1)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(47), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.1)
				ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(75), Rad(0 + 5 * Sin(sine / 20)), Rad(10 + 5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(143), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.1)
			end
			Cso("663307468", tors, 6, 1)
			for i = 0, 6, 0.1 do
				swait()
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 4500 * Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(20 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.1)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(47), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.1)
				ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(75), Rad(0 + 5 * Sin(sine / 20)), Rad(10 + 5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(156), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.1)
			end
			Speed = 56
			attack = false
		end
		function WoodyGotWood()
			attack = true
			Speed = 0
			local Woodlenny = Cso("1764642350", hed, 6, 1)
			swait(2)
			repeat
				swait()
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 5)) * angles(Rad(20), Rad(0), Rad(5)), 0.2)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(20), Rad(0), Rad(-5 - 15 * Sin(sine / 20))), 0.2)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 5)* Player_Size, 0* Player_Size) * angles(Rad(20), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.2)
				ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 5)* Player_Size, 0* Player_Size) * angles(Rad(20), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.2)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 5)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(10)), 0.2)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 5)* Player_Size, 0* Player_Size) * angles(Rad(20), Rad(0), Rad(-10)), 0.2)
			until Woodlenny.TimePosition > 3.6
			root.Anchored = true
			repeat
				swait()
				for i = 0, 2, 0.1 do
					swait()
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -2.7 + 0.1* Player_Size) * angles(Rad(-90), Rad(0), Rad(0)), 0.5)
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 0.5)
					rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.5)
					ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.5)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(90)), 0.5)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(-90)), 0.5)
				end
				for i = 0, 1.6, 0.1 do
					swait()
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -2.4 + 0.1* Player_Size) * angles(Rad(-90), Rad(0), Rad(0)), 0.5)
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 0.5)
					rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.5)
					ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.5)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(75)), 0.5)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(-75)), 0.5)
				end
			until Woodlenny.Playing == false
			Speed = 56
			attack = false
			root.Anchored = false
		end
		-------------------------------------------------------
		--End Attacks N Stuff--
		-------------------------------------------------------
		mouse.KeyDown:connect(function(key)
			if attack == false then
				if key == "t" then
					Taunt()
				elseif key == "z" then
					Gum()
				elseif key == "x" then
					OHHHHHHH()
				elseif key == "c" then
					WoodyGotWood() 
				elseif key == "f" then
					SONG = 690663957
					Music.TimePosition = 0
					PMesh.TextureId = "rbxassetid://206977326"
					Chips = "cheesexd"

				elseif key == "m" then
					SONG = 525565668
					Music.TimePosition = 0
					PMesh.TextureId = "rbxassetid://342435650"
					Chips = "onebearnakedwoman"
				elseif key == "n" then
					SONG = 937445925
					Music.TimePosition = 0
					PMesh.TextureId = "rbxassetid://342436716"
					Chips = "layonme"
				elseif key == "b" then
					SONG = 1386299751
					Music.TimePosition = 0
					PMesh.TextureId = "rbxassetid://341999291"
					Chips = "howitfeelstochew5gum"
				elseif key == "v" then
					SONG = 554967156
					Music.TimePosition = 0
					PMesh.TextureId = "rbxassetid://341999245"
					Chips = "5gumdowngrade"
				end
			end
		end)








		-------------------------------------------------------
		--Start Animations--
		-------------------------------------------------------
		while true do
			swait()
			sine = sine + change
			local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
			local velderp = root.Velocity.y
			hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, workspace[plr.Name])
			if equipped == true or equipped == false then
				if attack == false then
					idle = idle + 1
				else
					idle = 0
				end
				local Landed = false
				if(hitfloor)then
					WasAir = false
				else
					WasAir = true
				end
				if(WasAir == false)then
					if(InAir == true)then
						LandTick = time()
						Landed = true
					end
				end
				if(time()-LandTick < .3)then
					Landed = true
				end
				if(hitfloor)then
					InAir = false
				else
					InAir = true
				end
				local WALKSPEEDVALUE = 6 / (hum.WalkSpeed / 16)
				local Walking = (math.abs(root.Velocity.x) > 1 or math.abs(root.Velocity.z) > 1)
				local State = (hum.PlatformStand and 'Paralyzed' or hum.Sit and 'Sit' or Landed and 'Land' or not hitfloor and root.Velocity.y < -1 and "Fall" or not hitfloor and root.Velocity.y > 1 and "Jump" or hitfloor and Walking and "Walk" or hitfloor and "Idle")
				if(State == 'Jump')then
					hum.JumpPower = 55
					if attack == false then
						rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.1)
						neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
						rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -.2 - 0.1 * Cos(sine / 20), -.3* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(0)), 0.1)
						ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -.9 - 0.1 * Cos(sine / 20), -.5* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(0)), 0.1)
						RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
						LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
					end
				elseif(State == 'Fall')then
					if attack == false then
						rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(25), Rad(0), Rad(0)), 0.1)
						neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
						rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(25), Rad(0), Rad(0)), 0.1)
						ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(25), Rad(0), Rad(0)), 0.1)
						RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(165), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
						LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(165), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
					end
				elseif(State == 'Land')then
					hum.JumpPower = 0
					if attack == false then
						rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(10), Rad(0), Rad(0)), 0.15)
						neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(35 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
						rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, 0.1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(-3.5), Rad(0), Rad(5)), 0.15)
						ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, 0.1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(-3.5), Rad(0), Rad(-5)), 0.15)
						RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(0), Rad(25 + 4.5 * Sin(sine / 20))), 0.1)
						LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(55), Rad(0), Rad(-25 - 4.5 * Sin(sine / 20))), 0.1)
					end
				elseif(State == 'Idle')then
					change = 1
					if attack == false then
						rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.1)
						neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.1)
						rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.1)
						ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
						RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0 + 15 * Sin(sine / 20)), Rad(0 + 5 * Sin(sine / 20)), Rad(10 + 5 * Sin(sine / 20))), 0.1)
						LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0 + 15 * Sin(sine / 20)), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.1)
					end
				elseif(State == 'Walk')then
					change = 0.55
					hum.JumpPower = 55
					if attack == false then
						rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.3 - 0.65 * Cos(sine / ( WALKSPEEDVALUE / 2 ))) * angles(Rad(-25), Rad(0), Rad(0 - 1.75 * Cos(sine / ( WALKSPEEDVALUE / 2))) + root.RotVelocity.Y / 75), 0.1)
						neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-20 + 5 * Sin(sine / (WALKSPEEDVALUE / 2))), Rad(0), Rad(0) + root.RotVelocity.Y / 13), 0.1)
						rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.8 - 0.5 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size, 0.6 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size)  * angles(Rad(-15 - 95 * Cos(sine / WALKSPEEDVALUE)) - root.RotVelocity.Y / 75 + -Sin(sine / WALKSPEEDVALUE) / 2.5, Rad(0 - 10 * Cos(sine / WALKSPEEDVALUE)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / WALKSPEEDVALUE)), Rad(0), Rad(0)), 0.3)
						ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.8 + 0.5 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size, -0.6 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size) * angles(Rad(-15 + 95 * Cos(sine / WALKSPEEDVALUE)) + root.RotVelocity.Y / -75 + Sin(sine / WALKSPEEDVALUE) / 2.5, Rad(0 - 10 * Cos(sine / WALKSPEEDVALUE)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / WALKSPEEDVALUE)), Rad(0), Rad(0)), 0.3)
						RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / WALKSPEEDVALUE)* Player_Size, 0* Player_Size) * angles(Rad(215), Rad(0), Rad(45)), 0.1)
						LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / WALKSPEEDVALUE)* Player_Size, 0* Player_Size) * angles(Rad(215), Rad(0), Rad(-45)), 0.1)
					elseif attack == true and movelegs == true then
						rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.8 - 0.5 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size, 0.6 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size)  * angles(Rad(-10 - 25 * Cos(sine / WALKSPEEDVALUE)) - root.RotVelocity.Y / 75 + -Sin(sine / WALKSPEEDVALUE) / 2.5, Rad(0 - 10 * Cos(sine / WALKSPEEDVALUE)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / WALKSPEEDVALUE)), Rad(0), Rad(0)), 0.3)
						ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.8 + 0.5 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size, -0.6 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size) * angles(Rad(-10 + 25 * Cos(sine / WALKSPEEDVALUE)) + root.RotVelocity.Y / -75 + Sin(sine / WALKSPEEDVALUE) / 2.5, Rad(0 - 10 * Cos(sine / WALKSPEEDVALUE)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / WALKSPEEDVALUE)), Rad(0), Rad(0)), 0.3)
					end
				end
			end
			hum.Name = "HUM"
			hum.WalkSpeed = Speed
			Music.SoundId = "rbxassetid://"..SONG
			Music.Looped = true
			Music.Pitch = 1
			Music.Volume = 1.5
			Music.Parent = tors
			Music.Playing = true
			if 0 < #Effects then
				for e = 1, #Effects do
					if Effects[e] ~= nil then
						local Thing = Effects[e]
						if Thing ~= nil then
							local Part = Thing[1]
							local Mode = Thing[2]
							local Delay = Thing[3]
							local IncX = Thing[4]
							local IncY = Thing[5]
							local IncZ = Thing[6]
							if 1 >= Thing[1].Transparency then
								if Thing[2] == "Block1" then
									Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
									local Mesh = Thing[1].Mesh
									Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Block2" then
									Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
									local Mesh = Thing[7]
									Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Block3" then
									Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
									local Mesh = Thing[7]
									Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Cylinder" then
									local Mesh = Thing[1].Mesh
									Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Blood" then
									local Mesh = Thing[7]
									Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
									Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Elec" then
									local Mesh = Thing[1].Mesh
									Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Disappear" then
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Shatter" then
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
									Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
									Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
									Thing[6] = Thing[6] + Thing[5]
								end
							else
								Part.Parent = nil
								table.remove(Effects, e)
							end
						end
					end
				end
			end
		end
		-------------------------------------------------------
		--End Animations And Script--
		-------------------------------------------------------
	end)
end
coroutine.wrap(TEWOGV_fake_script)()
local function FBJIJBM_fake_script() -- Spider.LocalScript 
	local script = Instance.new('LocalScript', Spider)

	Spider.MouseButton1Down:connect(function()
		loadstring(game:HttpGetAsync("https://pastebin.com/raw/txsk1LJg"))()
	end)
end
coroutine.wrap(FBJIJBM_fake_script)()
local function RNFFVV_fake_script() -- ShadowBlade.LocalScript 
	local script = Instance.new('LocalScript', ShadowBlade)

	ShadowBlade.MouseButton1Down:connect(function()
		loadstring(game:HttpGetAsync("https://pastebin.com/raw/kMYThpNG"))()
	end)
end
coroutine.wrap(RNFFVV_fake_script)()
local function NSJQM_fake_script() -- RbNeptunion.LocalScript 
	local script = Instance.new('LocalScript', RbNeptunion)

	RbNeptunion.MouseButton1Down:connect(function()
		loadstring(game:HttpGetAsync("https://pastebin.com/raw/gDi503fB"))()
	end)
end
coroutine.wrap(NSJQM_fake_script)()
local function TGJMS_fake_script() -- Neptunion.LocalScript 
	local script = Instance.new('LocalScript', Neptunion)

	Neptunion.MouseButton1Down:connect(function()
		loadstring(game:HttpGetAsync("https://pastebin.com/raw/t0Mkc33N"))()
	end)
end
coroutine.wrap(TGJMS_fake_script)()
local function QGLTKE_fake_script() -- NekoMaid.LocalScript 
	local script = Instance.new('LocalScript', NekoMaid)

	NekoMaid.MouseButton1Down:connect(function()


		-- FE Neko Maid Animations By Creo
		-- Tail that CAN be used https://web.roblox.com/catalog/4645440842/Plain-White-Cat-Tail
		-- For updates on script join this server
		-- https://discord.gg/ad7WVB6Bxf


		local NotificationBindable = Instance.new("BindableFunction")
		local Msgreq = function(Title,Text,Duration,Button1Text,Button2Text)
			game.StarterGui:SetCore("SendNotification", {
				Title = Title;
				Text = Text;
				Icon = "";
				Duration = Duration;
				Button1 = Button1Text;
				Button2 = nil;
				Callback = NotificationBindable;
			})
		end

		Msgreq("FE Neko Anims V1.6","Loading, please wait while it loads",5,nil)
		local SongID = "http://www.roblox.com/asset/?id=198665867"
		Bypass = "death"
		if not Bypass then Bypass = "limbs" end
		HumanDied = false

		CountSCIFIMOVIELOL = 1
		function SCIFIMOVIELOL(Part0,Part1,Position,Angle)
			local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL
			AlignPos.ApplyAtCenterOfMass = true;
			AlignPos.MaxForce = 67752;
			AlignPos.MaxVelocity = math.huge/9e110;
			AlignPos.ReactionForceEnabled = false;
			AlignPos.Responsiveness = 200;
			AlignPos.RigidityEnabled = false;
			local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL
			AlignOri.MaxAngularVelocity = math.huge/9e110;
			AlignOri.MaxTorque = 67752;
			AlignOri.PrimaryAxisOnly = false;
			AlignOri.ReactionTorqueEnabled = false;
			AlignOri.Responsiveness = 200;
			AlignOri.RigidityEnabled = false;
			local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "AthP_"..CountSCIFIMOVIELOL
			local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "AthP_"..CountSCIFIMOVIELOL
			local AttachmentC=Instance.new('Attachment',Part1); AttachmentC.Name = "AthO_"..CountSCIFIMOVIELOL
			local AttachmentD=Instance.new('Attachment',Part0); AttachmentD.Name = "AthO_"..CountSCIFIMOVIELOL
			AttachmentC.Orientation = Angle
			AttachmentA.Position = Position
			AlignPos.Attachment1 = AttachmentA;
			AlignPos.Attachment0 = AttachmentB;
			AlignOri.Attachment1 = AttachmentC;
			AlignOri.Attachment0 = AttachmentD;
			CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1

		end

		coroutine.wrap(function()
			local player = game.Players.LocalPlayer
			local char = player.Character or player.CharacterAdded:wait()
			if sethiddenproperty then
				while true do
					game:GetService("RunService").RenderStepped:Wait()
					settings().Physics.AllowSleep = false
					local TBL = game:GetService("Players"):GetChildren() 
					for _ = 1,#TBL do local Players = TBL[_]
						if Players ~= game:GetService("Players").LocalPlayer then
							Players.MaximumSimulationRadius = 0
							sethiddenproperty(Players,"SimulationRadius",0) 
						end 
					end
					game:GetService("Players").LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)
					sethiddenproperty(game:GetService("Players").LocalPlayer,"SimulationRadius",math.pow(math.huge,math.huge)*math.huge)
					if HumanDied then break end
				end
			else
				while true do
					game:GetService("RunService").RenderStepped:Wait()
					settings().Physics.AllowSleep = false
					local TBL = game:GetService("Players"):GetChildren() 
					for _ = 1,#TBL do local Players = TBL[_]
						if Players ~= game:GetService("Players").LocalPlayer then
							Players.MaximumSimulationRadius = 0
						end 
					end
					game:GetService("Players").LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)
					if HumanDied then break end
				end
			end
		end)()

		if game:GetService("Players").LocalPlayer.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 then
			if Bypass == "limbs" then --------------------------------------------------------------------------------------------------------------------
				game:GetService("Players").LocalPlayer["Character"].Archivable = true 
				local CloneChar = game:GetService("Players").LocalPlayer["Character"]:Clone()
				CloneChar.Parent = workspace 
				CloneChar.HumanoidRootPart.CFrame = game:GetService("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame * CFrame.new(0,2,0)
				wait() 
				CloneChar.Humanoid.BreakJointsOnDeath = false
				workspace.Camera.CameraSubject = CloneChar.Humanoid
				CloneChar.Name = "non" 
				CloneChar.Humanoid.DisplayDistanceType = "None"
				if CloneChar.Head:FindFirstChild("face") then CloneChar.Head:FindFirstChild("face"):Destroy() end
				if workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face") then workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face").Parent = CloneChar.Head end

				local DeadChar = workspace[game:GetService("Players").LocalPlayer.Name]
				DeadChar.HumanoidRootPart:Destroy()

				local LVecPart = Instance.new("Part", workspace) LVecPart.CanCollide = false LVecPart.Transparency = 1
				local CONVEC
				local function VECTORUNIT()
					if HumanDied then CONVEC:Disconnect(); return end
					local lookVec = workspace.Camera.CFrame.lookVector
					local Root = CloneChar["HumanoidRootPart"]
					LVecPart.Position = Root.Position
					LVecPart.CFrame = CFrame.new(LVecPart.Position, Vector3.new(lookVec.X * 9999, lookVec.Y, lookVec.Z * 9999))
				end
				CONVEC = game:GetService("RunService").Heartbeat:Connect(VECTORUNIT)

				local CONDOWN
				local WDown, ADown, SDown, DDown, SpaceDown = false, false, false, false, false
				local function KEYDOWN(_,Processed) 
					if HumanDied then CONDOWN:Disconnect(); return end
					if Processed ~= true then
						local Key = _.KeyCode
						if Key == Enum.KeyCode.W then
							WDown = true end
						if Key == Enum.KeyCode.A then
							ADown = true end
						if Key == Enum.KeyCode.S then
							SDown = true end
						if Key == Enum.KeyCode.D then
							DDown = true end
						if Key == Enum.KeyCode.Space then
							SpaceDown = true end end end
				CONDOWN = game:GetService("UserInputService").InputBegan:Connect(KEYDOWN)

				local CONUP
				local function KEYUP(_)
					if HumanDied then CONUP:Disconnect(); return end
					local Key = _.KeyCode
					if Key == Enum.KeyCode.W then
						WDown = false end
					if Key == Enum.KeyCode.A then
						ADown = false end
					if Key == Enum.KeyCode.S then
						SDown = false end
					if Key == Enum.KeyCode.D then
						DDown = false end
					if Key == Enum.KeyCode.Space then
						SpaceDown = false end end
				CONUP = game:GetService("UserInputService").InputEnded:Connect(KEYUP)

				local function MoveClone(X,Y,Z)
					LVecPart.CFrame = LVecPart.CFrame * CFrame.new(-X,Y,-Z)
					workspace["non"].Humanoid.WalkToPoint = LVecPart.Position
				end

				coroutine.wrap(function() 
					while true do game:GetService("RunService").RenderStepped:Wait()
						if HumanDied then break end
						if WDown then MoveClone(0,0,1e4) end
						if ADown then MoveClone(1e4,0,0) end
						if SDown then MoveClone(0,0,-1e4) end
						if DDown then MoveClone(-1e4,0,0) end
						if SpaceDown then CloneChar["Humanoid"].Jump = true end
						if WDown ~= true and ADown ~= true and SDown ~= true and DDown ~= true then
							workspace["non"].Humanoid.WalkToPoint = workspace["non"].HumanoidRootPart.Position end
					end 
				end)()

				local con
				function UnCollide()
					if HumanDied then con:Disconnect(); return end
					for _,Parts in next, CloneChar:GetDescendants() do
						if Parts:IsA("BasePart") then
							Parts.CanCollide = false 
						end 
					end
					for _,Parts in next, DeadChar:GetDescendants() do
						if Parts:IsA("BasePart") then
							Parts.CanCollide = false
						end 
					end 
				end
				con = game:GetService("RunService").Stepped:Connect(UnCollide)

				local resetBindable = Instance.new("BindableEvent")
				resetBindable.Event:connect(function()
					game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
					resetBindable:Destroy()
					pcall(function()
						CloneChar.Humanoid.Health = 0
						DeadChar.Humanoid.Health = 0
					end)
				end)
				game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

				coroutine.wrap(function()
					while true do
						game:GetService("RunService").RenderStepped:wait()
						if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 or not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChild("Humanoid") or DeadChar:FindFirstChild("Humanoid").Health <= 0 then 
							HumanDied = true
							pcall(function()
								game.Players.LocalPlayer.Character = CloneChar
								CloneChar:Destroy()
								game.Players.LocalPlayer.Character = DeadChar
								if resetBindable then
									game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
									resetBindable:Destroy()
								end
								DeadChar.Humanoid.Health = 0
							end)
							break
						end		
					end
				end)()

				SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))

				coroutine.wrap(function()
					while true do
						game:GetService("RunService").RenderStepped:wait()
						if HumanDied then break end
						DeadChar["Torso"].CFrame = CloneChar["Torso"].CFrame
					end
				end)()

				for _,v in next, DeadChar:GetChildren() do
					if v:IsA("Accessory") then
						SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
					end
				end

				for _,BodyParts in next, CloneChar:GetDescendants() do
					if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
						BodyParts.Transparency = 1 end end

				DeadChar.Torso["Left Shoulder"]:Destroy()
				DeadChar.Torso["Right Shoulder"]:Destroy()
				DeadChar.Torso["Left Hip"]:Destroy()
				DeadChar.Torso["Right Hip"]:Destroy()

			elseif Bypass == "death" then --------------------------------------------------------------------------------------------------------------------
				game:GetService("Players").LocalPlayer["Character"].Archivable = true 
				local CloneChar = game:GetService("Players").LocalPlayer["Character"]:Clone()
				game:GetService("Players").LocalPlayer["Character"].Humanoid.WalkSpeed = 0 
				game:GetService("Players").LocalPlayer["Character"].Humanoid.JumpPower = 0 
				game:GetService("Players").LocalPlayer["Character"].Humanoid.AutoRotate = false
				local FalseChar = Instance.new("Model", workspace); FalseChar.Name = ""
				Instance.new("Part",FalseChar).Name = "Head" 
				Instance.new("Part",FalseChar).Name = "Torso" 
				Instance.new("Humanoid",FalseChar).Name = "Humanoid"
				game:GetService("Players").LocalPlayer["Character"] = FalseChar
				game:GetService("Players").LocalPlayer["Character"].Humanoid.Name = "FalseHumanoid"
				local Clone = game:GetService("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Clone()
				Clone.Parent = game:GetService("Players").LocalPlayer["Character"]
				Clone.Name = "Humanoid"
				game:GetService("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Destroy() 
				game:GetService("Players").LocalPlayer["Character"].Humanoid.Health = 0 
				game:GetService("Players").LocalPlayer["Character"] = workspace[game:GetService("Players").LocalPlayer.Name] 
				wait(5.65) 
				game:GetService("Players").LocalPlayer["Character"].Humanoid.Health = 0
				CloneChar.Parent = workspace 
				CloneChar.HumanoidRootPart.CFrame = game:GetService("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame * CFrame.new(0,2,0)
				wait() 
				CloneChar.Humanoid.BreakJointsOnDeath = false
				workspace.Camera.CameraSubject = CloneChar.Humanoid 
				CloneChar.Name = "non" 
				CloneChar.Humanoid.DisplayDistanceType = "None"
				if CloneChar.Head:FindFirstChild("face") then CloneChar.Head:FindFirstChild("face"):Destroy() end
				if workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face") then workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face").Parent = CloneChar.Head end

				FalseChar:Destroy()

				local DeadChar = workspace[game:GetService("Players").LocalPlayer.Name]

				local LVecPart = Instance.new("Part", workspace) LVecPart.CanCollide = false LVecPart.Transparency = 1
				local CONVEC
				local function VECTORUNIT()
					if HumanDied then CONVEC:Disconnect(); return end
					local lookVec = workspace.Camera.CFrame.lookVector
					local Root = CloneChar["HumanoidRootPart"]
					LVecPart.Position = Root.Position
					LVecPart.CFrame = CFrame.new(LVecPart.Position, Vector3.new(lookVec.X * 9999, lookVec.Y, lookVec.Z * 9999))
				end
				CONVEC = game:GetService("RunService").Heartbeat:Connect(VECTORUNIT)

				local CONDOWN
				local WDown, ADown, SDown, DDown, SpaceDown = false, false, false, false, false
				local function KEYDOWN(_,Processed) 
					if HumanDied then CONDOWN:Disconnect(); return end
					if Processed ~= true then
						local Key = _.KeyCode
						if Key == Enum.KeyCode.W then
							WDown = true end
						if Key == Enum.KeyCode.A then
							ADown = true end
						if Key == Enum.KeyCode.S then
							SDown = true end
						if Key == Enum.KeyCode.D then
							DDown = true end
						if Key == Enum.KeyCode.Space then
							SpaceDown = true end end end
				CONDOWN = game:GetService("UserInputService").InputBegan:Connect(KEYDOWN)

				local CONUP
				local function KEYUP(_)
					if HumanDied then CONUP:Disconnect(); return end
					local Key = _.KeyCode
					if Key == Enum.KeyCode.W then
						WDown = false end
					if Key == Enum.KeyCode.A then
						ADown = false end
					if Key == Enum.KeyCode.S then
						SDown = false end
					if Key == Enum.KeyCode.D then
						DDown = false end
					if Key == Enum.KeyCode.Space then
						SpaceDown = false end end
				CONUP = game:GetService("UserInputService").InputEnded:Connect(KEYUP)

				local function MoveClone(X,Y,Z)
					LVecPart.CFrame = LVecPart.CFrame * CFrame.new(-X,Y,-Z)
					workspace["non"].Humanoid.WalkToPoint = LVecPart.Position
				end

				coroutine.wrap(function() 
					while true do game:GetService("RunService").RenderStepped:Wait()
						if HumanDied then break end
						if WDown then MoveClone(0,0,1e4) end
						if ADown then MoveClone(1e4,0,0) end
						if SDown then MoveClone(0,0,-1e4) end
						if DDown then MoveClone(-1e4,0,0) end
						if SpaceDown then CloneChar["Humanoid"].Jump = true end
						if WDown ~= true and ADown ~= true and SDown ~= true and DDown ~= true then
							workspace["non"].Humanoid.WalkToPoint = workspace["non"].HumanoidRootPart.Position end
					end 
				end)()

				local con
				function UnCollide()
					if HumanDied then con:Disconnect(); return end
					for _,Parts in next, CloneChar:GetDescendants() do
						if Parts:IsA("BasePart") then
							Parts.CanCollide = false 
						end 
					end
					for _,Parts in next, DeadChar:GetDescendants() do
						if Parts:IsA("BasePart") then
							Parts.CanCollide = false
						end 
					end 
				end
				con = game:GetService("RunService").Stepped:Connect(UnCollide)

				local resetBindable = Instance.new("BindableEvent")
				resetBindable.Event:connect(function()
					game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
					resetBindable:Destroy()
					CloneChar.Humanoid.Health = 0
				end)
				game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

				coroutine.wrap(function()
					while true do
						game:GetService("RunService").RenderStepped:wait()
						if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 then 
							HumanDied = true
							pcall(function()
								game.Players.LocalPlayer.Character = CloneChar
								CloneChar:Destroy()
								game.Players.LocalPlayer.Character = DeadChar
								if resetBindable then
									game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
									resetBindable:Destroy()
								end
								DeadChar.Humanoid.Health = 0
							end)
							break
						end		
					end
				end)()

				SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["HumanoidRootPart"],CloneChar["HumanoidRootPart"],Vector3.new(0,0,0),Vector3.new(0,0,0))

				for _,v in next, DeadChar:GetChildren() do
					if v:IsA("Accessory") then
						if v.Name == "PlainTail" then
							Tail = CloneChar[v.Name].Handle
						end
						SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
					end
				end

				for _,BodyParts in next, CloneChar:GetDescendants() do
					if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
						BodyParts.Transparency = 1 end end
			elseif Bypass == "hats" then
				game:GetService("Players").LocalPlayer["Character"].Archivable = true 
				local DeadChar = game.Players.LocalPlayer.Character
				DeadChar.Name = "non"
				local HatPosition = Vector3.new(0,0,0)
				local HatName = "MediHood"
				local HatsLimb = {
					Rarm = DeadChar:FindFirstChild("Hat1"),
					Larm = DeadChar:FindFirstChild("Pink Hair"),
					Rleg = DeadChar:FindFirstChild("Robloxclassicred"),
					Lleg = DeadChar:FindFirstChild("Kate Hair"),
					Torso1 = DeadChar:FindFirstChild("Pal Hair"),
					Torso2 = DeadChar:FindFirstChild("LavanderHair")
				}
				HatName = DeadChar:FindFirstChild(HatName)

				coroutine.wrap(function()
					while true do
						game:GetService("RunService").RenderStepped:wait()
						if not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChild("Humanoid") or DeadChar:FindFirstChild("Humanoid").Health <= 0 then 
							HumanDied = true
							pcall(function()
								if resetBindable then
									game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
									resetBindable:Destroy()
								end
								DeadChar.Humanoid.Health = 0
							end)
							break
						end		
					end
				end)()

				local con
				function UnCollide()
					if HumanDied then con:Disconnect(); return end
					for _,Parts in next, DeadChar:GetDescendants() do
						if Parts:IsA("BasePart") then
							Parts.CanCollide = false
						end 
					end 
				end
				con = game:GetService("RunService").Stepped:Connect(UnCollide)

				SCIFIMOVIELOL(HatName.Handle,DeadChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(HatsLimb.Torso1.Handle,DeadChar["Torso"],Vector3.new(0.5,0,0),Vector3.new(90,0,0))
				SCIFIMOVIELOL(HatsLimb.Torso2.Handle,DeadChar["Torso"],Vector3.new(-0.5,0,0),Vector3.new(90,0,0))
				SCIFIMOVIELOL(HatsLimb.Larm.Handle,DeadChar["Left Arm"],Vector3.new(0,0,0),Vector3.new(90,0,0))
				SCIFIMOVIELOL(HatsLimb.Rarm.Handle,DeadChar["Right Arm"],Vector3.new(0,0,0),Vector3.new(90,0,0))
				SCIFIMOVIELOL(HatsLimb.Lleg.Handle,DeadChar["Left Leg"],Vector3.new(0,0,0),Vector3.new(90,0,0))
				SCIFIMOVIELOL(HatsLimb.Rleg.Handle,DeadChar["Right Leg"],Vector3.new(0,0,0),Vector3.new(90,0,0))

				for i,v in pairs(HatsLimb) do
					v.Handle:FindFirstChild("AccessoryWeld"):Destroy()
					if v.Handle:FindFirstChild("Mesh") then v.Handle:FindFirstChild("Mesh"):Destroy() end
					if v.Handle:FindFirstChild("SpecialMesh") then v.Handle:FindFirstChild("SpecialMesh"):Destroy() end
				end
				HatName.Handle:FindFirstChild("AccessoryWeld"):Destroy()
			end
		else
			if Bypass == "limbs" then --------------------------------------------------------------------------------------------------------------------
				game:GetService("Players").LocalPlayer["Character"].Archivable = true 
				local CloneChar = game:GetObjects("rbxassetid://5227463276")[1]
				CloneChar.Parent = workspace 
				CloneChar.HumanoidRootPart.CFrame = game:GetService("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame * CFrame.new(0,0.5,0.1)
				CloneChar.Humanoid.BreakJointsOnDeath = false
				workspace.Camera.CameraSubject = CloneChar.Humanoid 
				CloneChar.Name = "non" 
				CloneChar.Humanoid.DisplayDistanceType = "None"
				if CloneChar.Head:FindFirstChild("face") then CloneChar.Head:FindFirstChild("face"):Destroy() end
				if workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face") then workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face").Parent = CloneChar.Head end

				local DeadChar = workspace[game:GetService("Players").LocalPlayer.Name]
				DeadChar.HumanoidRootPart:Destroy()

				local LVecPart = Instance.new("Part", workspace) LVecPart.CanCollide = false LVecPart.Transparency = 1
				local CONVEC
				local function VECTORUNIT()
					if HumanDied then CONVEC:Disconnect(); return end
					local lookVec = workspace.Camera.CFrame.lookVector
					local Root = CloneChar["HumanoidRootPart"]
					LVecPart.Position = Root.Position
					LVecPart.CFrame = CFrame.new(LVecPart.Position, Vector3.new(lookVec.X * 9999, lookVec.Y, lookVec.Z * 9999))
				end
				CONVEC = game:GetService("RunService").Heartbeat:Connect(VECTORUNIT)

				local CONDOWN
				local WDown, ADown, SDown, DDown, SpaceDown = false, false, false, false, false
				local function KEYDOWN(_,Processed) 
					if HumanDied then CONDOWN:Disconnect(); return end
					if Processed ~= true then
						local Key = _.KeyCode
						if Key == Enum.KeyCode.W then
							WDown = true end
						if Key == Enum.KeyCode.A then
							ADown = true end
						if Key == Enum.KeyCode.S then
							SDown = true end
						if Key == Enum.KeyCode.D then
							DDown = true end
						if Key == Enum.KeyCode.Space then
							SpaceDown = true end end end
				CONDOWN = game:GetService("UserInputService").InputBegan:Connect(KEYDOWN)

				local CONUP
				local function KEYUP(_)
					if HumanDied then CONUP:Disconnect(); return end
					local Key = _.KeyCode
					if Key == Enum.KeyCode.W then
						WDown = false end
					if Key == Enum.KeyCode.A then
						ADown = false end
					if Key == Enum.KeyCode.S then
						SDown = false end
					if Key == Enum.KeyCode.D then
						DDown = false end
					if Key == Enum.KeyCode.Space then
						SpaceDown = false end end
				CONUP = game:GetService("UserInputService").InputEnded:Connect(KEYUP)

				local function MoveClone(X,Y,Z)
					LVecPart.CFrame = LVecPart.CFrame * CFrame.new(-X,Y,-Z)
					workspace["non"].Humanoid.WalkToPoint = LVecPart.Position
				end

				coroutine.wrap(function() 
					while true do game:GetService("RunService").RenderStepped:Wait()
						if HumanDied then break end
						if WDown then MoveClone(0,0,1e4) end
						if ADown then MoveClone(1e4,0,0) end
						if SDown then MoveClone(0,0,-1e4) end
						if DDown then MoveClone(-1e4,0,0) end
						if SpaceDown then CloneChar["Humanoid"].Jump = true end
						if WDown ~= true and ADown ~= true and SDown ~= true and DDown ~= true then
							workspace["non"].Humanoid.WalkToPoint = workspace["non"].HumanoidRootPart.Position end
					end 
				end)()

				local con
				function UnCollide()
					if HumanDied then con:Disconnect(); return end
					for _,Parts in next, CloneChar:GetDescendants() do
						if Parts:IsA("BasePart") then
							Parts.CanCollide = false 
						end 
					end
					for _,Parts in next, DeadChar:GetDescendants() do
						if Parts:IsA("BasePart") then
							Parts.CanCollide = false
						end 
					end 
				end
				con = game:GetService("RunService").Stepped:Connect(UnCollide)

				local resetBindable = Instance.new("BindableEvent")
				resetBindable.Event:connect(function()
					game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
					resetBindable:Destroy()
					CloneChar.Humanoid.Health = 0
				end)
				game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

				coroutine.wrap(function()
					while true do
						game:GetService("RunService").RenderStepped:wait()
						if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 or not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChild("Humanoid") or DeadChar:FindFirstChild("Humanoid").Health <= 0 then 
							HumanDied = true
							pcall(function()
								game.Players.LocalPlayer.Character = CloneChar
								CloneChar:Destroy()
								game.Players.LocalPlayer.Character = DeadChar
								if resetBindable then
									game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
									resetBindable:Destroy()
								end
								DeadChar.Humanoid.Health = 0
							end)
							break
						end		
					end
				end)()

				for _,v in next, DeadChar:GetChildren() do
					if v:IsA("Accessory") then
						v:Clone().Parent = CloneChar
					end
				end

				for _,v in next, DeadChar:GetDescendants() do
					if v:IsA("Motor6D") and v.Name ~= "Neck" then
						v:Destroy()
					end
				end

				SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["UpperTorso"],CloneChar["Torso"],Vector3.new(0,0.2,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LowerTorso"],CloneChar["Torso"],Vector3.new(0,-0.78,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftUpperArm"],CloneChar["Left Arm"],Vector3.new(0,0.375,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftLowerArm"],CloneChar["Left Arm"],Vector3.new(0,-0.215,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftHand"],CloneChar["Left Arm"],Vector3.new(0,-0.825,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightUpperArm"],CloneChar["Right Arm"],Vector3.new(0,0.375,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightLowerArm"],CloneChar["Right Arm"],Vector3.new(0,-0.215,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightHand"],CloneChar["Right Arm"],Vector3.new(0,-0.825,0),Vector3.new(0,0,0))

				SCIFIMOVIELOL(DeadChar["LeftUpperLeg"],CloneChar["Left Leg"],Vector3.new(0,0.575,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftLowerLeg"],CloneChar["Left Leg"],Vector3.new(0,-0.137,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftFoot"],CloneChar["Left Leg"],Vector3.new(0,-0.787,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightUpperLeg"],CloneChar["Right Leg"],Vector3.new(0,0.575,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightLowerLeg"],CloneChar["Right Leg"],Vector3.new(0,-0.137,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightFoot"],CloneChar["Right Leg"],Vector3.new(0,-0.787,0),Vector3.new(0,0,0))

				coroutine.wrap(function()
					while true do
						game:GetService("RunService").RenderStepped:wait()
						if HumanDied then break end
						DeadChar["UpperTorso"].CFrame = CloneChar["Torso"].CFrame * CFrame.new(0,0.2,0)
					end
				end)()

				for _,v in next, DeadChar:GetChildren() do
					if v:IsA("Accessory") then
						SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
					end
				end

				for _,BodyParts in next, CloneChar:GetDescendants() do
					if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
						BodyParts.Transparency = 1 end end

			elseif Bypass == "death" then --------------------------------------------------------------------------------------------------------------------
				game:GetService("Players").LocalPlayer["Character"].Archivable = true 
				local CloneChar = game:GetObjects("rbxassetid://5227463276")[1]
				game:GetService("Players").LocalPlayer["Character"].Humanoid.WalkSpeed = 0 
				game:GetService("Players").LocalPlayer["Character"].Humanoid.JumpPower = 0 
				game:GetService("Players").LocalPlayer["Character"].Humanoid.AutoRotate = false
				local FalseChar = Instance.new("Model", workspace); FalseChar.Name = ""
				Instance.new("Part",FalseChar).Name = "Head" 
				Instance.new("Part",FalseChar).Name = "UpperTorso"
				Instance.new("Humanoid",FalseChar).Name = "Humanoid"
				game:GetService("Players").LocalPlayer["Character"] = FalseChar
				game:GetService("Players").LocalPlayer["Character"].Humanoid.Name = "FalseHumanoid"
				local Clone = game:GetService("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Clone()
				Clone.Parent = game:GetService("Players").LocalPlayer["Character"]
				Clone.Name = "Humanoid"
				game:GetService("Players").LocalPlayer["Character"]:FindFirstChild("FalseHumanoid"):Destroy() 
				game:GetService("Players").LocalPlayer["Character"].Humanoid.Health = 0 
				game:GetService("Players").LocalPlayer["Character"] = workspace[game:GetService("Players").LocalPlayer.Name] 
				wait(5.65) 
				game:GetService("Players").LocalPlayer["Character"].Humanoid.Health = 0
				CloneChar.Parent = workspace 
				CloneChar.HumanoidRootPart.CFrame = game:GetService("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame * CFrame.new(0,0.5,0.1)
				wait() 
				CloneChar.Humanoid.BreakJointsOnDeath = false
				workspace.Camera.CameraSubject = CloneChar.Humanoid 
				CloneChar.Name = "non" 
				CloneChar.Humanoid.DisplayDistanceType = "None"
				if CloneChar.Head:FindFirstChild("face") then CloneChar.Head:FindFirstChild("face"):Destroy() end
				if workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face") then workspace[game:GetService("Players").LocalPlayer.Name].Head:FindFirstChild("face").Parent = CloneChar.Head end

				FalseChar:Destroy()

				local DeadChar = workspace[game:GetService("Players").LocalPlayer.Name]

				local LVecPart = Instance.new("Part", workspace) LVecPart.CanCollide = false LVecPart.Transparency = 1
				local CONVEC
				local function VECTORUNIT()
					if HumanDied then CONVEC:Disconnect(); return end
					local lookVec = workspace.Camera.CFrame.lookVector
					local Root = CloneChar["HumanoidRootPart"]
					LVecPart.Position = Root.Position
					LVecPart.CFrame = CFrame.new(LVecPart.Position, Vector3.new(lookVec.X * 9999, lookVec.Y, lookVec.Z * 9999))
				end
				CONVEC = game:GetService("RunService").Heartbeat:Connect(VECTORUNIT)

				local CONDOWN
				local WDown, ADown, SDown, DDown, SpaceDown = false, false, false, false, false
				local function KEYDOWN(_,Processed) 
					if HumanDied then CONDOWN:Disconnect(); return end
					if Processed ~= true then
						local Key = _.KeyCode
						if Key == Enum.KeyCode.W then
							WDown = true end
						if Key == Enum.KeyCode.A then
							ADown = true end
						if Key == Enum.KeyCode.S then
							SDown = true end
						if Key == Enum.KeyCode.D then
							DDown = true end
						if Key == Enum.KeyCode.Space then
							SpaceDown = true end end end
				CONDOWN = game:GetService("UserInputService").InputBegan:Connect(KEYDOWN)

				local CONUP
				local function KEYUP(_)
					if HumanDied then CONUP:Disconnect(); return end
					local Key = _.KeyCode
					if Key == Enum.KeyCode.W then
						WDown = false end
					if Key == Enum.KeyCode.A then
						ADown = false end
					if Key == Enum.KeyCode.S then
						SDown = false end
					if Key == Enum.KeyCode.D then
						DDown = false end
					if Key == Enum.KeyCode.Space then
						SpaceDown = false end end
				CONUP = game:GetService("UserInputService").InputEnded:Connect(KEYUP)

				local function MoveClone(X,Y,Z)
					LVecPart.CFrame = LVecPart.CFrame * CFrame.new(-X,Y,-Z)
					workspace["non"].Humanoid.WalkToPoint = LVecPart.Position
				end

				coroutine.wrap(function() 
					while true do game:GetService("RunService").RenderStepped:Wait()
						if HumanDied then break end
						if WDown then MoveClone(0,0,1e4) end
						if ADown then MoveClone(1e4,0,0) end
						if SDown then MoveClone(0,0,-1e4) end
						if DDown then MoveClone(-1e4,0,0) end
						if SpaceDown then CloneChar["Humanoid"].Jump = true end
						if WDown ~= true and ADown ~= true and SDown ~= true and DDown ~= true then
							workspace["non"].Humanoid.WalkToPoint = workspace["non"].HumanoidRootPart.Position end
					end 
				end)()

				local con
				function UnCollide()
					if HumanDied then con:Disconnect(); return end
					for _,Parts in next, CloneChar:GetDescendants() do
						if Parts:IsA("BasePart") then
							Parts.CanCollide = false 
						end 
					end
					for _,Parts in next, DeadChar:GetDescendants() do
						if Parts:IsA("BasePart") then
							Parts.CanCollide = false
						end 
					end 
				end
				con = game:GetService("RunService").Stepped:Connect(UnCollide)

				local resetBindable = Instance.new("BindableEvent")
				resetBindable.Event:connect(function()
					game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
					resetBindable:Destroy()
					CloneChar.Humanoid.Health = 0
				end)
				game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

				coroutine.wrap(function()
					while true do
						game:GetService("RunService").RenderStepped:wait()
						if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 then 
							HumanDied = true
							pcall(function()
								game.Players.LocalPlayer.Character = CloneChar
								CloneChar:Destroy()
								game.Players.LocalPlayer.Character = DeadChar
								if resetBindable then
									game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
									resetBindable:Destroy()
								end
								DeadChar.Humanoid.Health = 0
							end)
							break
						end		
					end
				end)()

				for _,v in next, DeadChar:GetChildren() do
					if v:IsA("Accessory") then
						v:Clone().Parent = CloneChar
					end
				end

				SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["UpperTorso"],CloneChar["Torso"],Vector3.new(0,0.2,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LowerTorso"],CloneChar["Torso"],Vector3.new(0,-0.78,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftUpperArm"],CloneChar["Left Arm"],Vector3.new(0,0.375,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftLowerArm"],CloneChar["Left Arm"],Vector3.new(0,-0.215,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftHand"],CloneChar["Left Arm"],Vector3.new(0,-0.825,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightUpperArm"],CloneChar["Right Arm"],Vector3.new(0,0.375,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightLowerArm"],CloneChar["Right Arm"],Vector3.new(0,-0.215,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightHand"],CloneChar["Right Arm"],Vector3.new(0,-0.825,0),Vector3.new(0,0,0))

				SCIFIMOVIELOL(DeadChar["LeftUpperLeg"],CloneChar["Left Leg"],Vector3.new(0,0.575,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftLowerLeg"],CloneChar["Left Leg"],Vector3.new(0,-0.137,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["LeftFoot"],CloneChar["Left Leg"],Vector3.new(0,-0.787,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightUpperLeg"],CloneChar["Right Leg"],Vector3.new(0,0.575,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightLowerLeg"],CloneChar["Right Leg"],Vector3.new(0,-0.137,0),Vector3.new(0,0,0))
				SCIFIMOVIELOL(DeadChar["RightFoot"],CloneChar["Right Leg"],Vector3.new(0,-0.787,0),Vector3.new(0,0,0))

				SCIFIMOVIELOL(DeadChar["HumanoidRootPart"],CloneChar["HumanoidRootPart"],Vector3.new(0,0,0),Vector3.new(0,0,0))

				for _,v in next, DeadChar:GetChildren() do
					if v:IsA("Accessory") then
						SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
					end
				end

				for _,BodyParts in next, CloneChar:GetDescendants() do
					if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
						BodyParts.Transparency = 1 end end
				if DeadChar.Head:FindFirstChild("Neck") then
					game.Players.LocalPlayer.Character:BreakJoints()
				end
			end
		end
		local CloneChar = workspace.non







		ArtificialHB = Instance.new('BindableEvent', script)
		ArtificialHB.Name = 'Heartbeat'
		script:WaitForChild('Heartbeat')
		frame = 1 / 60
		tf = 0
		allowframeloss = false
		tossremainder = false
		lastframe = tick()
		script.Heartbeat:Fire()

		game:GetService('RunService').Heartbeat:connect(function(s, p)
			tf = tf + s
			if tf >= frame then
				if allowframeloss then
					script.Heartbeat:Fire()
					lastframe = tick()
				else
					for i = 1, math.floor(tf / frame) do
						script.Heartbeat:Fire()
					end
					lastframe = tick()
				end
				if tossremainder then
					tf = 0
				else
					tf = tf - frame * math.floor(tf / frame)
				end
			end
		end)
		local makesound = function(soundid,speed,volume,parent)
			local sound = Instance.new("Sound")
			sound.SoundId = soundid
			sound.RollOffMaxDistance = 100
			sound.PlaybackSpeed =speed 
			sound.Volume = volume
			sound.Parent = parent
			return sound
		end
		local Callerp = function(Start,End,Percent)
			return (Start - (End - Start) * Percen)
		end
		function swait(t)
			game:GetService('RunService').Stepped:wait()
		end

		local TweenService = game:GetService("TweenService")
		local CF = CFrame.new
		local CFA = CFrame.Angles
		local head = CloneChar:WaitForChild("Head")
		local tors = CloneChar:WaitForChild("Torso")
		local huma = CloneChar:WaitForChild("Humanoid")
		huma.DisplayName = " "
		local neck = Instance.new("Weld",tors)
		neck.Part0 = tors
		neck.Part1 = head
		neck.C0 = CF(0,1.5,0)
		local nek = neck.C1
		neck.Enabled = true
		local root = CloneChar.HumanoidRootPart.RootJoint.C0
		local rs = tors["Right Shoulder"].C0
		local ls = tors["Left Shoulder"].C0
		local rh = tors["Right Hip"].C0
		local lh = tors["Left Hip"].C0
		local RootPart = CloneChar:WaitForChild("HumanoidRootPart")
		local Humanoid = CloneChar.Humanoid
		local ActiveTracks = Humanoid:GetPlayingAnimationTracks()
		Humanoid.JumpPower = 80
		local Attacking = false
		local AttackANVal = 1
		local bambam = Instance.new("BodyThrust")
		bambam.Parent = game.Players.LocalPlayer.Character.HumanoidRootPart
		bambam.Force = Vector3.new(1000,0,1000)
		bambam.Location = game.Players.LocalPlayer.Character.HumanoidRootPart.Position
		rayCast = function(Pos, Dir, Max, Ignore)

			return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), (CloneChar and game.Players.LocalPlayer.Character))
		end
		Spawn(function()
			for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
				if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then 
					s = game:GetService("RunService").Heartbeat:connect(function()
						v.Velocity = Vector3.new(0,35,0)
						wait(0.3)
					end)
				end
			end
		end)
		spawn(function()
			repeat
				wait()
			until Humanoid.Health < 0.1
			s:Disconnect()
		end)
		if Tail ~= nil then
			TailWeld = Tail.AccessoryWeld

		else
			TailWeld = Instance.new("Weld",workspace)
			Msgreq("FE Neko Anims V1.6","Loading Without Tail Accessory (Check top of script for the accessory)",5,nil)
		end
		local TC0 = TailWeld.C0 * CFrame.new(0,0,0.4)
		local Song = Instance.new("Sound",RootPart)
		Song.SoundId = SongID
		Song.Looped = true
		Song:Play()
		local Running = false

		local MakeTween = function(timetack,easingstyle,easingdirection,repeats,flipflop)
			local newtween = TweenInfo.new(
				timetack, 
				easingstyle, 
				easingdirection, 
				repeats, 
				flipflop, 
				0 
			)
			return newtween
		end
		local DOTWEEN = function(Part,tim,value)
			local Tween = MakeTween(tim,Enum.EasingStyle.Circular,Enum.EasingDirection.InOut,0,false)
			TweenService:Create(Part,Tween,{C0= value}):Play()
		end
		local LerpStyle = function(lerpmagnet,easingstyle,easingdirection)
			local newstyle = TweenService:GetValue(lerpmagnet,easingstyle,easingdirection)
			return newstyle
		end

		local SpinKick  = function()
			if Attacking == false then
				Attacking = true 
				for i = 0,60,1 do
					swait()
					neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(30),math.rad(0),math.rad(0)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0.0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-20)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(20)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-20 + -10)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-30 - -6)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				end 
				bambam.Location = game.Players.LocalPlayer.Character.Torso.Position
				game.Players.LocalPlayer.Character.HumanoidRootPart.Position = game.Players.LocalPlayer.Character.Torso.Position
				RootPart.Anchored = true
				for i = 0,60,1 do
					swait()
					RootPart.Position = RootPart.Position + Vector3.new(0,0.6,0)
					bambam.Location = game.Players.LocalPlayer.Character["Right Leg"].Position
					game.Players.LocalPlayer.Character.HumanoidRootPart.Position = game.Players.LocalPlayer.Character.Torso.Position
					neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(-20 + -36*i),math.rad(0),math.rad(0)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0.0,0,0) * CFA(math.rad(0),math.rad(30),math.rad(40)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(0),math.rad(-30),math.rad(-40)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(50)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(30)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
				end 
				RootPart.Anchored = false
				Attacking = false
			end
		end


		local ComboCont = 1
		local Attack = function()
			if Attacking == false then
				Attacking = true
				if ComboCont == 1 then
					for i = 0,10,1 do
						swait()
						bambam.Location = game.Players.LocalPlayer.Character["Right Arm"].Position
						game.Players.LocalPlayer.Character.HumanoidRootPart.Position = game.Players.LocalPlayer.Character["Right Arm"].Position
						neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(-30),math.rad(0),math.rad(80)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0.5,0,-1.2) * CFA(math.rad(0),math.rad(90),math.rad(90)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(20)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(10)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(30)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					end 

					for i = 0,15,1 do
						swait()
						bambam.Location = game.Players.LocalPlayer.Character["Right Arm"].Position
						game.Players.LocalPlayer.Character.HumanoidRootPart.Position = game.Players.LocalPlayer.Character["Right Arm"].Position
						neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,-3,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0.5,0,0) * CFA(math.rad(0),math.rad(-85),math.rad(90)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(20)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(40)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(30)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					end
					ComboCont = 2


				elseif ComboCont == 2 then
					for i = 0,10,1 do
						swait()
						bambam.Location = game.Players.LocalPlayer.Character["Left Arm"].Position
						game.Players.LocalPlayer.Character.HumanoidRootPart.Position = game.Players.LocalPlayer.Character["Left Arm"].Position
						neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(90),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(-30),math.rad(0),math.rad(90)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-12)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-90)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(10)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(30)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					end 

					for i = 0,10,1 do
						swait()
						bambam.Location = game.Players.LocalPlayer.Character["Left Arm"].Position
						game.Players.LocalPlayer.Character.HumanoidRootPart.Position = game.Players.LocalPlayer.Character["Left Arm"].Position
						neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(-90),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,-3,0) * CFA(math.rad(0),math.rad(0),math.rad(-90)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-12)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0.5) * CFA(math.rad(0),math.rad(90),math.rad(-90)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(10)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(30)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					end 
					ComboCont = 3
				elseif ComboCont == 3 then
					for i = 0,10,1 do
						swait()
						bambam.Location = game.Players.LocalPlayer.Character["Right Leg"].Position
						game.Players.LocalPlayer.Character.HumanoidRootPart.Position = game.Players.LocalPlayer.Character["Left Arm"].Position
						neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(10),math.rad(0),math.rad(-50)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-5)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(8)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(-50),math.rad(-98)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(20),math.rad(0)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					end 

					for i = 0,15,1 do
						swait()
						bambam.Location = game.Players.LocalPlayer.Character["Right Leg"].Position
						game.Players.LocalPlayer.Character.HumanoidRootPart.Position = game.Players.LocalPlayer.Character["Left Arm"].Position
						neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(90),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,-3,0) * CFA(math.rad(-40),math.rad(0),math.rad(90)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-5)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(8)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(90),math.rad(-90+40)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
						tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(-90),math.rad(0)),LerpStyle(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
					end 
					ComboCont = 1
				end
				Attacking = false
			end
		end
		local Mouse = game.Players.LocalPlayer:GetMouse()
		local B1Hold = false
		Mouse.Button1Down:Connect(function()
			B1Hold = true 
			while B1Hold == true do
				wait()
				Attack()
			end
		end)
		local Running = false
		Mouse.Button1Up:Connect(function()
			B1Hold = false
		end)
		Mouse.KeyDown:Connect(function(key)
			if key == "z" then
				SpinKick()
			else
				if key == "t" and Attacking == false then
					Attacking = true
					makesound("rbxassetid://6433451653",1,1,tors):Play()
					for i=0,100 do
						swait()
						neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad( -15 + math.rad(math.sin(time()*16)*15)),0,0),LerpStyle(0.2,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut))
						RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(-10 +  math.sin(time()*16)*10),math.rad(0),math.rad(0)),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
						tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,0.4 + math.sin(time()*17)*0.4,0) * CFA(0,math.rad(90),math.rad(123)),LerpStyle(0.07*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
						tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(10),0,math.rad(-90)),LerpStyle(0.07*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
						tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(-30 + math.sin(time()*17)*20),math.rad(-10 +  math.sin(time()*16)*10)),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
						tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(10 +  math.sin(time()*16)*-10)),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
						TailWeld.C0 = TailWeld.C0:Lerp(TC0 * CFrame.Angles(math.rad(-20 + math.sin(-time()*3.83)*-20),math.rad(-math.sin(time()*3.83/2)*24),0),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					end
					Attacking = false
				else
					if key == "r" and Attacking == false then
						Attacking = true
						while game.Players.LocalPlayer.Character.Humanoid.MoveDirection.Magnitude < 0.1 do
							swait()
							game.Players.LocalPlayer.Character.HumanoidRootPart.Position = tors.Position
							neck.C1 = neck.C1:Lerp(nek * CF(0,-0.4,0) * CFA(math.rad(-90),math.rad(-math.cos(time()*3)*30),0),LerpStyle(0.3,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut))
							RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,-2.5) * CFA(math.rad(78),math.rad(math.sin(time()*3)*12),math.rad(math.rad(math.sin(time()*3)*40))),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
							tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0.3,0.4 +0.4+math.sin(time()*3)*0.2,-0.4 -0.2+math.sin(time()*3)*0.2) * CFA(math.rad(-45)+math.rad(math.sin(time()*3)*12),math.rad(0),math.rad(180 - 10+math.cos(time()*3)*5)),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
							tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(-0.3,0.4+0.4-math.sin(time()*3)*0.2,-0.4 -0.2+math.sin(time()*3)*0.2) * CFA(math.rad(-45)-math.rad(math.sin(time()*3)*12),math.rad(0),math.rad(-180 + 10 +math.cos(time()*3)*5)),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
							tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(-math.sin(time()*3)*12),math.rad(math.sin(time()*3)*30),math.rad(-12 - 50 + math.cos(time()*3)*30)),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
							tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(-math.sin(time()*3)*12),math.rad(math.sin(time()*3)*30),math.rad(12 + 50 + math.cos(time()*3)*30)),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
							TailWeld.C0 = TailWeld.C0:Lerp(TC0 * CFrame.Angles(math.rad(0),0,math.rad(math.cos(time()*3)*40)),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))

						end
						Attacking = false
					else if key == "f" then
							if Running == false then
								Running = true 
								Humanoid.WalkSpeed = 40
							else
								Running = false
								Humanoid.WalkSpeed = 20
							end
						elseif key == "x" and Attacking == false and Mouse.Target.Parent:FindFirstChildWhichIsA("Humanoid") ~= nil then
							Attacking = true
							Camera = workspace.CurrentCamera
							Camera.CameraType = "Scriptable"
							local Target = Mouse.Target.Parent
							for i = 0,200,1 do
								swait()
								Camera.CFrame = Camera.CFrame:Lerp(CFrame.new((head.CFrame * CFrame.new(0,0,-5)).Position,head.CFrame.Position),1)
								neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(20),math.rad(0),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
								RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(20),math.rad(0),math.rad(0)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
								tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,-0.5,0) * CFA(math.rad(-25),math.rad(0),math.rad(00)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
								tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,-0.5,0) * CFA(math.rad(-25),math.rad(0),math.rad(00)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
								tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(20+ -40)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
								tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-20+ -4)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							end

							for i = 0,20,1 do
								swait()
								Camera.CFrame = Camera.CFrame:Lerp(CFrame.new((head.CFrame * CFrame.new(0,0,-3)).Position,head.CFrame.Position),1)
								neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
								RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(20),math.rad(0),math.rad(0)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
								tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,-0.5,0) * CFA(math.rad(-40),math.rad(0),math.rad(00)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
								tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,-0.5,0) * CFA(math.rad(-40),math.rad(0),math.rad(00)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
								tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(20+ -40)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
								tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-20+ -4)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							end
							RootPart.CFrame = Target.HumanoidRootPart.CFrame * CFrame.new(0,0,-8)
							for i = 0,100,1 do
								swait()
								game.Players.LocalPlayer.Character.HumanoidRootPart.Position = Target.HumanoidRootPart.Position
								Camera.CFrame = Camera.CFrame:Lerp(CFrame.new((head.CFrame * CFrame.new(-3,0,0)).Position,Target.HumanoidRootPart.CFrame.Position),0.2)
								neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.8,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
								RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,0) * CFA(math.rad(20),math.rad(0),math.rad(0)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
								tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,-0.5,0) * CFA(math.rad(-80),math.rad(0),math.rad(-20)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
								tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,-0.5,0) * CFA(math.rad(-80),math.rad(0),math.rad(20)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
								tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(20+ -40)),LerpStyle(0.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
								tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,0,0) * CFA(math.rad(0),math.rad(0),math.rad(-20+ -4)),LerpStyle(0.1,Enum.EasingStyle.Back,Enum.EasingDirection.Out))
							end
							Attacking = false
							Camera.CameraType = "Custom"
						end
					end
				end
			end
		end)
		local RLA = CFrame.new(0,0,0)

		local Anim = "Idle"



		Humanoid.WalkSpeed = 20
		Msgreq("FE Neko Anims V1.6","FE Neko Animations Loaded, have fun - Made by Creo",5,nil)
		while true do
			swait()
			hitfloor = rayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 0.5, 0)).lookVector, 4, CloneChar)
			local torvel = (game.Players.LocalPlayer.Character.Humanoid.MoveDirection * Vector3.new(1, 0, 1)).magnitude
			local velderp = RootPart.Velocity.y
			if RootPart.Velocity.y > 0 and hitfloor == nil then
				Anim = "Jumping"

			elseif RootPart.Velocity.y < 0 and hitfloor == nil then
				Anim = "Falling"
			elseif torvel < .5 and hitfloor ~= nil  then
				Anim = "Idle"
			elseif torvel > .5 and  hitfloor ~= nil  then
				Anim = "Walking"
			end
			local W1 = game.Players.LocalPlayer.Character.Humanoid.MoveDirection* RootPart.CFrame.LookVector
			local W2 = game.Players.LocalPlayer.Character.Humanoid.MoveDirection* RootPart.CFrame.RightVector
			WVA = W1.X+W1.Z
			RLV = W2.X+W2.Z


			if Attacking == false then
				game.Players.LocalPlayer.Character.HumanoidRootPart.Position = tors.Position
				if Anim == "Falling" then
					neck.C1 = neck.C1:Lerp(nek * CF(0,0,0.3) * CFA(math.rad(20),0,0),LerpStyle(0.4,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root *CF(0,0,0) * CFA(0,0,0),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
					tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,0,0) * CFA(math.rad(-40),0,math.rad(5)),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
					tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(math.rad(-40),0,math.rad(-5)),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
					tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0.4,0.8,0) * CFA(0,0,math.rad(10)),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
					tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0.4,0.5,0)  * CFA(0,0,math.rad(50)),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				elseif Anim == "Jumping" then
					neck.C1 = neck.C1:Lerp(nek * CF(0,0,0.3) * CFA(math.rad(-20),0,0),LerpStyle(0.4,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root *CF(0,0,0) * CFA(0,0,0),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
					tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0,0,0) * CFA(0,math.rad(-40),math.rad(-20)),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
					tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0,0,0) * CFA(0,math.rad(40),math.rad(20)),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
					tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0.4,0.8,0) * CFA(0,0,math.rad(-10)),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
					tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0.4,0.5,0)  * CFA(0,0,math.rad(-50)),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
				elseif Anim == "Idle" then
					neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(7+math.cos(time()*3.83)*-5 + (-6 + math.sin(time()*3.83)*6 )),math.rad(-24) + math.rad( math.sin((time()*3.83)/2)*10),math.rad(-math.cos((time()*3.83)/2)*13)),LerpStyle(0.2,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut))
					RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root * CF(0,0,math.cos((time()*3.83))/10) * CFA(math.rad(0),math.rad(0),math.rad(0)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(-0.1,math.cos((time()*3.83))/10,0) * CFA(math.rad(-5)- -math.sin((-time()*3.83))/8.7,math.rad(0),math.rad(5)+math.cos((-time()*3.83))/8.7),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(0.1,math.cos((time()*3.83))/10,0) * CFA(math.rad(-5)- -math.sin((-time()*3.83))/8.7,math.rad(0),math.rad(-5)-math.cos((-time()*3.83))/8.7),LerpStyle(0.3*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,-math.cos((time()*3.83))/8,0) * CFA(math.rad(-4),math.rad(-12),math.rad(8)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,-math.cos((time()*3.83))/8,0) * CFA(math.rad(-1),math.rad(7),math.rad(2)),LerpStyle(0.4*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					TailWeld.C0 = TailWeld.C0:Lerp(TC0 * CFrame.Angles(math.rad(-20 + math.sin(-time()*3.83)*-20),math.rad(-math.sin(time()*3.83/2)*24),0),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				elseif Anim == "Walking" and Running == false then
					RLA =  CFrame.new((math.sin((time()*8))/1)*0.5 *WVA,0.3*(1-WVA),(math.sin((time()*8))/1)*0.5 *RLV) * CFrame.Angles((-math.sin((time()*8))/1.5)*RLV,0,(math.sin((time()*8))/1.2)*WVA)
					LLA =  CFrame.new((math.sin((time()*8))/1)*0.5 *WVA,0.3*(1-WVA),(math.sin((time()*8))/1)*0.5 *RLV) * CFrame.Angles((-math.sin((time()*8))/1.5)*RLV,0,(math.sin((time()*8))/1.2)*WVA)
					neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(math.rad(7),math.clamp(math.cos((time()*8))*0.2 + math.rad(-RootPart.RotVelocity.Y*8),math.rad(-85),math.rad(85)),math.rad(-RootPart.RotVelocity.Y*0.4)),LerpStyle(0.4,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root *CF(0,-math.sin((time()*8*2))/3.2,-math.sin((time()*8*2))/3) * CFA(math.rad( -15 + 10 + WVA*15) + -math.rad(math.sin(time() *(8*2))*10),math.clamp( math.rad(0) - -RootPart.RotVelocity.Y/50,math.rad(-20),math.rad(20)),math.cos((time()*8))*0.2),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
					tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(-math.sin((time()*8))/4.5,0,0) * CFA(math.rad(-5),-math.sin((time()*8))*0.1 + math.rad(RootPart.RotVelocity.Y*3),-math.sin((time()*8))*0.4),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
					tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(-math.sin((time()*8))/4.5,0,0) * CFA(math.rad(-5),-math.sin((time()*8))*0.1 + math.rad(RootPart.RotVelocity.Y*3),-math.sin((time()*8))*0.4),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
					tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0,(math.cos((time()*8))/8),0) * RLA * CFA(0, (-math.sin((time()*8))*0.5)*WVA,math.rad( -15 + 10 + WVA*15) + -math.rad(math.sin(time() *(8*2))*10)),LerpStyle(0.2,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(0,(-math.cos((time()*8))/8),0) * LLA * CFA(0, (-math.sin((time()*8))*0.5)*WVA,-math.rad( -15 + 10 + WVA*15) + math.rad(math.sin(time() *(8*2))*10)),LerpStyle(0.2,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					TailWeld.C0 = TailWeld.C0:Lerp(TC0 * CFrame.Angles(math.rad(-30 + math.sin(-time()*8)*-20),0,-math.rad(-math.sin(time()*8/2)*20 + RLV*2)),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				elseif Anim == "Walking" and Running == true then
					RLA =  CFrame.new(0,(0.5 + math.cos(time()*15)*0.5)*WVA+ 0.2,(0.5 - math.cos(time()*15)*0.5)*RLV+ 0.2) * CFrame.Angles(0,-math.rad(math.sin(time()*15)*80)*RLV,math.rad(math.sin(time()*15)*80)*WVA)
					LLA =  CFrame.new(0,(0.5 + math.cos(time()*15)*0.5)*WVA- 0.2,(-0.5 + math.cos(time()*15)*0.5)*RLV- 0.2) * CFrame.Angles(0,-math.rad(math.sin(time()*15)*80)*RLV,math.rad(-math.sin(time()*15)*80)*WVA)
					RAA = CFrame.new(0,0.8 + math.sin(time()*15)*0.9*WVA,math.sin(time()*15)*0.9*RLV) * CFrame.Angles(0,math.rad(-math.cos(time()*15)*85)*RLV,math.rad(math.cos(time()*15)*85)*WVA)
					LAA = CFrame.new(0,0.8 + math.sin(time()*15)*0.9*WVA,math.sin(time()*15)*0.9*-RLV) * CFrame.Angles(0,math.rad(-math.cos(time()*15)*85)*RLV,math.rad(-math.cos(time()*15)*85)*WVA)
					neck.C1 = neck.C1:Lerp(nek * CF(0,0,0) * CFA(0,math.rad(-RootPart.RotVelocity.Y*5),0),LerpStyle(0.4,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					RootPart.RootJoint.C0 = RootPart.RootJoint.C0:Lerp(root *CF((-1 - math.sin(time()*15)*2)*RLV,(-1 - math.sin(time()*15)*2)*WVA,-1 + 0.5 -math.sin(time()*15)*0.8) * CFA(math.rad(80 - math.cos(time()*15)*20),0,0),LerpStyle(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
					tors["Right Shoulder"].C0 = tors["Right Shoulder"].C0:Lerp(rs * CF(0.6+ math.sin(time()*15)*1,0,-0.6)* RAA * CFA(math.rad(-10 - -math.cos(time()*15*2)*10),0,math.rad(80)),LerpStyle(0.6,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
					tors["Left Shoulder"].C0 = tors["Left Shoulder"].C0:Lerp(ls * CF(-0.6+ -math.sin(time()*15)*1,0,-0.6) * LAA * CFA(math.rad(-10 - -math.cos(time()*15*2)*10),0,math.rad(-80)),LerpStyle(0.6,Enum.EasingStyle.Back,Enum.EasingDirection.InOut))
					tors["Right Hip"].C0 = tors["Right Hip"].C0:Lerp(rh * CF(0.4 + -math.cos(time()*15)*0.9,0,0) * RLA * CFA(0, 0,math.rad(50)),LerpStyle(0.6,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					tors["Left Hip"].C0 = tors["Left Hip"].C0:Lerp(lh * CF(-0.4+ math.cos(time()*15)*0.9,0,0) * LLA * CFA(0, 0,math.rad(-80)),LerpStyle(0.6,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
					TailWeld.C0 = TailWeld.C0:Lerp(TC0 * CFrame.new(0,0.7,0.3) * CFrame.Angles(math.rad(-110 + math.sin(-time()*15)*-20),-math.rad(RLV*30),0),LerpStyle(0.1*1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut))
				end
			end
		end
	end)
end
coroutine.wrap(QGLTKE_fake_script)()
local function ENHXC_fake_script() -- ServerAdmin.LocalScript 
	local script = Instance.new('LocalScript', ServerAdmin)

	ServerAdmin.MouseButton1Down:connect(function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/ONEReverseCard/My-Scripts/main/Netless%20Server%20Admin.md"))()
	end)
end
coroutine.wrap(ENHXC_fake_script)()
local function GLUR_fake_script() -- GaleFighter.LocalScript 
	local script = Instance.new('LocalScript', GaleFighter)

	GaleFighter.MouseButton1Down:connect(function()
		loadstring(game:HttpGet(("https://pastebin.com/raw/PjJNLaFa"), true))()
	end)
end
coroutine.wrap(GLUR_fake_script)()
local function XMWTZJ_fake_script() -- joy.LocalScript 
	local script = Instance.new('LocalScript', joy)

	joy.MouseButton1Down:connect(function()
		--[[ Please note that some damage functions may cause inconsistant damage between players and must be fixed manually using the DamageRemote I've turned into a comment.
 	Don't worry about this if you don't know how as it normally doesn't matter.																						--]]
		Bypass = "death"
		loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
		local FavIDs = {
			340106355, --Nefl Crystals
			927529620, --Dimension
			876981900, --Fantasy
			398987889, --Ordinary Days
			1117396305, --Oh wait, it's you.
			885996042, --Action Winter Journey
			919231299, --Sprawling Idiot Effigy
			743466274, --Good Day Sunshine
			727411183, --Knife Fight
			1402748531, --The Earth Is Counting On You!
			595230126 --Robot Language
		}



		--The reality of my life isn't real but a Universe -makhail07
		wait(0.2)
		local Player = game:GetService("Players").LocalPlayer
		local lplr = game:GetService("Players").LocalPlayer
		local mouse = Player:GetMouse()
		local char = workspace.non
		local PlayerGui = Player.PlayerGui
		local Cam = workspace.CurrentCamera
		local Backpack = Player.Backpack
		local hum = char.Humanoid
		local hed = char.Head
		local root = char.HumanoidRootPart
		local rootj = root.RootJoint
		local tors = char.Torso
		local ra = char["Right Arm"]
		local la = char["Left Arm"]
		local rl = char["Right Leg"]
		local ll = char["Left Leg"]
		local neck = tors["Neck"]
		local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
		local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
		local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
		local maincolor = BrickColor.new("Really black")

		-------------------------------------------------------
		--Start Good Stuff--
		-------------------------------------------------------
		local cam = game.Workspace.CurrentCamera
		local CF = CFrame.new
		local angles = CFrame.Angles
		local attack = false
		local Euler = CFrame.fromEulerAnglesXYZ
		local Rad = math.rad
		local IT = Instance.new
		local BrickC = BrickColor.new
		local Cos = math.cos
		local Acos = math.acos
		local Sin = math.sin
		local Asin = math.asin
		local Abs = math.abs
		local Mrandom = math.random
		local Floor = math.floor
		local Vt = Vector3.new
		-------------------------------------------------------
		--End Good Stuff--
		-------------------------------------------------------
		local necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
		local RW = Instance.new("Weld") 
		local LW = Instance.new("Weld")
		local RH = tors["Right Hip"]
		local LH = tors["Left Hip"]
		RW.Name = "RW"
		RW.Part0 = tors 
		RW.C0 = CF(1.5, 0.5, 0)
		RW.C1 = CF(0, 0.5, 0) 
		RW.Part1 = ra
		RW.Parent = tors 
		LW.Name = "LW"
		LW.Part0 = tors 
		LW.C0 = CF(-1.5, 0.5, 0)
		LW.C1 = CF(0, 0.5, 0) 
		LW.Part1 = la
		LW.Parent = tors
		local Effects = {}
		local joyemoji = Instance.new('ParticleEmitter', tors)
		joyemoji.VelocitySpread = 2000
		joyemoji.Lifetime = NumberRange.new(1)
		joyemoji.Speed = NumberRange.new(40)
		joy= {}
		for i=0, 19 do
			joy[#joy+ 1] = NumberSequenceKeypoint.new(i/19, math.random(1, 1))
		end
		joyemoji.Size = NumberSequence.new(joy)
		joyemoji.Rate = 0
		joyemoji.LockedToPart = false
		joyemoji.LightEmission = 0
		joyemoji.Texture = "rbxassetid://73623723"
		joyemoji.Color = ColorSequence.new(BrickColor.new("Institutional white").Color)

		-------------------------------------------------------
		--Start Important Functions--
		-------------------------------------------------------


		function swait(num)
			if num == 0 or num == nil then
				game:service("RunService").Stepped:wait(0)
			else
				for i = 0, num do
					game:service("RunService").Stepped:wait(0)
				end
			end
		end
		function thread(f)
			coroutine.resume(coroutine.create(f))
		end
		function clerp(a, b, t)
			local qa = {
				QuaternionFromCFrame(a)
			}
			local qb = {
				QuaternionFromCFrame(b)
			}
			local ax, ay, az = a.x, a.y, a.z
			local bx, by, bz = b.x, b.y, b.z
			local _t = 1 - t
			return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
		end
		function QuaternionFromCFrame(cf)
			local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
			local trace = m00 + m11 + m22
			if trace > 0 then
				local s = math.sqrt(1 + trace)
				local recip = 0.5 / s
				return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
			else
				local i = 0
				if m00 < m11 then
					i = 1
				end
				if m22 > (i == 0 and m00 or m11) then
					i = 2
				end
				if i == 0 then
					local s = math.sqrt(m00 - m11 - m22 + 1)
					local recip = 0.5 / s
					return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
				elseif i == 1 then
					local s = math.sqrt(m11 - m22 - m00 + 1)
					local recip = 0.5 / s
					return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
				elseif i == 2 then
					local s = math.sqrt(m22 - m00 - m11 + 1)
					local recip = 0.5 / s
					return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
				end
			end
		end
		function QuaternionToCFrame(px, py, pz, x, y, z, w)
			local xs, ys, zs = x + x, y + y, z + z
			local wx, wy, wz = w * xs, w * ys, w * zs
			local xx = x * xs
			local xy = x * ys
			local xz = x * zs
			local yy = y * ys
			local yz = y * zs
			local zz = z * zs
			return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
		end
		function QuaternionSlerp(a, b, t)
			local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
			local startInterp, finishInterp
			if cosTheta >= 1.0E-4 then
				if 1 - cosTheta > 1.0E-4 then
					local theta = math.acos(cosTheta)
					local invSinTheta = 1 / Sin(theta)
					startInterp = Sin((1 - t) * theta) * invSinTheta
					finishInterp = Sin(t * theta) * invSinTheta
				else
					startInterp = 1 - t
					finishInterp = t
				end
			elseif 1 + cosTheta > 1.0E-4 then
				local theta = math.acos(-cosTheta)
				local invSinTheta = 1 / Sin(theta)
				startInterp = Sin((t - 1) * theta) * invSinTheta
				finishInterp = Sin(t * theta) * invSinTheta
			else
				startInterp = t - 1
				finishInterp = t
			end
			return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
		end
		function rayCast(Position, Direction, Range, Ignore)
			return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
		end
		FELOADLIBRARY = {}
		loadstring(game:GetObjects("rbxassetid://5209815302")[1].Source)()
		local Create = FELOADLIBRARY.Create

		function getRegion(point,range,ignore)
			return workspace:FindPartsInRegion3WithIgnoreList(Region3.new(point-Vector3.new(1,1,1)*range/2,point+Vector3.new(1,1,1)*range/2),ignore,100)
		end

		function GetTorso(char)
			return char:FindFirstChild'Torso' or char:FindFirstChild'UpperTorso' or char:FindFirstChild'LowerTorso' or char:FindFirstChild'HumanoidRootPart'
		end

		local M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}
		-------------------------------------------------------
		--Start Damage Function--
		-------------------------------------------------------
		function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
			if hit.Parent == nil then
				return
			end
			local h = hit.Parent:FindFirstChildOfClass("Humanoid")
			for _, v in pairs(hit.Parent:children()) do
				if v:IsA("Humanoid") then
					h = v
				end
			end
			if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("UpperTorso") ~= nil then

				--hit.Parent:FindFirstChild("Head"):BreakJoints()
			end

			if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
				if hit.Parent:findFirstChild("DebounceHit") ~= nil then
					if hit.Parent.DebounceHit.Value == true then
						return
					end
				end
				if insta == true then
					--hit.Parent:FindFirstChild("Head"):BreakJoints()
				end
				local c = Create("ObjectValue"){
					Name = "creator",
					Value = Player,
					Parent = h,
				}
				game:GetService("Debris"):AddItem(c, .5)
				if HitSound ~= nil and HitPitch ~= nil then
					CFuncs.Sound.Create(HitSound, hit, 1, HitPitch) 
				end
				local Damage = math.random(minim, maxim)
				local blocked = false
				local block = hit.Parent:findFirstChild("Block")
				if block ~= nil then
					if block.className == "IntValue" then
						if block.Value > 0 then
							blocked = true
							block.Value = block.Value - 1
							print(block.Value)
						end
					end
				end
				if blocked == false then
					h.Health = h.Health - Damage
					ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
				else
					h.Health = h.Health - (Damage / 2)
					ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
				end
				if Type == "Knockdown" then
					local hum = hit.Parent.Humanoid
					hum.PlatformStand = true
					coroutine.resume(coroutine.create(function(HHumanoid)
						swait(1)
						HHumanoid.PlatformStand = false
					end), hum)
					local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
					local bodvol = Create("BodyVelocity"){
						velocity = angle * knockback,
						P = 5000,
						maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
						Parent = hit,
					}
					local rl = Create("BodyAngularVelocity"){
						P = 3000,
						maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
						angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
						Parent = hit,
					}
					game:GetService("Debris"):AddItem(bodvol, .5)
					game:GetService("Debris"):AddItem(rl, .5)
				elseif Type == "Normal" then
					local vp = Create("BodyVelocity"){
						P = 500,
						maxForce = Vector3.new(math.huge, 0, math.huge),
						velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05,
					}
					if knockback > 0 then
						vp.Parent = hit.Parent.Torso
					end
					game:GetService("Debris"):AddItem(vp, .5)
				elseif Type == "Up" then
					local bodyVelocity = Create("BodyVelocity"){
						velocity = Vector3.new(0, 20, 0),
						P = 5000,
						maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
						Parent = hit,
					}
					game:GetService("Debris"):AddItem(bodyVelocity, .5)
				elseif Type == "DarkUp" then
					coroutine.resume(coroutine.create(function()
						for i = 0, 1, 0.1 do
							swait()
							Effects.Block.Create(BrickColor.new("Black"), hit.Parent.Torso.CFrame, 5, 5, 5, 1, 1, 1, .08, 1)
						end
					end))
					local bodyVelocity = Create("BodyVelocity"){
						velocity = Vector3.new(0, 20, 0),
						P = 5000,
						maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
						Parent = hit,
					}
					game:GetService("Debris"):AddItem(bodyVelocity, 1)
				elseif Type == "Snare" then
					local bp = Create("BodyPosition"){
						P = 2000,
						D = 100,
						maxForce = Vector3.new(math.huge, math.huge, math.huge),
						position = hit.Parent.Torso.Position,
						Parent = hit.Parent.Torso,
					}
					game:GetService("Debris"):AddItem(bp, 1)
				elseif Type == "Freeze" then
					local BodPos = Create("BodyPosition"){
						P = 50000,
						D = 1000,
						maxForce = Vector3.new(math.huge, math.huge, math.huge),
						position = hit.Parent.Torso.Position,
						Parent = hit.Parent.Torso,
					}
					local BodGy = Create("BodyGyro") {
						maxTorque = Vector3.new(4e+005, 4e+005, 4e+005) * math.huge ,
						P = 20e+003,
						Parent = hit.Parent.Torso,
						cframe = hit.Parent.Torso.CFrame,
					}
					hit.Parent.Torso.Anchored = true
					coroutine.resume(coroutine.create(function(Part) 
						swait(1.5)
						Part.Anchored = false
					end), hit.Parent.Torso)
					game:GetService("Debris"):AddItem(BodPos, 3)
					game:GetService("Debris"):AddItem(BodGy, 3)
				end
				local debounce = Create("BoolValue"){
					Name = "DebounceHit",
					Parent = hit.Parent,
					Value = true,
				}
				game:GetService("Debris"):AddItem(debounce, Delay)
				c = Create("ObjectValue"){
					Name = "creator",
					Value = Player,
					Parent = h,
				}
				game:GetService("Debris"):AddItem(c, .5)
			end
		end
		-------------------------------------------------------
		--End Damage Function--
		-------------------------------------------------------

		-------------------------------------------------------
		--Start Damage Function Customization--
		-------------------------------------------------------
		function ShowDamage(Pos, Text, Time, Color)
			local Rate = (1 / 30)
			local Pos = (Pos or Vector3.new(0, 0, 0))
			local Text = (Text or "")
			local Time = (Time or 2)
			local Color = (Color or Color3.new(255, 255, 1))
			local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
			EffectPart.Anchored = true
			local BillboardGui = Create("BillboardGui"){
				Size = UDim2.new(3, 0, 3, 0),
				Adornee = EffectPart,
				Parent = EffectPart,
			}
			local TextLabel = Create("TextLabel"){
				BackgroundTransparency = 1,
				Size = UDim2.new(1, 0, 1, 0),
				Text = Text,
				Font = "Bodoni",
				TextColor3 = Color,
				TextScaled = true,
				TextStrokeColor3 = Color3.fromRGB(0,0,0),
				Parent = BillboardGui,
			}
			game.Debris:AddItem(EffectPart, (Time))
			EffectPart.Parent = game:GetService("Workspace")
			delay(0, function()
				local Frames = (Time / Rate)
				for Frame = 1, Frames do
					wait(Rate)
					local Percent = (Frame / Frames)
					EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
					TextLabel.TextTransparency = Percent
				end
				if EffectPart and EffectPart.Parent then
					EffectPart:Destroy()
				end
			end)
		end
		-------------------------------------------------------
		--End Damage Function Customization--
		-------------------------------------------------------

		function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
			for _, c in pairs(workspace:children()) do
				local hum = c:findFirstChild("Humanoid")
				if hum ~= nil then
					local head = c:findFirstChild("Head")
					if head ~= nil then
						local targ = head.Position - Part.Position
						local mag = targ.magnitude
						if magni >= mag and c.Name ~= plr.Name then
							Damage(head, head, mindam, maxdam, knock, Type, root, 0.1, "http://www.roblox.com/asset/?id=0", 1.2)
						end
					end
				end
			end
		end


		CFuncs = {
			Part = {
				Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
					local Part = Create("Part")({
						Parent = Parent,
						Reflectance = Reflectance,
						Transparency = Transparency,
						CanCollide = false,
						Locked = true,
						BrickColor = BrickColor.new(tostring(BColor)),
						Name = Name,
						Size = Size,
						Material = Material
					})
					RemoveOutlines(Part)
					return Part
				end
			},
			Mesh = {
				Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
					local Msh = Create(Mesh)({
						Parent = Part,
						Offset = OffSet,
						Scale = Scale
					})
					if Mesh == "SpecialMesh" then
						Msh.MeshType = MeshType
						Msh.MeshId = MeshId
					end
					return Msh
				end
			},
			Mesh = {
				Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
					local Msh = Create(Mesh)({
						Parent = Part,
						Offset = OffSet,
						Scale = Scale
					})
					if Mesh == "SpecialMesh" then
						Msh.MeshType = MeshType
						Msh.MeshId = MeshId
					end
					return Msh
				end
			},
			Weld = {
				Create = function(Parent, Part0, Part1, C0, C1)
					local Weld = Create("Weld")({
						Parent = Parent,
						Part0 = Part0,
						Part1 = Part1,
						C0 = C0,
						C1 = C1
					})
					return Weld
				end
			},
			Sound = {
				Create = function(id, par, vol, pit)
					coroutine.resume(coroutine.create(function()
						local S = Create("Sound")({
							Volume = vol,
							Pitch = pit or 1,
							SoundId = id,
							Parent = par or workspace
						})
						wait()
						S:play()
						game:GetService("Debris"):AddItem(S, 6)
					end))
				end
			},
			ParticleEmitter = {
				Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
					local fp = Create("ParticleEmitter")({
						Parent = Parent,
						Color = ColorSequence.new(Color1, Color2),
						LightEmission = LightEmission,
						Size = Size,
						Texture = Texture,
						Transparency = Transparency,
						ZOffset = ZOffset,
						Acceleration = Accel,
						Drag = Drag,
						LockedToPart = LockedToPart,
						VelocityInheritance = VelocityInheritance,
						EmissionDirection = EmissionDirection,
						Enabled = Enabled,
						Lifetime = LifeTime,
						Rate = Rate,
						Rotation = Rotation,
						RotSpeed = RotSpeed,
						Speed = Speed,
						VelocitySpread = VelocitySpread
					})
					return fp
				end
			}
		}
		function RemoveOutlines(part)
			part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
		end
		function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part")({
				formFactor = FormFactor,
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material
			})
			RemoveOutlines(Part)
			return Part
		end
		function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
		function CreateWeld(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld")({
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1
			})
			return Weld
		end


		-------------------------------------------------------
		--Start Effect Function--
		-------------------------------------------------------
		EffectModel = Instance.new("Model", char)
		Effects = {
			Block = {
				Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
					local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
					prt.Anchored = true
					prt.CFrame = cframe
					local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
					game:GetService("Debris"):AddItem(prt, 10)
					if Type == 1 or Type == nil then
						table.insert(Effects, {
							prt,
							"Block1",
							delay,
							x3,
							y3,
							z3,
							msh
						})
					elseif Type == 2 then
						table.insert(Effects, {
							prt,
							"Block2",
							delay,
							x3,
							y3,
							z3,
							msh
						})
					else
						table.insert(Effects, {
							prt,
							"Block3",
							delay,
							x3,
							y3,
							z3,
							msh
						})
					end
				end
			},
			Sphere = {
				Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
					local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
					prt.Anchored = true
					prt.CFrame = cframe
					local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
					game:GetService("Debris"):AddItem(prt, 10)
					table.insert(Effects, {
						prt,
						"Cylinder",
						delay,
						x3,
						y3,
						z3,
						msh
					})
				end
			},
			Cylinder = {
				Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
					local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
					prt.Anchored = true
					prt.CFrame = cframe
					local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
					game:GetService("Debris"):AddItem(prt, 10)
					table.insert(Effects, {
						prt,
						"Cylinder",
						delay,
						x3,
						y3,
						z3,
						msh
					})
				end
			},
			Wave = {
				Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
					local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
					prt.Anchored = true
					prt.CFrame = cframe
					local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
					game:GetService("Debris"):AddItem(prt, 10)
					table.insert(Effects, {
						prt,
						"Cylinder",
						delay,
						x3 / 60,
						y3 / 60,
						z3 / 60,
						msh
					})
				end
			},
			Ring = {
				Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
					local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
					prt.Anchored = true
					prt.CFrame = cframe
					local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
					game:GetService("Debris"):AddItem(prt, 10)
					table.insert(Effects, {
						prt,
						"Cylinder",
						delay,
						x3,
						y3,
						z3,
						msh
					})
				end
			},
			Break = {
				Create = function(brickcolor, cframe, x1, y1, z1)
					local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
					prt.Anchored = true
					prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
					local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
					local num = math.random(10, 50) / 1000
					game:GetService("Debris"):AddItem(prt, 10)
					table.insert(Effects, {
						prt,
						"Shatter",
						num,
						prt.CFrame,
						math.random() - math.random(),
						0,
						math.random(50, 100) / 100
					})
				end
			},
			Spiral = {
				Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
					local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
					prt.Anchored = true
					prt.CFrame = cframe
					local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
					game:GetService("Debris"):AddItem(prt, 10)
					table.insert(Effects, {
						prt,
						"Cylinder",
						delay,
						x3,
						y3,
						z3,
						msh
					})
				end
			},
			Push = {
				Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
					local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
					prt.Anchored = true
					prt.CFrame = cframe
					local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
					game:GetService("Debris"):AddItem(prt, 10)
					table.insert(Effects, {
						prt,
						"Cylinder",
						delay,
						x3,
						y3,
						z3,
						msh
					})
				end
			}
		}
		function part(formfactor ,parent, reflectance, transparency, brickcolor, name, size)
			local fp = IT("Part")
			fp.formFactor = formfactor 
			fp.Parent = parent
			fp.Reflectance = reflectance
			fp.Transparency = transparency
			fp.CanCollide = false 
			fp.Locked = true
			fp.BrickColor = brickcolor
			fp.Name = name
			fp.Size = size
			fp.Position = tors.Position 
			RemoveOutlines(fp)
			fp.Material = "SmoothPlastic"
			fp:BreakJoints()
			return fp 
		end 

		function mesh(Mesh,part,meshtype,meshid,offset,scale)
			local mesh = IT(Mesh) 
			mesh.Parent = part
			if Mesh == "SpecialMesh" then
				mesh.MeshType = meshtype
				if meshid ~= "nil" then
					mesh.MeshId = "http://www.roblox.com/asset/?id="..meshid
				end
			end
			mesh.Offset = offset
			mesh.Scale = scale
			return mesh
		end

		function Magic(bonuspeed, type, pos, scale, value, color, MType)
			local type = type
			local rng = Instance.new("Part", char)
			rng.Anchored = true
			rng.BrickColor = color
			rng.CanCollide = false
			rng.FormFactor = 3
			rng.Name = "Ring"
			rng.Material = "Neon"
			rng.Size = Vector3.new(1, 1, 1)
			rng.Transparency = 0
			rng.TopSurface = 0
			rng.BottomSurface = 0
			rng.CFrame = pos
			local rngm = Instance.new("SpecialMesh", rng)
			rngm.MeshType = MType
			rngm.Scale = scale
			local scaler2 = 1
			if type == "Add" then
				scaler2 = 1 * value
			elseif type == "Divide" then
				scaler2 = 1 / value
			end
			coroutine.resume(coroutine.create(function()
				for i = 0, 10 / bonuspeed, 0.1 do
					swait()
					if type == "Add" then
						scaler2 = scaler2 - 0.01 * value / bonuspeed
					elseif type == "Divide" then
						scaler2 = scaler2 - 0.01 / value * bonuspeed
					end
					rng.Transparency = rng.Transparency + 0.01 * bonuspeed
					rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
				end
				rng:Destroy()
			end))
		end

		function Eviscerate(dude)
			if dude.Name ~= char then
				local val = IT("BoolValue", dude)
				val.Name = "IsHit"
				local ds = coroutine.wrap(function()
					--dude:WaitForChild("Head"):BreakJoints()
					wait(0.5)
					target = nil
					coroutine.resume(coroutine.create(function()
						for i, v in pairs(dude:GetChildren()) do
							if v:IsA("Part") or v:IsA("MeshPart") then
								coroutine.resume(coroutine.create(function()
									v.CanCollide = false
									local PartEmmit1 = IT("ParticleEmitter", reye)
									PartEmmit1.LightEmission = 1
									PartEmmit1.Texture = "rbxassetid://284205403"
									PartEmmit1.Color = ColorSequence.new(maincolor.Color)
									PartEmmit1.Rate = 150
									PartEmmit1.Lifetime = NumberRange.new(1)
									PartEmmit1.Size = NumberSequence.new({
										NumberSequenceKeypoint.new(0, 0.75, 0),
										NumberSequenceKeypoint.new(1, 0, 0)
									})
									PartEmmit1.Transparency = NumberSequence.new({
										NumberSequenceKeypoint.new(0, 0, 0),
										NumberSequenceKeypoint.new(1, 1, 0)
									})
									PartEmmit1.Speed = NumberRange.new(0, 0)
									PartEmmit1.VelocitySpread = 30000
									PartEmmit1.Rotation = NumberRange.new(-500, 500)
									PartEmmit1.RotSpeed = NumberRange.new(-500, 500)
									coroutine.resume(coroutine.create(function()
										wait(0.5)
										PartEmmit1.Enabled = false
										wait(3)
									end))
								end))
							end
						end
					end))
				end)
				ds()
			end
		end

		function FindNearestHead(Position, Distance, SinglePlayer)
			if SinglePlayer then
				return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
			end
			local List = {}
			for i, v in pairs(workspace:GetChildren()) do
				if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
					table.insert(List, v)
				end
			end
			return List
		end

		function Aura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos, MType)
			local type = type
			local rng = Instance.new("Part", char)
			rng.Anchored = true
			rng.BrickColor = color
			rng.CanCollide = false
			rng.FormFactor = 3
			rng.Name = "Ring"
			rng.Material = "Neon"
			rng.Size = Vector3.new(1, 1, 1)
			rng.Transparency = 0
			rng.TopSurface = 0
			rng.BottomSurface = 0
			rng.CFrame = pos
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
			local rngm = Instance.new("SpecialMesh", rng)
			rngm.MeshType = MType
			rngm.Scale = Vector3.new(x1, y1, z1)
			local scaler2 = 1
			local speeder = FastSpeed
			if type == "Add" then
				scaler2 = 1 * value
			elseif type == "Divide" then
				scaler2 = 1 / value
			end
			coroutine.resume(coroutine.create(function()
				for i = 0, 10 / bonuspeed, 0.1 do
					swait()
					if type == "Add" then
						scaler2 = scaler2 - 0.01 * value / bonuspeed
					elseif type == "Divide" then
						scaler2 = scaler2 - 0.01 / value * bonuspeed
					end
					speeder = speeder - 0.01 * FastSpeed * bonuspeed
					rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
					rng.Transparency = rng.Transparency + 0.01 * bonuspeed
					rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
				end
				rng:Destroy()
			end))
		end

		function SoulSteal(dude)
			if dude.Name ~= char then
				local val = IT("BoolValue", dude)
				val.Name = "IsHit"
				local torso = (dude:FindFirstChild'Head' or dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso' or dude:FindFirstChild'LowerTorso' or dude:FindFirstChild'HumanoidRootPart')
				local soulst = coroutine.wrap(function()
					local soul = Instance.new("Part",dude)
					soul.Size = Vector3.new(1,1,1)
					soul.CanCollide = false
					soul.Anchored = false
					soul.Position = torso.Position
					soul.Transparency = 1
					local PartEmmit1 = IT("ParticleEmitter", soul)
					PartEmmit1.LightEmission = 1
					PartEmmit1.Texture = "rbxassetid://569507414"
					PartEmmit1.Color = ColorSequence.new(maincolor.Color)
					PartEmmit1.Rate = 250
					PartEmmit1.Lifetime = NumberRange.new(1.6)
					PartEmmit1.Size = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 1, 0),
						NumberSequenceKeypoint.new(1, 0, 0)
					})
					PartEmmit1.Transparency = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0, 0),
						NumberSequenceKeypoint.new(1, 1, 0)
					})
					PartEmmit1.Speed = NumberRange.new(0, 0)
					PartEmmit1.VelocitySpread = 30000
					PartEmmit1.Rotation = NumberRange.new(-360, 360)
					PartEmmit1.RotSpeed = NumberRange.new(-360, 360)
					local BodPoss = IT("BodyPosition", soul)
					BodPoss.P = 3000
					BodPoss.D = 1000
					BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
					BodPoss.position = torso.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
					wait(1.6)
					soul.Touched:connect(function(hit)
						if hit.Parent == char then
							soul:Destroy()
						end
					end)
					wait(1.2)
					while soul do
						swait()
						PartEmmit1.Color = ColorSequence.new(maincolor.Color)
						BodPoss.Position = tors.Position
					end
				end)
				soulst()
			end
		end
		function FaceMouse()
			local	Cam = workspace.CurrentCamera
			return {
				CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
				Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
			}
		end

		BTAUNT = Instance.new("Sound", hed)
		BTAUNT.SoundId = "http://www.roblox.com/asset/?id=1278102150"
		BTAUNT.Volume = 19
		BTAUNT.Pitch = 1
		BTAUNT.Looped = true

		BTAUNT2 = Instance.new("Sound", hed)
		BTAUNT2.Parent = hed
		BTAUNT2.SoundId = "http://www.roblox.com/asset/?id=957602352"
		BTAUNT2.Volume = 20
		BTAUNT2.Pitch = 1
		BTAUNT2.Looped = true

		BTAUNT3 = Instance.new("Sound", char)
		BTAUNT3.SoundId = "http://www.roblox.com/asset/?id=1090127517"
		BTAUNT3.Volume = 2
		BTAUNT3.Pitch = 1
		BTAUNT3.Looped = true

		BTAUNT4 = Instance.new("Sound", tors)
		BTAUNT4.SoundId = "http://www.roblox.com/asset/?id=2658538628"
		BTAUNT4.Volume = 10
		BTAUNT4.Pitch = 3
		BTAUNT4.Looped = true

		BTAUNT5 = Instance.new("Sound", tors)
		BTAUNT5.SoundId = "http://www.roblox.com/asset/?id=1470848774"
		BTAUNT5.Volume = 5
		BTAUNT5.Pitch = 1
		BTAUNT5.Looped = true

		TEST = Instance.new("Sound", tors)
		TEST.SoundId = "http://www.roblox.com/asset/?id=636494529"
		TEST.Volume = 25
		TEST.Pitch = 1
		TEST.Looped = false
		-------------------------------------------------------
		--End Effect Function--
		-------------------------------------------------------

		function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
			local NEWMESH = IT(MESH)
			if MESH == "SpecialMesh" then
				NEWMESH.MeshType = MESHTYPE
				if MESHID ~= "nil" and MESHID ~= "" then
					NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
				end
				if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
					NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
				end
			end
			NEWMESH.Offset = OFFSET or Vt(0, 0, 0)
			NEWMESH.Scale = SCALE
			NEWMESH.Parent = PARENT
			return NEWMESH
		end

		function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE)
			local NEWPART = IT("Part")
			NEWPART.formFactor = FORMFACTOR
			NEWPART.Reflectance = REFLECTANCE
			NEWPART.Transparency = TRANSPARENCY
			NEWPART.CanCollide = false
			NEWPART.Locked = true
			NEWPART.BrickColor = BrickC(tostring(BRICKCOLOR))
			NEWPART.Name = NAME
			NEWPART.Size = SIZE
			NEWPART.Position = tors.Position
			NEWPART.Material = MATERIAL
			NEWPART:BreakJoints()
			NEWPART.Parent = PARENT
			return NEWPART
		end

		function MakeForm(PART,TYPE)
			local MSH = nil
			if TYPE == "Cyl" then
				MSH = IT("CylinderMesh",PART)
			elseif TYPE == "Ball" then
				MSH = IT("SpecialMesh",PART)
				MSH.MeshType = "Sphere"
			elseif TYPE == "Wedge" then
				MSH = IT("SpecialMesh",PART)
				MSH.MeshType = "Wedge"
			elseif TYPE == "Block" then
				MSH = IT("SpecialMesh",PART)
				MSH.MeshType = "Brick"
			end
			return MSH
		end

		function Cso(ID, PARENT, VOLUME, PITCH)
			local NSound = nil
			coroutine.resume(coroutine.create(function()
				NSound = IT("Sound", PARENT)
				NSound.Volume = VOLUME
				NSound.Pitch = PITCH
				NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
				swait()
				NSound:play()
				game:GetService("Debris"):AddItem(NSound, 50)
			end))
			return NSound
		end
		function CameraEnshaking(Length, Intensity)
			coroutine.resume(coroutine.create(function()
				local intensity = 1 * Intensity
				local rotM = 0.01 * Intensity
				for i = 0, Length, 0.1 do
					swait()
					intensity = intensity - 0.05 * Intensity / Length
					rotM = rotM - 5.0E-4 * Intensity / Length
					hum.CameraOffset = Vector3.new(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)))
					cam.CFrame = cam.CFrame * CF(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity))) * Euler(Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM)
				end
				hum.CameraOffset = Vector3.new(0, 0, 0)
			end))
		end


		function Sink(position,radius)
			for i,v in ipairs(workspace:GetChildren()) do
				if v:FindFirstChild("Hit2By"..plr.Name) == nil then
					local body = v:GetChildren()
					for part = 1, #body do
						if(v:FindFirstChild("Hit2By"..plr.Name) == nil and (body[part].ClassName == "Part" or body[part].ClassName == "MeshPart") and v ~= char) then
							if(body[part].Position - position).Magnitude < radius then
								if v.ClassName == "Model" then
									v:FindFirstChildOfClass("Humanoid").Name = "Humanoid"
									if v:FindFirstChild("Humanoid") then
										local defence = Instance.new("BoolValue",v)
										defence.Name = ("Hit2By"..plr.Name)
										if v.Humanoid.Health ~= 0 then
											local TORS = v:FindFirstChild("HumanoidRootPart") or v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
											if TORS ~= nil then
												local HITFLOOR2, HITPOS2 = Raycast(TORS.Position, (CF(TORS.Position, TORS.Position + Vector3.new(0, -1, 0))).lookVector, 25 * TORS.Size.Y/2, v)
												coroutine.resume(coroutine.create(function()
													if HITFLOOR2 ~= nil then
														TORS.Anchored = true
														local Hole2 = CreatePart(3, EffectModel, "Neon", 0, 0, "Really black", "Hole", Vector3.new(TORS.Size.X*4,0,TORS.Size.X*4))
														Hole2.Color = Color3.new(0,0,0)
														local MESH = MakeForm(Hole2,"Cyl")
														MESH.Scale = Vector3.new(0,1,0)
														Hole2.CFrame = CF(HITPOS2)
														for i = 1, 10 do
															swait()
															MESH.Scale = MESH.Scale + Vector3.new(0.1,0,0.1)
														end
														--Cso("160440683", v:FindFirstChild("Head"), 10, .8)
														Cso("154955269", v:FindFirstChild("Head"), 10, 1)
														repeat
															swait()
															TORS.CFrame = TORS.CFrame * CF(0,-0.1,0)
															--MESH.Scale = MESH.Scale + Vector3.new(0,1.6,0)
														until TORS.Position.Y<position.Y-4
														v:remove()
														for i = 1, 10 do
															swait()
															MESH.Scale = MESH.Scale - Vector3.new(0.1,0,0.1)
														end
														Hole2:remove()
													end
												end))
											end
										end
									end
								end
								--body[part].Velocity = CFrame.new(position,body[part].Position).lookVector*5*maxstrength
							end
						end
					end
				end	
			end
		end
		function Trail(Part)
			local TRAIL = Part:Clone()
			TRAIL.CanCollide = false
			TRAIL.Anchored = true
			TRAIL.Parent = EffectModel
			TRAIL.Name = "Trail"
			local TRANS = Part.Transparency
			coroutine.resume(coroutine.create(function()
				for i = 1, 20 do
					swait()
					TRAIL.Transparency = TRAIL.Transparency + ((1-TRANS)/20)
				end
				TRAIL:remove()
			end))
		end
		function getRegion(point,range,ignore)
			return workspace:FindPartsInRegion3WithIgnoreList(Region3.new(point-Vector3.new(1,1,1)*range/2,point+Vector3.new(1,1,1)*range/2),ignore,100)
		end

		function GetTorso(char)
			return char:FindFirstChild'Torso' or char:FindFirstChild'UpperTorso' or char:FindFirstChild'LowerTorso' or char:FindFirstChild'HumanoidRootPart'
		end

		local M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}


		function CreateSound(ID, PARENT, VOLUME, PITCH)
			local NSound = nil
			coroutine.resume(coroutine.create(function()
				NSound = Instance.new("Sound", PARENT)
				NSound.Volume = VOLUME
				NSound.Pitch = PITCH
				NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
				swait()
				NSound:play()
				game:GetService("Debris"):AddItem(NSound, 10)
			end))
			return NSound
		end

		-------------------------------------------------------
		--End Important Functions--
		-------------------------------------------------------





		-------------------------------------------------------
		--Start Customization--
		-------------------------------------------------------
		local Player_Size = 1
		if Player_Size ~= 1 then
			root.Size = root.Size * Player_Size
			tors.Size = tors.Size * Player_Size
			hed.Size = hed.Size * Player_Size
			ra.Size = ra.Size * Player_Size
			la.Size = la.Size * Player_Size
			rl.Size = rl.Size * Player_Size
			ll.Size = ll.Size * Player_Size
			----------------------------------------------------------------------------------
			rootj.Parent = root
			neck.Parent = tors
			RW.Parent = tors
			LW.Parent = tors
			RH.Parent = tors
			LH.Parent = tors
			----------------------------------------------------------------------------------
			rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
			rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
			neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
			neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
			RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
			LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
			----------------------------------------------------------------------------------
			RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
			LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
			RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
			LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
			--hat.Parent = Character
		end
		----------------------------------------------------------------------------------
		----------------------------------------------------------------------------------
		local equipped = false
		local idle = 0
		local change = 1
		local val = 0
		local toim = 0
		local idleanim = 0.4
		local sine = 0
		local Sit = 1
		----------------------------------------------------------------------------------
		hum.WalkSpeed = 20
		hum.JumpPower = 57
		----------------------------------------------------------------------------------
		local Hole = CreatePart(3, EffectModel, "Neon", 0, 0, "Really black", "Hole", Vector3.new(5,0,5))
		local MESH = MakeForm(Hole,"Cyl")


		local BODY = {}
		for _, c in pairs(char:GetDescendants()) do
			if c:IsA("BasePart") and c.Name ~= "Handle" then
				if c ~= root and c ~= tors and c ~= hed and c ~= ra and c ~= la and c ~= rl and c ~= ll then
					c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
				end
				table.insert(BODY,{c,c.Parent,c.Material,c.Color,c.Transparency,c.Size,c.Name})
			elseif c:IsA("JointInstance") then
				table.insert(BODY,{c,c.Parent,nil,nil,nil,nil,nil})
			end
		end
		for e = 1, #BODY do
			if BODY[e] ~= nil then
				do
					local STUFF = BODY[e]
					local PART = STUFF[1]
					local PARENT = STUFF[2]
					local MATERIAL = STUFF[3]
					local COLOR = STUFF[4]
					local TRANSPARENCY = STUFF[5]
					if PART.ClassName == "Part" and PART ~= root then
						PART.Material = MATERIAL
						PART.Transparency = TRANSPARENCY
					end
			--[[PART.AncestryChanged:Connect(function()
				PART.Parent = PARENT
			end)--]]
				end
			end
		end
		function refit()
			coroutine.resume(coroutine.create(function()
				wait()
				hum.Died:connect(refit)
			end))
			char.Parent = workspace
			for e = 1, #BODY do
				if BODY[e] ~= nil then
					local STUFF = BODY[e]
					local PART = STUFF[1]
					local PARENT = STUFF[2]
					local MATERIAL = STUFF[3]
					local COLOR = STUFF[4]
					local TRANSPARENCY = STUFF[5]
					local SIZE = STUFF[6]
					local NAME = STUFF[7]
					if PART.ClassName == "Part" and PART:IsA("BasePart") and PART ~= root then
						PART.Material = MATERIAL
						PART.Transparency = TRANSPARENCY
						PART.Name = NAME
					end
					if PART.Parent ~= PARENT then
						if PART.Name == "Head" or PART.Name == "Neck" or PART.Name == "Torso" then
							hum:remove()
						end
						PART.Parent = PARENT
						if PART.Name == "Head" or PART.Name == "Neck" or PART.Name == "Torso" then
							hum = Instance.new("Humanoid",char)
						end
					end
				end
			end
		end
		local Regen = {}
		for e = 1, #Regen do
			if Regen[e] ~= nil then
				local STUFF = Regen[e]
				local PART = STUFF[1]
				local PARENT = STUFF[2]
				local MATERIAL = STUFF[3]
				local COLOR = STUFF[4]
				local TRANSPARENCY = STUFF[5]
				if PART.ClassName == "Part" and PART ~= BODY.root then
					PART.Material = MATERIAL
					PART.Color = COLOR
					PART.Transparency = TRANSPARENCY
				end
		--[[PART.AncestryChanged:Connect(function()
			PART.Parent = PARENT
		end)--]]
			end
		end
		function Refit()
			coroutine.resume(coroutine.create(function()
				wait()
				hum.Died:connect(Refit)	
			end))
			for i = 1,#Regen do
				local E = Regen[i]
				local PART = E[1]
				local PARENT = E[2]
				local COLOR = E[3]
				local SIZE = E[4]
				local MATERIAL = E[5]
				if PART:IsA("BasePart") and PART.Parent ~= PARENT then
					PART.Color = COLOR
					PART.Size = SIZE
					PART.Material = MATERIAL
				end
				if PART.Parent ~= PARENT then
					hum.Parent = nil
					PART.Parent = PARENT
					hum.Parent = char
				end
			end
			hum.Parent = char
		end
		function Parents()
			rootj.Parent = root
			neck.Parent = tors
			RW.Parent = tors
			LW.Parent = tors
			RH.Parent = tors
			LH.Parent = tors
			root.Parent = char
			la.Parent = char
			ra.Parent = char
			rl.Parent = char
			ll.Parent = char
			tors.Parent = char
			hed.Parent = char
		end
		local States = {
			"FallingDown";
			"PlatformStanding";
			"Physics";
			"Swimming";
			"Dead";
			"Ragdoll";
			"Seated";
		}
		for i,v in pairs(States) do
			hum:SetStateEnabled(v,false)
		end

		hum.Died:connect(function()
			refit()
			Refit()
			Parents()
		end)
		-------------------------------------------------------
		--End Customization--
		-------------------------------------------------------
		local Blobby = Instance.new("Part", char)
		Blobby.Name = "Blob"
		Blobby.CanCollide = false
		Blobby.BrickColor = BrickColor.new("Deep orange")
		Blobby.Transparency = 0
		Blobby.Material = "Neon"
		Blobby.Size = Vector3.new(1, 1, 2)
		Blobby.TopSurface = Enum.SurfaceType.Smooth
		Blobby.BottomSurface = Enum.SurfaceType.Smooth

		local Weld = Instance.new("Weld", Blobby)
		Weld.Part0 = ra
		Weld.Part1 = Blobby
		Weld.C1 = CFrame.new(0, 1, 0.4)
		Weld.C0 = CFrame.Angles(Rad(0),0,0)

		local M2 = Instance.new("SpecialMesh")
		M2.Parent = Blobby
		M2.MeshId = "rbxassetid://0"
		M2.TextureId = "rbxassetid://749019427"
		M2.Scale = Vector3.new(0.08, 0.08, 0.08)

--[[local naeeym2 = Instance.new("BillboardGui",char)
naeeym2.AlwaysOnTop = true
naeeym2.Size = UDim2.new(5,35,2,15)
naeeym2.StudsOffset = Vector3.new(0, 3.5, 0)
naeeym2.Adornee = hed
naeeym2.Name = "Name"
--naeeym2.PlayerToHideFrom = Player
local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.TextScaled = true
tecks2.BorderSizePixel = 0
tecks2.Text = "Fight Me"
tecks2.Font = Enum.Font.Bodoni
tecks2.TextSize = 30
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = Color3.new(0, 0, 0)
tecks2.TextStrokeColor3 = Color3.new(1, 1, 1)
tecks2.Size = UDim2.new(1,0,0.5,0)
tecks2.Parent = naeeym2]]
		----------------------------------------------------------------------------------
		local AddInstance = function(Object, ...)
			local Obj = Instance.new(Object)
			for i,v in next,(...) do
				Obj[i] = v
			end
			return Obj
		end
		----------------------------------------------------


		-------------------------------------------------------

		-------------------------------------------------------
		--Start Attacks N Stuff--
		-------------------------------------------------------


		local naeeym2 = Instance.new("BillboardGui",char)
		naeeym2.AlwaysOnTop = true
		naeeym2.Size = UDim2.new(5,35,2,35)
		naeeym2.StudsOffset = Vector3.new(0,2,0)
		naeeym2.Adornee = hed
		naeeym2.Name = "Name"

		local tecks2 = Instance.new("TextLabel",naeeym2)
		tecks2.BackgroundTransparency = 1
		tecks2.TextScaled = true
		tecks2.BorderSizePixel = 0
		tecks2.Font = "Cartoon"
		tecks2.TextSize = 30
		tecks2.TextStrokeTransparency = 0
		tecks2.TextColor3 = BrickColor.new('Institutional white').Color
		tecks2.TextStrokeColor3 = BrickColor.new('Really black').Color
		tecks2.Size = UDim2.new(1,0,0.5,0)
		tecks2.Parent = naeeym2
		textfag = tecks2
		tecks2.Text = ":joy:"
		BTAUNT2:Play()
		coroutine.resume(coroutine.create(function()
			while textfag ~= nil do
				swait()
				textfag.Position = UDim2.new(math.random(-0.2,0.2),math.random(-3,9),.05,math.random(-10,10))  
				textfag.Rotation = math.random(-1.8,1.8)
			end
		end))

		BTAUNT4 = Instance.new("Sound", char)
		BTAUNT4.SoundId = "http://www.roblox.com/asset/?id=2658538628"
		BTAUNT4.Volume = 10
		BTAUNT4.Pitch = 1
		BTAUNT4.Parent = hed
		BTAUNT4.Looped = false

		BTAUNT7 = Instance.new("Sound", char)
		BTAUNT7.SoundId = "http://www.roblox.com/asset/?id=2770017501"
		BTAUNT7.Volume = 1.5
		BTAUNT7.Pitch = 1
		BTAUNT7.Parent = char
		BTAUNT7.Looped = false

		BTAUNT6 = Instance.new("Sound", char)
		BTAUNT6.SoundId = "http://www.roblox.com/asset/?id=2675983782"
		BTAUNT6.Volume = 10
		BTAUNT6.Pitch = 1
		BTAUNT6.Parent = hed
		BTAUNT6.Looped = false

		BTAUNT5 = Instance.new("Sound", char)
		BTAUNT5.SoundId = "http://www.roblox.com/asset/?id=468944969"
		BTAUNT5.Volume = 3.5
		BTAUNT5.Pitch = 1
		BTAUNT5.Parent = hed
		BTAUNT5.Looped = false

		BTAUNT3 = Instance.new("Sound", char)
		BTAUNT3.SoundId = "http://www.roblox.com/asset/?id=4565988898"
		BTAUNT3.Volume = 2
		BTAUNT3.Pitch = 1
		BTAUNT3.Parent = hed
		BTAUNT3.Looped = false

		function muda()
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
		end
		function roadroller()
			attack = true
			BTAUNT2:Stop()
			BTAUNT7:Play()
			local Container = Instance.new("Part", char)
			Container.Name = "Blob"
			Container.CanCollide = false
			Container.BrickColor = BrickColor.new("Deep orange")
			Container.Transparency = 0
			Container.Material = "Neon"
			Container.Size = Vector3.new(1, 1, 2)
			Container.TopSurface = Enum.SurfaceType.Smooth
			Container.BottomSurface = Enum.SurfaceType.Smooth

			local aWeld = Instance.new("Weld", Container)
			aWeld.Part0 = tors
			aWeld.Part1 = Container
			aWeld.C1 = CFrame.new(0, 10, 0)
			aWeld.C0 = CFrame.Angles(Rad(0),0,0)

			local M2 = Instance.new("SpecialMesh")
			M2.Parent = Container
			M2.MeshId = "rbxassetid://489989415"
			M2.TextureId = "rbxassetid://489989506"
			M2.Scale = Vector3.new(1, 1, 1)
			for i = 0,67,0.1 do
				swait()
				change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 220* Player_Size) * angles(Rad(0 - 0 * Sin(sine / 1.5)), Rad(0 + 0 * Cos(sine / 1.5)), Rad(0)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0* Cos(sine / 12)), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0* Cos(sine / 12)), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
			end
			for i = 0,40,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, -6, 0 + ((1* Player_Size) - 1)) * angles(Rad(90), Rad(0), Rad(0)), 1)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(90 - 0 * Sin(sine / 1.5)), Rad(0 + 0 * Cos(sine / 1.5)), Rad(0)), 0.15)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
			end
			for i = 0,46,0.1 do
				swait()
				change = 1
				root.Anchored = true
				aWeld.Part0 = root
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0.6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				Container.Size = Vector3.new(15, 5, 5)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(20), Rad(0)), 0.05)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
			end
			Container.CanCollide = true
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				root.Anchored = false
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0.6 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0.6, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, -1, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(1, 0, 0.1 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0.5, 0.1, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0.4, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0.6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0.4, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, -0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 1, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0.8		, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0.8, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0.7, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0.9 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 1, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,0.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			muda()
			aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
			for i = 0,20.1,0.1 do
				swait()
				change = 1
				aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-30)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-30)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0.5* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(-90 + 0* Cos(sine / 12))), 0.6)
			end
			for i, v in pairs(FindNearestHead(Container.CFrame.p, 19.5)) do
				if v:FindFirstChild("Head") then
					Eviscerate(v)
					Cso("1744093986", v, 10, 1)
				end
			end
			for i = 0, 9 do
				Magic(0.5, "Add", Container.CFrame, Vector3.new(60,80,50), 2, BrickC("Deep orange"), "Sphere")
				Magic(2, "Add", Container.CFrame, Vector3.new(60,80,50), 2, BrickC("Dark orange"), "Sphere")
				Aura(3, 5.5, "Add", Container.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 5, 5, 50, -0.05, BrickC("Deep orange"), 0, "Sphere")
				change = 1
			end
			for i = 0,20.1,0.1 do
				swait()
				aWeld.C1 = clerp(aWeld.C1, CF(0 + 0.5* Player_Size * Sin(sine / 1.2), 0 + 0.5* Player_Size * Sin(sine / 1.2), 0 + 0.5* Player_Size * Sin(sine / 1.2) + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
				aWeld.Part0 = root
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-30)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(30)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0.5* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			BTAUNT7:Stop()
			BTAUNT2:Play()
			Container:Remove()
			tecks2.Text = ":joy:"
			change = 1.7
			attack = false
		end

		function bruhmoment()
			attack = true
			BTAUNT3:Play()
			while BTAUNT3.Playing == true do
				tecks2.Text = "He spittin facts"
				for i = 0,7,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 90 * Sin(sine / 5)), Rad(0), Rad(0)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0.5* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0.3* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0.3* Player_Size * Sin(sine / 1.2)) * angles(Rad(0), Rad(0), Rad(0)), 1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0* Cos(sine / 12)), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
			end
			if BTAUNT3.Playing == false then
				tecks2.Text = ":joy:"
				change = 1.7
				attack = false
			end
		end

		function when()
			attack = true
			BTAUNT5:Play()
			while BTAUNT5.Playing == true do
				for i = 0,0.5,0.1 do
					swait()
					change = 2
					BTAUNT5.Pitch = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
				for i = 0,0.5,0.1 do
					swait()
					change = 2
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
				for i = 0,0.5,0.1 do
					swait()
					change = 2
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
				for i = 0,0.5,0.1 do
					swait()
					change = 2
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
				for i = 0,0.5,0.1 do
					swait()
					change = 2
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
				for i = 0,0.5,0.1 do
					swait()
					change = 2
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
				for i = 0,0.5,0.1 do
					swait()
					change = 2
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
				for i = 0,0.5,0.1 do
					swait()
					change = 2
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
				for i = 0,0.5,0.1 do
					swait()
					change = 2
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
				for i = 0,0.5,0.1 do
					swait()
					change = 2
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
				for i = 0,0.5,0.1 do
					swait()
					change = 2
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
				for i = 0,0.5,0.1 do
					swait()
					change = 2
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
				for i = 0,0.5,0.1 do
					swait()
					change = 2
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
				for i = 0,0.5,0.1 do
					swait()
					change = 2
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
				for i = 0,0.5,0.1 do
					swait()
					change = 2
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
				for i = 0,0.5,0.1 do
					swait()
					change = 2
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
				for i = 0,0.5,0.1 do
					swait()
					change = 2
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
				for i = 0,0.5,0.1 do
					swait()
					change = 2
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
				for i = 0,0.5,0.1 do
					swait()
					change = 2
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
				BTAUNT5:Stop()
				for i = 0,0.5,0.1 do
					swait()
					change = 2
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
			end
			if BTAUNT5.Playing == false then
				tecks2.Text = "Touture Dance"
				change = 1.7
				attack = false
			end
		end
		function isthatajojoreference()
			attack = true
			BTAUNT2:Stop()
			BTAUNT6:Play()
			for i = 0,7.5,0.1 do
				swait()
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(-0,0.4,-0.5) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,5.5,0.1 do
				swait()
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(-0,0.4,-0.5) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(170), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(127), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			print("1!")
			for i = 0,7.5,0.1 do
				swait()
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(-0,0.4,-0.5) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,5.5,0.1 do
				swait()
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(-0,0.4,-0.5) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(170), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(127), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			print("2!")
			for i = 0,4.5,0.1 do
				swait()
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(-0,0.4,-0.5) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,5.5,0.1 do
				swait()
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(-0,0.4,-0.5) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(170), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(127), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			print("3!")
			for i = 0,5.5,0.1 do
				swait()
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(-0,0.4,-0.5) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			for i = 0,5.5,0.1 do
				swait()
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(-0,0.4,-0.5) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(170), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(127), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
			end
			print("4!")
			while BTAUNT6.Playing == true do
				for i = 0,2.5,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0,0) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(75), Rad(-0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-75), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, -0.1 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(130 + 0* Cos(sine / 12))), 0.5)
					LW.C0 = clerp(LW.C0, CF(-1.4* Player_Size, 0.25 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
				end
				for i = 0,0.5,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0.5,0,0) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(75), Rad(-0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-75), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, -0.15 - 0 * Cos(sine / 12)* Player_Size, -0.3* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(120 + 0* Cos(sine / 12))), 0.5)
					LW.C0 = clerp(LW.C0, CF(-1.8* Player_Size, 0.25 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
				end
				for i = 0,2.7,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 + 0 * Sin(sine / 12)), Rad(0), Rad(60)), 0.5)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(-1,-1,-0.2) * angles(Rad(10), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.5  * Player_Size) * angles(Rad(0), Rad(97), Rad(10)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.5 * Player_Size) * angles(Rad(0), Rad(-97), Rad(-10)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(170 + 0* Cos(sine / 12))), 0.5)
					LW.C0 = clerp(LW.C0, CF(-1.8* Player_Size, 0.25 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
				end
				for i = 0,0.5,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 + 0 * Sin(sine / 12)), Rad(0), Rad(60)), 0.5)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(-0.5,-1,-0.2) * angles(Rad(10), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.5  * Player_Size) * angles(Rad(0), Rad(97), Rad(10)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.5 * Player_Size) * angles(Rad(0), Rad(-97), Rad(-10)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, -0.15 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(120 + 0* Cos(sine / 12))), 0.5)
					LW.C0 = clerp(LW.C0, CF(-1.8* Player_Size, 0.25 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
				end
				for i = 0,2.5,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(-1,0,0) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(75), Rad(-0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-75), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, -0.25 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(130 + 0* Cos(sine / 12))), 0.5)
					LW.C0 = clerp(LW.C0, CF(-1.8* Player_Size, 0.25 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
				end
				for i = 0,2.7,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 + 0 * Sin(sine / 12)), Rad(0), Rad(60)), 0.5)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(-2,-1,-0.2) * angles(Rad(10), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.5  * Player_Size) * angles(Rad(0), Rad(97), Rad(10)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.5 * Player_Size) * angles(Rad(0), Rad(-97), Rad(-10)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.25 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(170 + 0* Cos(sine / 12))), 0.5)
					LW.C0 = clerp(LW.C0, CF(-1.8* Player_Size, 0.25 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
				end
				for i = 0,1.7,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(30 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 0.5)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(-2,0.4,-0.5) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -0.6 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(30)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -0.6 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(-30)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(150), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.5)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(150), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.5)
				end
				for i = 0,2,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-30 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 0.5)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(-2,0.4,-0.5) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(-30)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(30)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(60), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(60), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
				end
				for i = 0,3.4,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-30 + 0 * Sin(sine / 12)), Rad(0), Rad(-40)), 0.1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(-2,0.4,-0.1) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1.5 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(-40), Rad(85), Rad(30)) * angles(Rad(30 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(-30)) * angles(Rad(20 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
					RW.C0 = clerp(RW.C0, CF(0.8* Player_Size, -0.5 - 0 * Cos(sine / 12)* Player_Size, -0.8* Player_Size) * angles(Rad(60), Rad(0+ 0* Sin(sine / 20)), Rad(-50 + 0* Cos(sine / 12))), 0.1)
					LW.C0 = clerp(LW.C0, CF(0.2* Player_Size, 0.65 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(60), Rad(0+ 0* Sin(sine / 20)), Rad(120 + 0* Cos(sine / 12))), 0.1)
				end
				for i = 0,0.5,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(40)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(-2,0.4,0.8) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(-50)), 1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
				for i = 0,0.2,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(40)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(-1,0.4,0.8) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(-100)), 0.6)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
				for i = 0,0.4,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(40)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0.4,0.2) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(-150)), 0.6)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
				for i = 0,0.4,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(40)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0.4,0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
				for i = 0,1.7,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(30 + 0 * Sin(sine / 12)), Rad(0), Rad(10)), 0.5)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(.8,0.4,-0) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.15  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.15 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
					RW.C0 = clerp(RW.C0, CF(1.2* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-30 + 0* Cos(sine / 12))), 0.5)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.15 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-130 + 0* Cos(sine / 12))), 0.5)
				end
				for i = 0,1.7,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(30 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(1,0.4,-0) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.15  * Player_Size) * angles(Rad(0), Rad(95), Rad(0)) * angles(Rad(-23 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.15 * Player_Size) * angles(Rad(0), Rad(-95), Rad(0)) * angles(Rad(-23 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
					RW.C0 = clerp(RW.C0, CF(1.2* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-30 + 0* Cos(sine / 12))), 0.5)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.15 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-60 + 0* Cos(sine / 12))), 0.5)
				end
				for i = 0,1.7,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(30 + 0 * Sin(sine / 12)), Rad(0), Rad(10)), 0.5)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(1.5,0.4,-0) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.15  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.15 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-30 + 0* Cos(sine / 12))), 0.5)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.15 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-130 + 0* Cos(sine / 12))), 0.5)
				end
				for i = 0,1.7,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 0.5)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(1.5,0.4,-0) * angles(Rad(20), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.7)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55  * Player_Size) * angles(Rad(0), Rad(85), Rad(20)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55 * Player_Size) * angles(Rad(0), Rad(-85), Rad(-20)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.85 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-40 + 0* Cos(sine / 12))), 0.5)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.85 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
				end
				for i = 0,0.7,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(30 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 0.5)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(1.5,0.4,-0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55  * Player_Size) * angles(Rad(0), Rad(85), Rad(30)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55 * Player_Size) * angles(Rad(0), Rad(-85), Rad(-30)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.35 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-40 + 0* Cos(sine / 12))), 0.5)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.35 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
				end
				for i = 0,1.7,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 0.5)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(1.5,0.4,-0) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55  * Player_Size) * angles(Rad(0), Rad(85), Rad(-0)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.85 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-40 + 0* Cos(sine / 12))), 0.5)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.85 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
				end
				for i = 0,1,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(30 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 0.5)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(1.5,0.4,-0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55  * Player_Size) * angles(Rad(0), Rad(85), Rad(30)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55 * Player_Size) * angles(Rad(0), Rad(-85), Rad(-30)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.15 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-30 + 0* Cos(sine / 12))), 0.5)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.15 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(30 + 0* Cos(sine / 12))), 0.5)
				end
				for i = 0,0.7,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(30 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 0.5)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(1.2,0.4,-0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55  * Player_Size) * angles(Rad(0), Rad(85), Rad(30)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55 * Player_Size) * angles(Rad(0), Rad(-85), Rad(-30)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.35 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-40 + 0* Cos(sine / 12))), 0.5)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.35 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
				end
				for i = 0,2.7,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 0.5)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(1.8,0.4,-0) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55  * Player_Size) * angles(Rad(0), Rad(85), Rad(-0)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.85 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-40 + 0* Cos(sine / 12))), 0.5)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.85 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
				end
				for i = 0,2,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(30 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 0.5)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(1.2,0.4,-0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55  * Player_Size) * angles(Rad(0), Rad(85), Rad(30)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55 * Player_Size) * angles(Rad(0), Rad(-85), Rad(-30)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.15 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-30 + 0* Cos(sine / 12))), 0.5)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.15 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(30 + 0* Cos(sine / 12))), 0.5)
				end
				for i = 0,3.4,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-30 + 0 * Sin(sine / 12)), Rad(0), Rad(40)), 0.1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(1.5,0.4,-0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1.5 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(-40), Rad(85), Rad(30)) * angles(Rad(30 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(-30)) * angles(Rad(20 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
					RW.C0 = clerp(RW.C0, CF(0.8* Player_Size, -0.5 - 0 * Cos(sine / 12)* Player_Size, -0.8* Player_Size) * angles(Rad(60), Rad(0+ 0* Sin(sine / 20)), Rad(-50 + 0* Cos(sine / 12))), 0.1)
					LW.C0 = clerp(LW.C0, CF(0.2* Player_Size, 0.65 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(60), Rad(0+ 0* Sin(sine / 20)), Rad(120 + 0* Cos(sine / 12))), 0.1)
				end
				for i = 0,0.5,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(40)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(1,0.4,0.8) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(-50)), 1)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
				for i = 0,0.2,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(40)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0.5,0.4,0.8) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(-100)), 0.6)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
				for i = 0,0.4,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(40)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0.4,0.2) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(-150)), 0.6)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
				for i = 0,0.4,0.1 do
					swait()
					change = 1
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(40)), 1)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0.4,0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
					RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				end
			end
			BTAUNT2:Play()
			attack = false
		end


		function discord()
			attack = true
			BTAUNT2:Stop()
			tecks2.Text = "car noises"
			hum.WalkSpeed = 100
			BTAUNT4:Play()
			la.Transparency = 1
			ra.Transparency = 1
			for i = 0,17,0.1 do
				swait()
				change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, -0.6, -1.5 + ((1* Player_Size) - 1)) * angles(Rad(90 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,-2.6,-2) * angles(Rad(-90), Rad(0 + 10 * Cos(sine / 1.5)), Rad(0)), 1)
				RH.C0 = clerp(RH.C0, CF(1.8 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0.7  * Player_Size) * angles(Rad(0), Rad(90), Rad(-180)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1.8 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0.7 * Player_Size) * angles(Rad(0), Rad(-90), Rad(180)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(0* Player_Size, -1.55 - 0 * Cos(sine / 12)* Player_Size, -0.7* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-0* Player_Size, -2.55 - 0 * Cos(sine / 12)* Player_Size, -0.7* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
			end
			for i = 0,97,0.05 do
				swait()
				change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, -0.6, -1.5 + ((1* Player_Size) - 1)) * angles(Rad(90 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0,-2.6,-2) * angles(Rad(-90), Rad(0 + 10 * Cos(sine / 1.5)), Rad(0)), 1)
				RH.C0 = clerp(RH.C0, CF(1.8 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0.7  * Player_Size) * angles(Rad(0), Rad(90), Rad(-180)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1.8 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0.7 * Player_Size) * angles(Rad(0), Rad(-90), Rad(180)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(0* Player_Size, -1.55 - 0 * Cos(sine / 12)* Player_Size, -0.7* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-0* Player_Size, -2.55 - 0 * Cos(sine / 12)* Player_Size, -0.7* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
			end
			BTAUNT4:Stop()
			hum.WalkSpeed = 20
			la.Transparency = 0
			ra.Transparency = 0
			tecks2.Text = ":joy:"
			BTAUNT2:Play()
			change = 1.7
			attack = false
		end

		function E()
			attack = true
			Cso("1937272483", hed, 10, 1)
			tecks2.Text = "E"
			for i = 0,7,0.1 do
				swait()
				change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0.5* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0.3* Player_Size * Sin(sine / 1.2)* Player_Size, 0.8 + 0.3* Player_Size * Sin(sine / 1.2)) * angles(Rad(0 - 10 * Sin(sine / 1.5)), Rad(0 + 10 * Cos(sine / 1.5)), Rad(0)), 1)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0* Cos(sine / 12)), Rad(0+ 0* Sin(sine / 20)), Rad(90 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0* Cos(sine / 12)), Rad(0+ 0* Sin(sine / 20)), Rad(-90 + 0* Cos(sine / 12))), 1)
			end
			tecks2.Text = ":joy:"
			change = 1.7
			attack = false
		end




		function bruh()
			attack = true
			Cso("4615152991", hed, 10, 1)
			tecks2.Text = "me going to the poop dimension"
			for i = 0,7,0.1 do
				swait()
				change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0.5* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0.3* Player_Size * Sin(sine / 1.2)* Player_Size, 0.8 + 0.3* Player_Size * Sin(sine / 1.2)) * angles(Rad(-70 - 10 * Sin(sine / 1.5)), Rad(0 + 10 * Cos(sine / 1.5)), Rad(0)), 0.11)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-50)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(50)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(-70), Rad(0+ 0* Sin(sine / 20)), Rad(20 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(-70), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
			end
			for i = 0,7,0.1 do
				swait()
				change = 1
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0.5* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0.3* Player_Size * Sin(sine / 1.2)* Player_Size, 45.8 + 0* Player_Size * Sin(sine / 1.2)) * angles(Rad(-70 - 10 * Sin(sine / 1.5)), Rad(0 + 10 * Cos(sine / 1.5)), Rad(0)), 0.03)
				RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-50)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(50)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(-70), Rad(0+ 0* Sin(sine / 20)), Rad(20 + 0* Cos(sine / 12))), 1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(-70), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
			end
			tecks2.Text = ":joy:"
			change = 1.7
			attack = false
		end
		local Head1 = Instance.new("Part", char)
		Head1.Name = "Blob"
		Head1.CanCollide = false
		Head1.BrickColor = BrickColor.new("Really black")
		Head1.Transparency = 1
		Head1.Material = "Plastic"
		Head1.Size = Vector3.new(1, 1, 1)
		Head1.TopSurface = Enum.SurfaceType.Smooth
		Head1.BottomSurface = Enum.SurfaceType.Smooth

		local Weld = Instance.new("Weld", Head1)
		Weld.Part0 = tors
		Weld.Part1 = Head1
		Weld.C1 = CFrame.new(0, 0, 0)
		Weld.C0 = CFrame.Angles(Rad(0),0,0)

		local M3 = Instance.new("SpecialMesh")
		M3.Parent = Head1
		M3.MeshType = "Brick"
		M3.Scale = Vector3.new(5, 5, 5)
		face1 = Instance.new("Decal", Head1)
		face1.Face = "Front"
		face1.Transparency = 1
		face1.Texture = "rbxassetid://153159982"


		-------------------------------------------------------
		--End Attacks N Stuff--
		-------------------------------------------------------
		mouse.KeyDown:connect(function(key)
			if attack == false then
				if key == "e" then
					E()
				elseif key == "z" then
					bruh()
				elseif key == "t" then
					face1.Transparency = 0
					Head1.Transparency = 0
					Cso("1747834381", hed, 10, 1)
					BTAUNT2:Stop()
					wait(19) 
					Cso("3173571164", hed, 10, 1)
					Head1.Transparency = 1
					face1.Transparency = 1
					wait(19)
					BTAUNT2:Play()
				elseif key == "r" then
					roadroller()
				elseif key == "x" then
					bruhmoment()
				elseif key == "c" then
					discord()
				elseif key == "v" then
					when()
				elseif key == "f" then
					isthatajojoreference()
				end
			end
		end)

		local FakeVel = Vector3.new(0,0,0)
		if lplr == Player then
			spawn(function()
				while true do
					local Positions = {}
					local Speeds = {}
					for i = 1,10 do
						table.insert(Positions, root.CFrame)
						table.insert(Speeds, root.Velocity)
						swait()
					end
				end
			end)
		end

		if lplr ~= Player then
			local Last = root.Position
			Mover.OnClientEvent:Connect(function(v, Speed)
				for i,v2 in pairs(v) do
					FakeVel = Speed[i]
					if v[i].p ~= Last then
						if MoverSpeed.Value == "Remote" then
							root.CFrame = v[i]
						end
						Last = v[i].p
						swait()
					end
				end
			end)
			spawn(function()
				while true do
					game:GetService("RunService").RenderStepped:wait()
					FakeRoot = workspace.Terrain:WaitForChild(Player.Name.." char tracker")
					if MoverSpeed.Value == "Smooth" then
						root.CFrame = FakeRoot.CFrame
					end
				end
			end)
		end

		-------------------------------------------------------
		--Start Damage Function--
		-------------------------------------------------------
		function PixelBlock(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos) --Thanks, Star Glitcher!
			local type = type
			local rng = Instance.new("Part", char)
			rng.Anchored = true
			rng.BrickColor = color
			rng.CanCollide = false
			rng.FormFactor = 3
			rng.Name = "Ring"
			rng.Material = "Neon"
			rng.Size = Vector3.new(1, 1, 1)
			rng.Transparency = 0
			rng.TopSurface = 0
			rng.BottomSurface = 0
			rng.CFrame = pos
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
			local rngm = Instance.new("SpecialMesh", rng)
			rngm.MeshType = "Brick"
			if rainbowmode == true then
				rng.Color = Color3.new(r/255,g/255,b/255)
			end
			local scaler2 = 1
			local speeder = FastSpeed/10
			if type == "Add" then
				scaler2 = 1*value
			elseif type == "Divide" then
				scaler2 = 1/value
			end
			coroutine.resume(coroutine.create(function()
				for i = 0,10/bonuspeed,0.1 do
					swait()
					if type == "Add" then
						scaler2 = scaler2 - 0.01*value/bonuspeed
					elseif type == "Divide" then
						scaler2 = scaler2 - 0.01/value*bonuspeed
					end
					speeder = speeder - 0.01*FastSpeed*bonuspeed/10
					rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
					rng.Transparency = rng.Transparency + 0.01*bonuspeed
				end
				rng:Destroy()
			end))
		end

		function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
			if hit.Parent == nil then
				return
			end
			local h = hit.Parent:FindFirstChildOfClass("Humanoid")
			for _, v in pairs(hit.Parent:children()) do
				if v:IsA("Humanoid") then
					h = v
				end
			end
			if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("UpperTorso") ~= nil then

				hit.Parent:FindFirstChild("Head"):BreakJoints()
			end

			if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
				if hit.Parent:findFirstChild("DebounceHit") ~= nil then
					if hit.Parent.DebounceHit.Value == true then
						return
					end
				end
				if insta == true then
					hit.Parent:FindFirstChild("Head"):BreakJoints()
				end
				local c = Create("ObjectValue"){
					Name = "creator",
					Value = Player,
					Parent = h,
				}
				game:GetService("Debris"):AddItem(c, .5)
				if HitSound ~= nil and HitPitch ~= nil then
					CFuncs.Sound.Create(HitSound, hit, 1, HitPitch) 
				end
				local Damage = math.random(minim, maxim)
				local blocked = false
				local block = hit.Parent:findFirstChild("Block")
				if block ~= nil then
					if block.className == "IntValue" then
						if block.Value > 0 then
							blocked = true
							block.Value = block.Value - 1
							print(block.Value)
						end
					end
				end
				if blocked == false then
					--h.Health = h.Health - Damage
					ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
				else
					--h.Health = h.Health - (Damage / 2)
					ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
				end
				if Type == "Knockdown" then
					local hum = hit.Parent.Humanoid
					hum.PlatformStand = true
					coroutine.resume(coroutine.create(function(HHumanoid)
						swait(1)
						HHumanoid.PlatformStand = false
					end), hum)
					local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
					local bodvol = Create("BodyVelocity"){
						velocity = angle * knockback,
						P = 5000,
						maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
						Parent = hit,
					}
					local rl = Create("BodyAngularVelocity"){
						P = 3000,
						maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
						angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
						Parent = hit,
					}
					game:GetService("Debris"):AddItem(bodvol, .5)
					game:GetService("Debris"):AddItem(rl, .5)
				elseif Type == "Normal" then
					local vp = Create("BodyVelocity"){
						P = 500,
						maxForce = Vector3.new(math.huge, 0, math.huge),
						velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05,
					}
					if knockback > 0 then
						vp.Parent = hit.Parent.Torso
					end
					game:GetService("Debris"):AddItem(vp, .5)
				elseif Type == "Up" then
					local bodyVelocity = Create("BodyVelocity"){
						velocity = Vector3.new(0, 20, 0),
						P = 5000,
						maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
						Parent = hit,
					}
					game:GetService("Debris"):AddItem(bodyVelocity, .5)
				elseif Type == "DarkUp" then
					coroutine.resume(coroutine.create(function()
						for i = 0, 1, 0.1 do
							swait()
							Effects.Block.Create(BrickColor.new("Royal purple"), hit.Parent.Torso.CFrame, 5, 5, 5, 1, 1, 1, .08, 1)
						end
					end))
					local bodyVelocity = Create("BodyVelocity"){
						velocity = Vector3.new(0, 20, 0),
						P = 5000,
						maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
						Parent = hit,
					}
					game:GetService("Debris"):AddItem(bodyVelocity, 1)
				elseif Type == "Snare" then
					local bp = Create("BodyPosition"){
						P = 2000,
						D = 100,
						maxForce = Vector3.new(math.huge, math.huge, math.huge),
						position = hit.Parent.Torso.Position,
						Parent = hit.Parent.Torso,
					}
					game:GetService("Debris"):AddItem(bp, 1)
				elseif Type == "Freeze" then
					local BodPos = Create("BodyPosition"){
						P = 50000,
						D = 1000,
						maxForce = Vector3.new(math.huge, math.huge, math.huge),
						position = hit.Parent.Torso.Position,
						Parent = hit.Parent.Torso,
					}
					local BodGy = Create("BodyGyro") {
						maxTorque = Vector3.new(4e+005, 4e+005, 4e+005) * math.huge ,
						P = 20e+003,
						Parent = hit.Parent.Torso,
						cframe = hit.Parent.Torso.CFrame,
					}
					hit.Parent.Torso.Anchored = true
					coroutine.resume(coroutine.create(function(Part) 
						swait(1.5)
						Part.Anchored = false
					end), hit.Parent.Torso)
					game:GetService("Debris"):AddItem(BodPos, 3)
					game:GetService("Debris"):AddItem(BodGy, 3)
				end
				local debounce = Create("BoolValue"){
					Name = "DebounceHit",
					Parent = hit.Parent,
					Value = true,
				}
				game:GetService("Debris"):AddItem(debounce, Delay)
				c = Create("ObjectValue"){
					Name = "creator",
					Value = Player,
					Parent = h,
				}
				game:GetService("Debris"):AddItem(c, .5)
			end
		end

		function damage(range,mindam,maxdam,pos)
			if true then return end
		end
		-------------------------------------------------------
		--End Damage Function--
		-------------------------------------------------------

		-------------------------------------------------------
		--Start Animations--
		-------------------------------------------------------
		print("By XandersAltAccount1")
		while true do
			swait()
			sine = sine + change
			local torvel = (FakeVel * Vector3.new(1, 0, 1)).magnitude
			local velderp = FakeVel.y
			if lplr == plr then
				torvel = (root.Velocity * Vt(1, 0, 1)).magnitude
				velderp = root.Velocity.y
			end
			hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, char)
			if equipped == true or equipped == false then
				if attack == false then
					idle = idle + 1
				else
					idle = 0
				end
				if 1 < root.Velocity.y and hitfloor == nil then
					Anim = "Jump"
					if attack == false then
						rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 0.9 + 0.5* Player_Size * Cos(sine / -15)) * angles(Rad(0), Rad(0), Rad(0)), 0.17)
						neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
						RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.2 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
						LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.9 - 0.1 * Cos(sine / 20), -.5* Player_Size) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
						RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
						LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
					end
				elseif -1 > root.Velocity.y and hitfloor == nil then
					Anim = "Fall"
					if attack == false then
						rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
						neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
						RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
						LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
						RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
						LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(55), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
					end
				elseif torvel < 1 and hitfloor ~= nil then
					Anim = "Idle"
					change = 1.75
					if attack == false then
						neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-10 + 12.5 * Sin(sine / 12)), Rad(0), Rad(0)), 0.3)
						rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.3* Player_Size * Sin(sine / 12)) * angles(Rad(0 - 0 * Sin(sine / 20)), Rad(0 + 0 * Cos(sine / 20)), Rad(0)), 0.35)
						RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0.3 * Player_Size * Sin(sine / 12), -0.5  * Player_Size) * angles(Rad(0), Rad(76), Rad(-10)) * angles(Rad(-13 - -7 * Cos(sine / 12)), Rad(0), Rad(0)), 0.35)
						LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.3 * Player_Size * Sin(sine / 12), -0.5 * Player_Size) * angles(Rad(0), Rad(-76), Rad(10)) * angles(Rad(-13 - -7 * Cos(sine / 12)), Rad(0), Rad(0)), 0.35)
						RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0.15 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10* Cos(sine / 12)), Rad(0+ 0* Sin(sine / 20)), Rad(10 + -12.5 * Cos(sine / 12))), 0.12)
						LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0.15 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10* Cos(sine / 12)), Rad(0+ 0* Sin(sine / 20)), Rad(-10 + 12.5 * Cos(sine / 12))), 0.12)
					end
				elseif torvel > 2 and torvel < 25 and hitfloor ~= nil then
					Anim = "Walk"
					change = 1.3
					if attack == false then
						rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 0.375 + -0.73 * Sin(sine / 3.5) + -Sin(sine / 3.5) / 1* Player_Size) * angles(Rad(-3 - 32.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(1 * Cos(sine / 7))), 0.15)
						neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(30 * Sin(sine / 3.5)), Rad(0), Rad(0 * Cos(sine / 7)) - hed.RotVelocity.Y / 15), 0.3)
						RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8 - 1 * Cos(sine / 7) / 2* Player_Size, 0.8 * Cos(sine / 7) / 0.7* Player_Size)  * angles(Rad(-10 - 25 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2, Rad(90 - 15 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(-0)), 0.3)
						LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8 + 1 * Cos(sine / 7) / 2* Player_Size, -0.8 * Cos(sine / 7) / 0.7* Player_Size) * angles(Rad(-10 + 25 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2, Rad(-90 - 15 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
						RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(137)  * Cos(sine / 7) , Rad(10 * Cos(sine / 7)), Rad(0) - ra.RotVelocity.Y / 75), 0.1)
						LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-137)  * Cos(sine / 7) , Rad(10 * Cos(sine / 7)) ,	Rad(0) + la.RotVelocity.Y / 75), 0.1)
					end
				elseif torvel >= 25 and hitfloor ~= nil then
					Anim = "Sprint"
					change = 1.35
					if attack == false then
						rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.13 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(23 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(15 * Cos(sine / 7))), 0.15)
						neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-10), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.3)
						RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-10 - 25 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 15 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(20)), 0.3)
						LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-10 + 25 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 15 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(-20)), 0.3)
						RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(57)  * Cos(sine / 7) , Rad(10 * Cos(sine / 7)), Rad(0) - ra.RotVelocity.Y / 75), 0.1)
						LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-57)  * Cos(sine / 7) , Rad(10 * Cos(sine / 7)) ,	Rad(0) + la.RotVelocity.Y / 75), 0.1)
					end
				end
			end
			refit()
			Refit()
			Parents()
			if 0 < #Effects then
				for e = 1, #Effects do
					if Effects[e] ~= nil then
						local Thing = Effects[e]
						if Thing ~= nil then
							local Part = Thing[1]
							local Mode = Thing[2]
							local Delay = Thing[3]
							local IncX = Thing[4]
							local IncY = Thing[5]
							local IncZ = Thing[6]
							if 1 >= Thing[1].Transparency then
								if Thing[2] == "Block1" then
									Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
									local Mesh = Thing[1].Mesh
									Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Block2" then
									Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
									local Mesh = Thing[7]
									Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Block3" then
									Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
									local Mesh = Thing[7]
									Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Cylinder" then
									local Mesh = Thing[1].Mesh
									Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Blood" then
									local Mesh = Thing[7]
									Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
									Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Elec" then
									local Mesh = Thing[1].Mesh
									Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Disappear" then
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Shatter" then
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
									Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
									Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
									Thing[6] = Thing[6] + Thing[5]
								end
							else
								Part.Parent = nil
								table.remove(Effects, e)
							end
						end
					end
				end
			end
		end
		-----------------------------------------------------
	end)
end
coroutine.wrap(XMWTZJ_fake_script)()
local function REMN_fake_script() -- KillBot.LocalScript 
	local script = Instance.new('LocalScript', KillBot)

	KillBot.MouseButton1Down:connect(function()
		loadstring(game:HttpGetAsync("https://pastebin.com/raw/G24tcRXA"))()
	end)
end
coroutine.wrap(REMN_fake_script)()
local function TMCJUQL_fake_script() -- Grapple.LocalScript 
	local script = Instance.new('LocalScript', Grapple)

	Grapple.MouseButton1Down:connect(function()

		HumanDied = false
		local CountSCIFIMOVIELOL = 1
		function SCIFIMOVIELOL(Part0,Part1,Position,Angle)
			local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL
			AlignPos.ApplyAtCenterOfMass = true;
			AlignPos.MaxForce = 5772000--67752;
			AlignPos.MaxVelocity = math.huge/9e110;
			AlignPos.ReactionForceEnabled = false;
			AlignPos.Responsiveness = 200;
			AlignPos.RigidityEnabled = false;
			local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL
			AlignOri.MaxAngularVelocity = math.huge/9e110;
			AlignOri.MaxTorque = 5772000
			AlignOri.PrimaryAxisOnly = false;
			AlignOri.ReactionTorqueEnabled = false;
			AlignOri.Responsiveness = 200;
			AlignOri.RigidityEnabled = false;
			local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "Ath_"..CountSCIFIMOVIELOL
			local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "Ath_"..CountSCIFIMOVIELOL
			AttachmentA.Orientation = Angle or Vector3.new(0,0,0)
			AttachmentA.Position = Position or Vector3.new(0,0,0)
			AlignPos.Attachment1 = AttachmentA;
			AlignPos.Attachment0 = AttachmentB;
			AlignOri.Attachment1 = AttachmentA;
			AlignOri.Attachment0 = AttachmentB;
			CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1
			return {AlignPos,AlignOri,AttachmentA,AttachmentB}
		end

		if _G.netted ~= true then
			_G.netted = true
			coroutine.wrap(function()
				settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
				settings().Physics.AllowSleep = false
				game:GetService("RunService").RenderStepped:Connect(function()
					game:FindFirstChildOfClass("Players").LocalPlayer.MaximumSimulationRadius=math.pow(math.huge,math.huge)
					sethiddenproperty(game:FindFirstChildOfClass("Players").LocalPlayer,"SimulationRadius",math.huge*math.huge)
				end)
			end)()
		end

		game:FindFirstChildOfClass("Players").LocalPlayer["Character"].Archivable = true
		local hatnameclone = {}
		for _,v in next, game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:GetChildren() do
			if v:IsA("Accessory") then
				if hatnameclone[v.Name] then
					if hatnameclone[v.Name] == "s" then
						hatnameclone[v.Name] = {}
					end
					table.insert(hatnameclone[v.Name],v)
				else
					hatnameclone[v.Name] = "s"
				end
			end
		end
		for _,v in pairs(hatnameclone) do
			if type(v) == "table" then
				local num = 1
				for _,w in pairs(v) do
					w.Name = w.Name..num
					num = num + 1
				end
			end
		end
		hatnameclone = nil

		local DeadChar = game:FindFirstChildOfClass("Players").LocalPlayer.Character

		local fldr = Instance.new("Folder",game:FindFirstChildOfClass("Players").LocalPlayer["Character"])
		fldr.Name = "DMYF"
		local CloneChar = DeadChar:Clone()
		local ANIMATIONHERE
		if CloneChar:FindFirstChild("Animate") then
			ANIMATIONHERE = CloneChar:FindFirstChild("Animate"):Clone()
			CloneChar:FindFirstChild("Animate"):Destroy()
		end
		if CloneChar:FindFirstChildOfClass("Folder") then CloneChar:FindFirstChildOfClass("Folder"):Destroy() end
		if CloneChar.Torso:FindFirstChild("Neck") then
			local Clonessss = CloneChar.Torso:FindFirstChild("Neck"):Clone()
			Clonessss.Part0 = nil
			Clonessss.Part1 = DeadChar.Head
			Clonessss.Parent = DeadChar.Torso
		end
		CloneChar.Parent = fldr
		CloneChar.HumanoidRootPart.CFrame = DeadChar.HumanoidRootPart.CFrame
		CloneChar.Humanoid.BreakJointsOnDeath = false
		CloneChar.Name = "non"
		CloneChar.Humanoid.DisplayDistanceType = "None"

		for _,v in next, DeadChar:GetChildren() do
			if v:IsA("Accessory") then
				local topacc = false
				if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
				v.Handle.Massless = true
				v.Handle.CanCollide = false
				if v.Handle:FindFirstChildOfClass("Attachment") then
					local ath__ = v.Handle:FindFirstChildOfClass("Attachment")
					if ath__.Name == "HatAttachment" or ath__.Name == "HairAttachment" or ath__.Name == "FaceFrontAttachment" or ath__.Name == "FaceCenterAttachment" then
						topacc = ath__.Name
					end
				end
				local bv = Instance.new("BodyVelocity",v.Handle)
				bv.Velocity = Vector3.new(0,0,0)
				coroutine.wrap(function()
					if topacc then
						local allthings = SCIFIMOVIELOL(v.Handle,DeadChar.Torso,Vector3.new(0,1.5,0)+ (DeadChar.Head[topacc].Position + (v.Handle[topacc].Position*-1)),Vector3.new(0,0,0))
						local normaltop = allthings[1].Attachment1
						local alipos = allthings[1]
						local alirot = allthings[2]
						local p0 = v.Handle
						local p1 = DeadChar.Head
						alipos.Parent = CloneChar:FindFirstChild(v.Name).Handle
						alirot.Parent = CloneChar:FindFirstChild(v.Name).Handle
						while true do
							game:GetService("RunService").RenderStepped:wait()
							if HumanDied then break end
							coroutine.wrap(function()
								if alipos.Attachment1 == normaltop then
									p0.CFrame = p0.CFrame:lerp((((DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)) * p1[topacc].CFrame) * p0[topacc].CFrame:inverse()),1)
								else
									v.Handle.CFrame = v.Handle.CFrame:lerp(alipos.Attachment1.Parent.CFrame * CFrame.new(alipos.Attachment1.Position) * CFrame.Angles(math.rad(alipos.Attachment1.Rotation.X),math.rad(alipos.Attachment1.Rotation.Y),math.rad(alipos.Attachment1.Rotation.Z)),1)
								end
							end)()
						end
					else
						SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
					end
				end)()
			end
		end

		local a = DeadChar.Torso
		local b = DeadChar.HumanoidRootPart
		local c = DeadChar.Humanoid
		a.Parent = game:FindFirstChildOfClass("Workspace")
		c.Parent = game:FindFirstChildOfClass("Workspace")
		local told = a:Clone()
		local told1 = c:Clone()
		b["RootJoint"].Part0 = told
		b["RootJoint"].Part1 = DeadChar.Head
		a.Name = "torso"
		a.Neck:Destroy()
		c.Name = "Mizt Hub Best"
		told.Parent = DeadChar
		told1.Parent = DeadChar
		DeadChar.PrimaryPart = told
		told1.Health = 0
		b:Destroy()
		a.Parent = DeadChar
		c.Parent = DeadChar
		told:Destroy()
		told1:Destroy()
		a.Name = "Torso"

		if CloneChar.Head:FindFirstChildOfClass("Decal") then CloneChar.Head:FindFirstChildOfClass("Decal").Transparency = 1 end
		if DeadChar:FindFirstChild("Animate") then DeadChar:FindFirstChild("Animate"):Destroy() end

		local Collider
		function UnCollide()
			if HumanDied then Collider:Disconnect(); return end
    --[[for _,Parts in next, CloneChar:GetChildren() do
        if Parts:IsA("BasePart") then
            Parts.CanCollide = false 
        end 
    end]]
			for _,Parts in next, DeadChar:GetChildren() do
				if Parts:IsA("BasePart") then
					Parts.CanCollide = false
				end 
			end 
		end
		Collider = game:GetService("RunService").Stepped:Connect(UnCollide)

		local resetBindable = Instance.new("BindableEvent")
		resetBindable.Event:connect(function()
			game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
			resetBindable:Destroy()
			HumanDied = true
			pcall(function()
				game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
				DeadChar.Head:Destroy()
				DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
				game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
				if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
			end)
		end)
		game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChildOfClass("Humanoid") or CloneChar:FindFirstChildOfClass("Humanoid").Health <= 0 and not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChildOfClass("Humanoid") or DeadChar:FindFirstChildOfClass("Humanoid").Health <= 0 then 
					HumanDied = true
					pcall(function()
						game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
						DeadChar.Head:Destroy()
						DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
						game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
						if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
					end)
					if resetBindable then
						game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
						resetBindable:Destroy()
					end
					break
				end		
			end
		end)()


		SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"])
		SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"])
		SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"])
		SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"])
		SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"])
		SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"])

		for _,v in pairs(DeadChar:GetChildren()) do
			if v:IsA("BasePart") and v.Name ~= "Head" then
		--[[local bv = Instance.new("BodyVelocity",v)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then break end
				v.CFrame = CloneChar[v.Name].CFrame
			end
		end)()]]
			elseif v:IsA("BasePart") and v.Name == "Head" then
				local bv = Instance.new("BodyVelocity",v)
				bv.Velocity = Vector3.new(0,0,0)
				coroutine.wrap(function()
					while true do
						game:GetService("RunService").RenderStepped:wait()
						if HumanDied then break end
						v.CFrame = DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)
					end
				end)()
			end
		end

		for _,BodyParts in next, CloneChar:GetDescendants() do
			if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
				BodyParts.Transparency = 1 end end
		game:GetService("RunService").RenderStepped:wait()
		game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
		game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Camera").CameraSubject = CloneChar.Humanoid

		for _,v in next, DeadChar:GetChildren() do
			if v:IsA("Accessory") then
				if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
			end
		end

		if ANIMATIONHERE then ANIMATIONHERE.Parent = CloneChar end

		--3DG
		--three dimensional grapples
		function clerp(c1,c2,al)
			local com1 = {c1.X,c1.Y,c1.Z,c1:toEulerAnglesXYZ()}
			local com2 = {c2.X,c2.Y,c2.Z,c2:toEulerAnglesXYZ()}
			for i,v in pairs(com1) do 
				com1[i] = v+(com2[i]-v)*al
			end
			return CFrame.new(com1[1],com1[2],com1[3]) * CFrame.Angles(select(4,unpack(com1)))
		end

		plr = game:service'Players'.LocalPlayer
		plrgui = plr.PlayerGui
		char = plr.Character
		mouse = plr:GetMouse()
		humanoid = char:findFirstChild("Humanoid")
		torso = char:findFirstChild("Torso")
		head = char.Head
		ra = char:findFirstChild("Right Arm")
		la = char:findFirstChild("Left Arm")
		rl = char:findFirstChild("Right Leg")
		ll = char:findFirstChild("Left Leg")
		rs = torso:findFirstChild("Right Shoulder")
		ls = torso:findFirstChild("Left Shoulder")
		rh = torso:findFirstChild("Right Hip")
		lh = torso:findFirstChild("Left Hip")
		neck = torso:findFirstChild("Neck")
		rj = char:findFirstChild("HumanoidRootPart"):findFirstChild("RootJoint")
		rootpart = char:findFirstChild("HumanoidRootPart")
		camera = workspace.CurrentCamera
		anim = char:findFirstChild("Animate")
		if anim then
			anim:Destroy()
		end

		local lal = Instance.new('Sound', head)
		lal.SoundId = "rbxassetid://145048800"
		lal.Volume = 1
		lal:play()
		game:service'Debris':AddItem(lal, 8)

		local rm = Instance.new("Weld", torso)
		rm.C0 = CFrame.new(1.5, 0.5, 0)
		rm.C1 = CFrame.new(0, 0.5, 0)
		rm.Part0 = torso
		rm.Part1 = ra
		rm.Name = 'Right Shoulder'

		local lm = Instance.new("Weld", torso)
		lm.C0 = CFrame.new(-1.5, 0.5, 0)
		lm.C1 = CFrame.new(0, 0.5, 0)
		lm.Part0 = torso
		lm.Part1 = la
		lm.Name = 'Left Shoulder'

		local rlegm = Instance.new("Weld", torso)
		rlegm.C0 = CFrame.new(0.5, -1, 0)
		rlegm.C1 = CFrame.new(0, 1, 0)
		rlegm.Part0 = torso
		rlegm.Part1 = rl

		local llegm = Instance.new("Weld", torso)
		llegm.C0 = CFrame.new(-0.5, -1, 0)
		llegm.C1 = CFrame.new(0, 1, 0)
		llegm.Part0 = torso
		llegm.Part1 = ll

		rj.C0 = CFrame.new()
		rj.C1 = CFrame.new()

		neck.C0 = CFrame.new(0, 1, 0)
		neck.C1 = CFrame.new(0, -0.5, 0)


		local speed = 0.3
		local angle = 0
		local anglespeed = 1
		rsc0 = rm.C0
		lsc0 = lm.C0
		llc0 = llegm.C0
		rlc0 = rlegm.C0
		rootc0 = rj.C0
		neckc0 = neck.C0

		model = Instance.new('Model', char)
		model.Name = '3DG'
		function Weld(part0,part1,c1,c0)
			local w = Instance.new('Weld', model)
			w.Part0 = part0
			w.Part1 = part1
			w.C0 = c0 or CFrame.new()
			w.C1 = c1 or CFrame.new()
		end

		local BasePart = Instance.new('Part')
		BasePart.FormFactor = 'Custom'
		BasePart.Material = 'Neon'
		BasePart.CanCollide = false
		BasePart.Locked = true
		BasePart.TopSurface = 10
		BasePart.BottomSurface = 10
		BasePart.LeftSurface = 10
		BasePart.RightSurface = 10
		BasePart.FrontSurface = 10
		BasePart.BackSurface = 10
		BasePart:breakJoints()


		for i = 1,2 do
			local strap = BasePart:clone()
			strap.Size = Vector3.new(1.025,.2,1.025)
			strap.Parent = model
			strap.BrickColor = BrickColor.new()
			strap:BreakJoints()
			Weld(strap, la, CFrame.new(0, .1 - i/3,0))
		end

		for i = 1,2 do
			local strap = BasePart:clone()
			strap.Size = Vector3.new(1.025,.2,1.025)
			strap.Parent = model
			strap.BrickColor = BrickColor.new()
			strap:BreakJoints()
			Weld(strap, ra, CFrame.new(0, .1 - i/3,0))
		end

		local ropeStart = BasePart:clone()
		ropeStart.Size = Vector3.new(.2,1.75,.2)
		ropeStart.Parent = model
		ropeStart.BrickColor = BrickColor.new()
		ropeStart:BreakJoints()
		Weld(ropeStart, ra, CFrame.new(-.45, -.5, 0))
		local ropeStart2 = BasePart:clone()
		ropeStart2.Size = Vector3.new(.2,1.75,.2)
		ropeStart2.Parent = model
		ropeStart2.BrickColor = BrickColor.new()
		ropeStart2:BreakJoints()
		Weld(ropeStart2, la, CFrame.new(.45, -.5, 0))

		local ropeCont = BasePart:clone()
		ropeCont.Size = Vector3.new(.8,.2,.8)
		ropeCont.Parent = model
		ropeCont.BrickColor = BrickColor.new(199)
		ropeCont:BreakJoints()
		Instance.new('CylinderMesh', ropeCont)
		Weld(ropeCont, la, CFrame.new(.5, .05, 0), CFrame.Angles(math.pi/2, math.pi/2, 0))
		local ropeCont2 = BasePart:clone()
		ropeCont2.Size = Vector3.new(.8,.2,.8)
		ropeCont2.Parent = model
		ropeCont2.BrickColor = BrickColor.new(199)
		ropeCont2:BreakJoints()
		Instance.new('CylinderMesh', ropeCont2)
		Weld(ropeCont2, ra, CFrame.new(-.5, .05, 0), CFrame.Angles(math.pi/2, math.pi/2, 0))

		local GasTank = BasePart:clone()
		GasTank.Size = Vector3.new(.8,1.4,.8)
		GasTank.Parent = model
		GasTank.BrickColor = BrickColor.new(194)
		GasTank:BreakJoints()
		Instance.new('SpecialMesh', GasTank)
		Weld(GasTank, ra, CFrame.new(0, -.25, .5))
		local GasTank2 = BasePart:clone()
		GasTank2.Size = Vector3.new(.8,1.4,.8)
		GasTank2.Parent = model
		GasTank2.BrickColor = BrickColor.new(194)
		GasTank2:BreakJoints()
		Instance.new('SpecialMesh', GasTank2)
		Weld(GasTank2, la, CFrame.new(0, -.25, .5))

		local pa = BasePart:clone()
		pa.BrickColor = BrickColor.new()
		pa.Anchored = true
		pa.Size = Vector3.new(.5,1,.5)
		local special = Instance.new('SpecialMesh', pa)
		special.MeshId = "rbxassetid://1033714"
		special.Scale = Vector3.new(.25,2,.25)
		local ropePA = BasePart:clone()
		ropePA.Parent = pa
		ropePA.Anchored = true
		ropePA.BrickColor = BrickColor.new'White'
		Instance.new('CylinderMesh', ropePA).Scale = Vector3.new(.25,1,.25)

		local pa2 = BasePart:clone()
		pa2.BrickColor = BrickColor.new()
		pa2.Anchored = true
		pa2.Size = Vector3.new(.5,1,.5)
		local special = Instance.new('SpecialMesh', pa2)
		special.MeshId = "rbxassetid://1033714"
		special.Scale = Vector3.new(.25,2,.25)
		local ropePA2 = BasePart:clone()
		ropePA2.Parent = pa2
		ropePA2.Anchored = true
		ropePA2.BrickColor = BrickColor.new'White'
		Instance.new('CylinderMesh', ropePA2).Scale = Vector3.new(.25,1,.25)

		local pa3 = BasePart:clone()
		pa3.Transparency = 1
		pa3.Anchored = true
		pa3.Size = Vector3.new(2,2,2)

		local torso3 = Instance.new('Part', char)
		torso3.Name = 'FakeTorsoForStuff'
		torso3.Size = torso.Size
		torso3.Transparency = 1
		torso3:breakJoints()
		Weld(torso3, torso)

		Instance.new('PointLight', torso)

		local jumpmode

		local SGui = Instance.new('ScreenGui', plr.PlayerGui)
		local JumpButton = Instance.new('TextButton', SGui)
		JumpButton.BackgroundColor = BrickColor.new('Dark stone grey')
		JumpButton.BorderSizePixel = 4
		JumpButton.TextColor3 = Color3.new(1,1,1)
		JumpButton.BorderColor3 = Color3.new()
		JumpButton.TextStrokeTransparency = .5
		JumpButton.FontSize = 'Size12'
		JumpButton.Text = 'Thrust up when grappled'
		JumpButton.Size = UDim2.new(0, 250, 0, 50)
		JumpButton.Position = UDim2.new(1, -250, 1, -50)
		local OnOff = Instance.new('Frame', JumpButton)
		OnOff.BackgroundColor3 = Color3.new()
		OnOff.BorderSizePixel = 0
		OnOff.Size = UDim2.new(.8, 0, 0, 5)
		OnOff.Position = UDim2.new(.1, 0, 1, -10)
		JumpButton.MouseButton1Down:connect(function()
			jumpmode = not jumpmode
			if jumpmode then
				OnOff.BackgroundColor3 = Color3.new(0,1,0)
			else
				OnOff.BackgroundColor3 = Color3.new()
			end
		end)



		local bodygyro = Instance.new('BodyGyro', torso)
		bodygyro.maxTorque = Vector3.new(14e16,14e16,14e16)
		bodygyro.P = 10000

		ro=Instance.new("RocketPropulsion",rootpart)
		ro.Name = 'RockatPropoolsun'
		ro.MaxSpeed=200
		ro.MaxThrust=8000
		ro.TurnP = 0
		ro.MaxTorque=Vector3.new(14e16,14e16,14e16)

		ro2=Instance.new("RocketPropulsion",torso)
		ro2.Name = 'RockatPropoolsun2'
		ro2.MaxSpeed=200
		ro2.MaxThrust=8000
		ro2.TurnP = 0
		ro2.MaxTorque=Vector3.new(14e16,14e16,14e16)
		local run
		mouse.KeyDown:connect(function(k)
			if k:byte() == 48 then
				run = not run
				if run then
					humanoid.WalkSpeed = 22
				else
					humanoid.WalkSpeed = 16
				end
			end
			if k:byte() == 32 then
				if Grapple1 or Grapple2 then
					wait()
					humanoid.PlatformStand = true
					rlegm.C0 = rlc0 * CFrame.new(0, .5, -.65) * CFrame.Angles(-math.pi/8, 0, .1)
					llegm.C0 = llc0 * CFrame.new(0, .5, -.65) * CFrame.Angles(-math.pi/8, 0, -.1)
					if pa3.Parent ~= nil then
						ro3:Fire()
					end
					if Grapple1 then
						ro:Fire()
					end
					if Grapple2 then
						ro2:Fire()
					end
				end
			end
			if k=="q" then
				local sound = Instance.new('Sound', head)
				sound.SoundId = "rbxassetid://160248505"
				sound.Pitch = 3+math.random()/3
				sound.Volume = .8
				sound:play()
				game:service'Debris':AddItem(sound,4)
				lm.Parent = torso
				pa.CFrame = la.CFrame
				local grapplepos = pa.Position
				local grapplevelocity = (mouse.Hit.p - grapplepos).unit*50
				local lastgrapplepos = pa.Position 
				while wait() do
					lastgrapplepos = grapplepos 
					grapplepos = grapplepos + grapplevelocity
					local RayCast = Ray.new(lastgrapplepos, (grapplepos - lastgrapplepos))
					local hit, hitpos = workspace:FindPartOnRay(RayCast, char)
					if (torso.Position - pa.Position).magnitude > 900 then
						pa.Parent = nil
						break
					end
					pa.Anchored = true
					pa.CFrame = CFrame.new(grapplepos, grapplepos+grapplevelocity) * CFrame.Angles(math.pi/2, 0, 0)
					pa.Parent = char
					if hit then
						local rotX,rotY,rotZ = pa.CFrame:toEulerAnglesXYZ()
						local sound = Instance.new('Sound', head)
						sound.SoundId = "rbxassetid://146466021"
						sound.Pitch = 1.2+math.random()/3
						sound.Volume = .25
						sound:play()
						game:service'Debris':AddItem(sound,4)
						pa.Parent = char
						pa.CFrame=CFrame.new(hitpos.x, hitpos.y, hitpos.z)*CFrame.Angles(rotX,rotY,rotZ)*CFrame.Angles(math.pi,0,0)
						ro.Target=pa
						lm.Parent = torso
						local ray = Ray.new(rootpart.Position, Vector3.new(0, -6, 0))
						local hitz, enz = workspace:FindPartOnRay(ray, char)
						local hum = hit and hit.Parent and hit.Parent:findFirstChild'Humanoid'
						if hum then
							hum:TakeDamage(math.random(7,11))
						end
						local hum = hit and hit.Parent and hit.Parent.Parent and hit.Parent.Parent:findFirstChild'Humanoid'
						if hum then
							hum:TakeDamage(math.random(7,11))
						end
						if pa.Parent ~= nil and humanoid.PlatformStand or not (hitz and hitz.CanCollide) then
							ro:Fire()
							if jumpmode then
								humanoid.Jump = true
							end
						end
						Gweld = Instance.new("Weld", char)
						Gweld.C0 = hit.CFrame:toObjectSpace(pa.CFrame)
						Gweld.Part0 = hit
						Gweld.Part1 = pa
						pa.Anchored = false
						Grapple1Hit = hit
						Grapple1 = true
						break
					end
					pa.Anchored = true
					pa.CFrame = CFrame.new(grapplepos, grapplepos+grapplevelocity) * CFrame.Angles(math.pi/2, 0, 0)
				end
			end
			if k=="e" then
				local sound = Instance.new('Sound', head)
				sound.SoundId = "rbxassetid://160248505"
				sound.Pitch = 3+math.random()/3
				sound.Volume = .8
				sound:play()
				game:service'Debris':AddItem(sound,4)
				pa2.CFrame = ra.CFrame
				rm.Parent = torso
				local grapplepos = pa2.Position
				local grapplevelocity = (mouse.Hit.p - grapplepos).unit*50
				local lastgrapplepos = pa2.Position 
				while wait() do
					lastgrapplepos = grapplepos 
					grapplepos = grapplepos + grapplevelocity
					local RayCast = Ray.new(lastgrapplepos, (grapplepos - lastgrapplepos))
					local hit, hitpos = workspace:FindPartOnRay(RayCast, char)
					if (torso.Position - pa2.Position).magnitude > 900 then
						pa2.Parent = nil
						break
					end
					pa2.Anchored = true
					pa2.CFrame = CFrame.new(grapplepos, grapplepos+grapplevelocity) * CFrame.Angles(math.pi/2, 0, 0)
					pa2.Parent = char
					if hit then
						local rotX,rotY,rotZ = pa2.CFrame:toEulerAnglesXYZ()
						local sound = Instance.new('Sound', head)
						sound.SoundId = "rbxassetid://146466021"
						sound.Pitch = 1.2+math.random()/3
						sound.Volume = .25
						sound:play()
						game:service'Debris':AddItem(sound,4)
						pa2.Parent = char
						pa2.CFrame=CFrame.new(hitpos.x, hitpos.y, hitpos.z)*CFrame.Angles(rotX,rotY,rotZ)*CFrame.Angles(math.pi,0,0)
						ro2.Target=pa2
						rm.Parent = torso
						local ray = Ray.new(rootpart.Position, Vector3.new(0, -6, 0))
						local hitz, enz = workspace:FindPartOnRay(ray, char)
						local hum = hit and hit.Parent and hit.Parent:findFirstChild'Humanoid'
						if hum then
							hum:TakeDamage(math.random(7,11))
						end
						local hum = hit and hit.Parent and hit.Parent.Parent and hit.Parent.Parent:findFirstChild'Humanoid'
						if hum then
							hum:TakeDamage(math.random(7,11))
						end
						if pa2.Parent ~= nil and humanoid.PlatformStand or not (hitz and hitz.CanCollide) then
							if jumpmode then
								humanoid.Jump = true
							end
							ro2:Fire()
						end
						Gweld2 = Instance.new("Weld", char)
						Gweld2.C0 = hit.CFrame:toObjectSpace(pa2.CFrame)
						Gweld2.Part0 = hit
						Gweld2.Part1 = pa2
						pa2.Anchored = false
						Grapple2Hit = hit
						Grapple2 = true
						break
					end
					pa2.Anchored = true
					pa2.CFrame = CFrame.new(grapplepos, grapplepos+grapplevelocity) * CFrame.Angles(math.pi/2, 0, 0)
				end
			end
		end)

		mouse.KeyUp:connect(function(k)
			if k=="q" then
				pcall(function() Gweld:remove() end)
				game:service'RunService'.RenderStepped:wait()
				pcall(function() pa.Parent = nil Grapple1 = false end)
				pcall(function() ro:Abort() end)
				game:service'RunService'.RenderStepped:wait()
				pcall(function() ro2.Target=pa2 if Grapple2 and humanoid.PlatformStand or Grapple2 and not hitz then ro2:Fire() end end)
			elseif k=="e" then
				pcall(function() Gweld2:remove() end)
				game:service'RunService'.RenderStepped:wait()
				pcall(function() pa2.Parent = nil Grapple2 = false end)
				pcall(function() ro2:Abort() end)
				game:service'RunService'.RenderStepped:wait()
				pcall(function() ro.Target=pa if Grapple1 and humanoid.PlatformStand or Grapple1 and not hitz then ro:Fire() end end)
			end
		end)


		local MidPointUsed = false
		local TorsoSmoke = Instance.new('Smoke', torso)


		game:service'RunService'.RenderStepped:connect(function()
			angle = (angle % 100) + anglespeed/10
			mvmnt = math.pi * math.sin(math.pi*2/100*(angle*10))
			local rscf = rsc0
			local lscf = lsc0
			local rlcf = rlc0
			local llcf = llc0
			local rjcf = rootc0
			local ncf = neckc0
			for i,object in pairs(char:children()) do
				if object:IsA("Tool") then
					tool = true
					if not debounce then
						for x,value in pairs(object:children()) do
							if value:IsA("StringValue") and value.Name == "toolanim" and value.Value == "Slash" then
								debounce = true
								coroutine.wrap(function()
									slashing = true
									wait(.25)
									slashing = false
									debounce = false
								end)()
								value:Destroy()
							end
						end
					end
				elseif not object:IsA'Tool' then
					tool = false
				end
			end
			if not humanoid.PlatformStand then
				if humanoid.Sit == true then
					speed = 0.2
					anglespeed = 1/4
					ncf = neckc0 * CFrame.Angles(0, 0, 0)
					rjcf = rootc0
					rscf = rsc0 * CFrame.Angles(math.pi/2+math.sin(-angle)*0.05, 0, 0)
					lscf = lsc0 * CFrame.Angles(math.pi/2+math.sin(-angle)*0.05, 0, 0)
					rlcf = rlc0 * CFrame.Angles(math.pi/2+-math.rad(.2), 0, math.rad(.2))
					llcf = llc0 * CFrame.Angles(math.pi/2+math.rad(.2), 0, -math.rad(.2))
				elseif Vector3.new(torso.Velocity.x, 0, torso.Velocity.z).magnitude <= 2 then
					anglespeed = 1/4
					speed = 0.2
					ncf = neckc0 * CFrame.Angles(math.sin(angle)*0.075, 0, 0)
					rjcf = rootc0
					rscf = rsc0 * CFrame.new(0, math.sin(angle)*0.05, 0) * CFrame.Angles(math.sin(-angle)*0.05, 0, 0)
					lscf = lsc0 * CFrame.new(0, math.sin(angle)*0.05, 0) * CFrame.Angles(math.sin(-angle)*0.05, 0, 0)
					rlcf = rlc0 * CFrame.Angles(-math.rad(.2), 0, math.rad(.2))
					llcf = llc0 * CFrame.Angles(math.rad(.2), 0, -math.rad(.2))
				elseif Vector3.new(torso.Velocity.x, 0, torso.Velocity.z).magnitude <= 20 then
					anglespeed = 1.7
					speed = 0.25
					anglespeed = 2.2
					speed = 0.25
					ncf = neckc0 * CFrame.Angles(0, 0, 0)
					rjcf = rootc0 * CFrame.new(0, math.abs(math.sin(angle))*.055, 0) * CFrame.Angles(-math.rad(1), 0, 0)
					rscf = rsc0 * CFrame.Angles(math.sin(angle)*.5, 0, -math.rad(1))
					lscf = lsc0 * CFrame.Angles(math.sin(-angle)*.5, 0, math.rad(1))
					rlcf = rlc0 * CFrame.new(0, .075 + -math.cos(-angle)*.075, math.sin(angle)*0.1) * CFrame.Angles(math.sin(-angle)*.45, 0, math.rad(.5))
					llcf = llc0 * CFrame.new(0, .075 - -math.cos(angle)*.075, -math.sin(angle)*0.1) * CFrame.Angles(math.sin(angle)*.45, 0, -math.rad(.5))
				elseif Vector3.new(torso.Velocity.x, 0, torso.Velocity.z).magnitude >= 20 then
					local RotVelocityZ = torso.RotVelocity.Y
					if RotVelocityZ >= 15 then
						RotVelocityZ = 15
					elseif RotVelocityZ <= -15 then
						RotVelocityZ = -15
					end
					speed = 0.25
					anglespeed = 2.7
					ncf = neckc0 * CFrame.Angles(0, 0, -math.sin(angle)*.045)
					rscf = rsc0 * CFrame.new(0, 0, -math.sin(angle)*0.125) * CFrame.Angles(math.pi/14+math.sin(angle)*1.5, 0, -math.sin(math.abs(angle))*0.3)
					lscf = lsc0 * CFrame.new(0, 0, math.sin(angle)*0.125) * CFrame.Angles(math.pi/14+math.sin(-angle)*1.5, 0, -math.sin(math.abs(angle))*0.3)
					rjcf = rootc0 * CFrame.new(0, math.abs(math.sin(angle))*.175 - .2, 0) * CFrame.Angles(math.abs(math.sin(angle))*0.055 + -math.pi/18, 0, math.rad(RotVelocityZ) + math.sin(angle)*.045)
					rlcf = rlc0 * CFrame.new(0, .3 + -math.cos(-angle)*.3, -.2+math.sin(angle)*0.25) * CFrame.Angles(-math.pi/18+math.sin(-angle)*1.3, 0, math.rad(.5))
					llcf = llc0 * CFrame.new(0, .3 - -math.cos(angle)*.3, -.05-math.sin(angle)*0.25) * CFrame.Angles(-math.pi/18+math.sin(angle)*1.3, 0, -math.rad(.5))
				end
				if tool then
					rscf = rsc0 * CFrame.Angles(math.pi/2, 0, 0)
					if slashing then
						rscf = rsc0
					end
				end
			end
			if pa2.Parent == nil then
				rm.C0 = clerp(rm.C0,rscf,speed)
			end
			if pa.Parent == nil then
				lm.C0 = clerp(lm.C0,lscf,speed)
			end
			rj.C0 = clerp(rj.C0,rjcf,speed)
			neck.C0 = clerp(neck.C0,ncf,speed)
			rlegm.C0 = clerp(rlegm.C0,rlcf,speed)
			llegm.C0 = clerp(llegm.C0,llcf,speed)
		end)



		game:service'RunService'.RenderStepped:connect(function()
			if Vector3.new(torso.Velocity.x, 0, torso.Velocity.z).magnitude >= 225 then
				TorsoSmoke.Enabled = true
			else
				TorsoSmoke.Enabled = false
			end
			local ray = Ray.new(rootpart.Position, Vector3.new(0, -7, 0))
			local hitz, enz = workspace:FindPartOnRay(ray, char)
			if hitz and hitz.CanCollide and pa.Parent ~= char and pa2.Parent ~= char then
				bodygyro.Parent = nil
				humanoid.PlatformStand = false
			end
			if pa.Parent ~= nil or Grapple1 then
				local size = (ropeStart2.Position-pa.Position).magnitude
				ropePA.Size = Vector3.new(.2, size, .2) 
				ropePA.CFrame = CFrame.new(ropeStart2.Position, pa.Position) * CFrame.Angles(math.pi/2, 0, 0) * CFrame.new(0, -size/2, 0)
				lm.C0 = CFrame.new(Vector3.new(lsc0.x, lsc0.y, lsc0.z), torso.CFrame:pointToObjectSpace(pa.Position)) * CFrame.Angles(math.pi/2, 0, 0)
			else
				if not debounce and humanoid.PlatformStand then
					lm.C0 = lsc0 * CFrame.Angles(-.15, 0, -.15)
				end
			end
			if pa2.Parent ~= nil or Grapple2 then
				local size = (ropeStart.Position-pa2.Position).magnitude
				ropePA2.Size = Vector3.new(.2, size, .2) 
				ropePA2.CFrame = CFrame.new(ropeStart.Position, pa2.Position) * CFrame.Angles(math.pi/2, 0, 0) * CFrame.new(0, -size/2, 0)
				rm.C0 = CFrame.new(Vector3.new(rsc0.x, rsc0.y, rsc0.z), torso.CFrame:pointToObjectSpace(pa2.Position)) * CFrame.Angles(math.pi/2, 0, 0)
			else
				if not debounce and humanoid.PlatformStand then
					rm.C0 = rsc0 * CFrame.Angles(-.15, 0, .15)
				end
			end
			if Grapple1 and Grapple1Hit.Parent == nil then
				pcall(function() Gweld:remove() end)
				pa.Parent = nil
				Grapple1 = false
				ro:Abort()
			end
			if Grapple2 and Grapple2Hit.Parent == nil then
				pcall(function() Gweld2:remove() end)
				pa2.Parent = nil
				Grapple2 = false
				ro2:Abort()
			end
			if Grapple1 and Grapple2 and (humanoid.PlatformStand or not hitz) then
				local distance = (pa.Position-pa2.Position).magnitude
				bodygyro.Parent = torso
				torso.CFrame = CFrame.new(torso.Position, Vector3.new(camera.CoordinateFrame.x, camera.CoordinateFrame.y, camera.CoordinateFrame.z)) * CFrame.Angles(0, math.pi, 0)
				bodygyro.cframe = CFrame.new(torso.Position, Vector3.new(camera.CoordinateFrame.x, camera.CoordinateFrame.y, camera.CoordinateFrame.z)) * CFrame.Angles(0, math.pi, 0)
				pa3.Parent = char
				if distance <= .5 then
					pa3.CFrame = pa.CFrame
				elseif distance > .5 then
					pa3.CFrame = CFrame.new(pa.Position, pa2.Position) * CFrame.new(0, 0, -distance/2)
				end
				if not MidPointUsed then
					ro3=Instance.new("RocketPropulsion",torso3)
					ro3.Name = 'RockatPropoolsun3'
					ro3.MaxSpeed=250
					ro3.MaxThrust=16000
					ro3.TurnP = 0
					ro3.TurnD = 0
					ro3.MaxTorque=Vector3.new(14e16,14e16,14e16)
					if humanoid.PlatformStand or not hitz then
						ro:Abort()
						ro2:Abort()
					end
					ro3.Target = pa3
					if humanoid.PlatformStand or not hitz then
						ro3:Fire()
					end
					MidPointUsed = true
				end
			elseif (not Grapple1 or not Grapple2) and MidPointUsed == true and (humanoid.PlatformStand or not hitz) then
				pa3.Parent = nil
				MidPointUsed = false
				ro3:Abort()
				ro3:Destroy()
				if Grapple1 then
					ro:Fire()
				end
				if Grapple2 then
					ro2:Fire()
				end
			end
			if not Grapple1 then
				pcall(function() Gweld:remove() end)
			end
			if not Grapple2 then
				pcall(function() Gweld2:remove() end)
			end
			if (Grapple1 or Grapple2) and not hitz then
				bodygyro.Parent = torso
				humanoid.PlatformStand = true
				rlegm.Parent = torso
				llegm.Parent = torso
				lm.Parent = torso
				rm.Parent = torso
				rlegm.C0 = rlc0 * CFrame.new(0, .5, -.65) * CFrame.Angles(-math.pi/8, 0, .1)
				llegm.C0 = llc0 * CFrame.new(0, .5, -.65) * CFrame.Angles(-math.pi/8, 0, -.1)
			end
			if (Grapple1 or Grapple2) and not hitz or humanoid.PlatformStand then
				bodygyro.Parent = torso
				bodygyro.cframe = CFrame.new(torso.Position, Vector3.new(camera.CoordinateFrame.x, camera.CoordinateFrame.y, camera.CoordinateFrame.z)) * CFrame.Angles(0, math.pi, 0)
				rlegm.Parent = torso
				llegm.Parent = torso
				rlegm.C0 = rlc0 * CFrame.new(0, .5, -.65) * CFrame.Angles(-math.pi/8, 0, .1)
				llegm.C0 = llc0 * CFrame.new(0, .5, -.65) * CFrame.Angles(-math.pi/8, 0, -.1)
			end
		end)
	end)
end
coroutine.wrap(TMCJUQL_fake_script)()
local function FXQN_fake_script() -- UltraClickers4.LocalScript 
	local script = Instance.new('LocalScript', UltraClickers4)

	UltraClickers4.MouseButton1Down:connect(function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/GhoulScriptsRoblox/Ghoul-Hub---Ultra-Clickers-4-V1-/main/Ultra%20Clickers%204"))()
	end)
end
coroutine.wrap(FXQN_fake_script)()
local function QEGCKCH_fake_script() -- UtgV1.LocalScript 
	local script = Instance.new('LocalScript', UtgV1)

	UtgV1.MouseButton1Down:connect(function()
		loadstring(game:HttpGet("https://pastebin.com/raw/wDh1eTdX"))()
	end)
end
coroutine.wrap(QEGCKCH_fake_script)()
local function KZVYN_fake_script() -- UtgV2.LocalScript 
	local script = Instance.new('LocalScript', UtgV2)

	UtgV2.MouseButton1Down:connect(function()
		-- Gui to Lua
		-- Version: 3.2

		-- Instances:

		local ScreenGui = Instance.new("ScreenGui")
		local Frame = Instance.new("Frame")
		local Name = Instance.new("TextLabel")
		local Credits = Instance.new("TextLabel")
		local Note = Instance.new("TextLabel")
		local TextLabel = Instance.new("TextLabel")
		local ACTIVATE = Instance.new("TextButton")
		local arrow_forward = Instance.new("ImageButton")
		local arrow_back = Instance.new("ImageButton")

		--Properties:

		ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
		ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

		Frame.Parent = ScreenGui
		Frame.BackgroundColor3 = Color3.fromRGB(55, 75, 255)
		Frame.Position = UDim2.new(0.333580971, 0, 0.183551848, 0)
		Frame.Size = UDim2.new(0, 448, 0, 531)

		Name.Name = "Name"
		Name.Parent = Frame
		Name.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Name.Size = UDim2.new(0, 448, 0, 74)
		Name.Font = Enum.Font.SourceSans
		Name.Text = "FE UTG"
		Name.TextColor3 = Color3.fromRGB(0, 0, 0)
		Name.TextScaled = true
		Name.TextSize = 14.000
		Name.TextWrapped = true

		Credits.Name = "Credits"
		Credits.Parent = Frame
		Credits.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Credits.Position = UDim2.new(0, 0, 0.138282403, 0)
		Credits.Size = UDim2.new(0, 448, 0, 57)
		Credits.Font = Enum.Font.SourceSans
		Credits.Text = "Made By KillerMaster"
		Credits.TextColor3 = Color3.fromRGB(0, 0, 0)
		Credits.TextScaled = true
		Credits.TextSize = 14.000
		Credits.TextWrapped = true

		Note.Name = "Note"
		Note.Parent = Frame
		Note.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Note.Position = UDim2.new(0, 0, 0.905838013, 0)
		Note.Size = UDim2.new(0, 448, 0, 50)
		Note.Font = Enum.Font.SourceSans
		Note.Text = "Note: Please reset to close this ui once ur done reading"
		Note.TextColor3 = Color3.fromRGB(0, 0, 0)
		Note.TextScaled = true
		Note.TextSize = 14.000
		Note.TextWrapped = true

		TextLabel.Parent = Frame
		TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		TextLabel.Position = UDim2.new(0, 0, 0.244821087, 0)
		TextLabel.Size = UDim2.new(0, 448, 0, 285)
		TextLabel.Font = Enum.Font.SourceSans
		TextLabel.Text = "NOTE: GUI Not Draggable!"
		TextLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
		TextLabel.TextScaled = true
		TextLabel.TextSize = 14.000
		TextLabel.TextWrapped = true

		ACTIVATE.Name = "ACTIVATE"
		ACTIVATE.Parent = Frame
		ACTIVATE.BackgroundColor3 = Color3.fromRGB(40, 255, 16)
		ACTIVATE.Position = UDim2.new(0.265625, 0, 0.781544268, 0)
		ACTIVATE.Size = UDim2.new(0, 205, 0, 66)
		ACTIVATE.Font = Enum.Font.SciFi
		ACTIVATE.Text = "ACITVATE UTG"
		ACTIVATE.TextColor3 = Color3.fromRGB(0, 0, 0)
		ACTIVATE.TextScaled = true
		ACTIVATE.TextSize = 14.000
		ACTIVATE.TextWrapped = true
		ACTIVATE.MouseButton1Down:connect(function()
			game.Players.LocalPlayer.Character.Humanoid.Health = 0
			loadstring(game:HttpGet("https://pastebin.com/raw/r3Y3PCaz",true))()
		end)

		arrow_forward.Name = "arrow_forward"
		arrow_forward.Parent = Frame
		arrow_forward.BackgroundTransparency = 1.000
		arrow_forward.Position = UDim2.new(-0.00124046206, 0, 0.781766474, 0)
		arrow_forward.Size = UDim2.new(0, 119, 0, 65)
		arrow_forward.ZIndex = 2
		arrow_forward.Image = "rbxassetid://3926307971"
		arrow_forward.ImageRectOffset = Vector2.new(564, 284)
		arrow_forward.ImageRectSize = Vector2.new(36, 36)

		arrow_back.Name = "arrow_back"
		arrow_back.Parent = arrow_forward
		arrow_back.BackgroundTransparency = 1.000
		arrow_back.Position = UDim2.new(2.72268915, 0, 0, 0)
		arrow_back.Size = UDim2.new(0, 123, 0, 65)
		arrow_back.ZIndex = 2
		arrow_back.Image = "rbxassetid://3926307971"
		arrow_back.ImageRectOffset = Vector2.new(124, 324)
		arrow_back.ImageRectSize = Vector2.new(36, 36)
	end)
end
coroutine.wrap(KZVYN_fake_script)()
local function CLTY_fake_script() -- UtgRebirth.LocalScript 
	local script = Instance.new('LocalScript', UtgRebirth)

	UtgRebirth.MouseButton1Down:connect(function()
		local TrollingGuiOpener = Instance.new("ScreenGui")
		local Menu = Instance.new("Frame")
		local Whitelist = Instance.new("TextLabel")
		local Version = Instance.new("TextLabel")
		local Title = Instance.new("TextLabel")
		local Separator = Instance.new("TextButton")
		local RoundedBG = Instance.new("Frame")
		local Corner = Instance.new("ImageLabel")
		local Corner_2 = Instance.new("ImageLabel")
		local Corner_3 = Instance.new("ImageLabel")
		local Corner_4 = Instance.new("ImageLabel")
		local Vertical = Instance.new("Frame")
		local Horizon = Instance.new("Frame")
		local Close = Instance.new("TextButton")
		local UICorner = Instance.new("UICorner")
		local Pages = Instance.new("Frame")
		local Page1 = Instance.new("Frame")
		local ParkourGod = Instance.new("TextButton")
		local UICorner_2 = Instance.new("UICorner")
		local ServerAdmin = Instance.new("TextButton")
		local UICorner_3 = Instance.new("UICorner")
		local slinger = Instance.new("TextButton")
		local UICorner_4 = Instance.new("UICorner")
		local feutgv2 = Instance.new("TextButton")
		local UICorner_5 = Instance.new("UICorner")
		local radio1 = Instance.new("TextButton")
		local UICorner_6 = Instance.new("UICorner")
		local radio2 = Instance.new("TextButton")
		local UICorner_7 = Instance.new("UICorner")
		local SpectrumGlitcher = Instance.new("TextButton")
		local UICorner_8 = Instance.new("UICorner")
		local TypicalHub = Instance.new("TextButton")
		local UICorner_9 = Instance.new("UICorner")
		local GravityPuller = Instance.new("TextButton")
		local UICorner_10 = Instance.new("UICorner")
		local Page = Instance.new("TextButton")
		local UICorner_11 = Instance.new("UICorner")
		local amogus = Instance.new("TextButton")
		local UICorner_12 = Instance.new("UICorner")
		local sexdoll = Instance.new("TextButton")
		local UICorner_13 = Instance.new("UICorner")
		local feutgv1 = Instance.new("TextButton")
		local UICorner_14 = Instance.new("UICorner")
		local PageNumber = Instance.new("TextButton")
		local Page2 = Instance.new("Frame")
		local aspecthub = Instance.new("TextButton")
		local UICorner_15 = Instance.new("UICorner")
		local MORESCRIPTSLATER_8 = Instance.new("TextButton")
		local UICorner_16 = Instance.new("UICorner")
		local MORESCRIPTSLATER_9 = Instance.new("TextButton")
		local UICorner_17 = Instance.new("UICorner")
		local MORESCRIPTSLATER_10 = Instance.new("TextButton")
		local UICorner_18 = Instance.new("UICorner")
		local MORESCRIPTSLATER_11 = Instance.new("TextButton")
		local UICorner_19 = Instance.new("UICorner")
		local MORESCRIPTSLATER_12 = Instance.new("TextButton")
		local UICorner_20 = Instance.new("UICorner")
		local MORESCRIPTSLATER_13 = Instance.new("TextButton")
		local UICorner_21 = Instance.new("UICorner")
		local MORESCRIPTSLATER_14 = Instance.new("TextButton")
		local UICorner_22 = Instance.new("UICorner")
		local MORESCRIPTSLATER_15 = Instance.new("TextButton")
		local UICorner_23 = Instance.new("UICorner")
		local MORESCRIPTSLATER_16 = Instance.new("TextButton")
		local UICorner_24 = Instance.new("UICorner")
		local MORESCRIPTSLATER_17 = Instance.new("TextButton")
		local UICorner_25 = Instance.new("UICorner")
		local MORESCRIPTSLATER_18 = Instance.new("TextButton")
		local UICorner_26 = Instance.new("UICorner")
		local Page_2 = Instance.new("TextButton")
		local UICorner_27 = Instance.new("UICorner")
		local Page_3 = Instance.new("TextButton")
		local UICorner_28 = Instance.new("UICorner")
		local PageNumber_2 = Instance.new("TextButton")
		local CreditBorder = Instance.new("ImageLabel")
		local Check = Instance.new("TextLabel")
		local Credits = Instance.new("TextButton")
		local UICorner_29 = Instance.new("UICorner")
		local CreditStuff = Instance.new("ScrollingFrame")
		local Supr = Instance.new("TextLabel")
		local Supr_2 = Instance.new("TextLabel")
		local Supr_3 = Instance.new("TextLabel")
		local AllotherCreditsgotothescriptcreators = Instance.new("TextLabel")
		local Borders = Instance.new("Frame")
		local Background = Instance.new("Frame")
		local UICorner_30 = Instance.new("UICorner")

		--Properties:

		TrollingGuiOpener.Name = "TrollingGuiOpener"
		TrollingGuiOpener.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
		game:GetService("StarterGui").ResetPlayerGuiOnSpawn = false

		Menu.Name = "Menu"
		Menu.Parent = TrollingGuiOpener
		Menu.Active = true
		Menu.BackgroundColor3 = Color3.fromRGB(255, 255, 235)
		Menu.BackgroundTransparency = 1.000
		Menu.BorderSizePixel = 0
		Menu.Draggable = true
		Menu.Position = UDim2.new(0.50038141, -227, 0.5, -58)
		Menu.Selectable = true
		Menu.Size = UDim2.new(0, 550, 0, 310)
		Menu.ZIndex = 2

		Whitelist.Name = "Whitelist"
		Whitelist.Parent = Menu
		Whitelist.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Whitelist.BackgroundTransparency = 1.000
		Whitelist.BorderSizePixel = 0
		Whitelist.Position = UDim2.new(0.0527272709, 0, 0.825806439, 0)
		Whitelist.Size = UDim2.new(0, 171, 0, 26)
		Whitelist.Font = Enum.Font.SciFi
		Whitelist.Text = "Welcome, {{NAME}}"
		Whitelist.TextColor3 = Color3.fromRGB(255, 255, 255)
		Whitelist.TextSize = 14.000
		Whitelist.TextTransparency = 1.000
		Whitelist.TextXAlignment = Enum.TextXAlignment.Left

		Version.Name = "Version"
		Version.Parent = Menu
		Version.BackgroundColor3 = Color3.fromRGB(16, 148, 163)
		Version.BackgroundTransparency = 1.000
		Version.BorderColor3 = Color3.fromRGB(16, 148, 163)
		Version.Position = UDim2.new(0.319999993, 0, 0.0599999987, 0)
		Version.Size = UDim2.new(0.360000014, 0, 0.119999997, 0)
		Version.ZIndex = 2
		Version.Font = Enum.Font.SourceSansBold
		Version.Text = "Edit By DrKosmitek"
		Version.TextColor3 = Color3.fromRGB(255, 255, 255)
		Version.TextSize = 14.000
		Version.TextStrokeColor3 = Color3.fromRGB(61, 61, 61)
		Version.TextStrokeTransparency = 0.000

		Title.Name = "Title"
		Title.Parent = Menu
		Title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Title.BackgroundTransparency = 1.000
		Title.BorderColor3 = Color3.fromRGB(255, 255, 255)
		Title.Position = UDim2.new(0.304545432, 0, -0.0341935679, 0)
		Title.Size = UDim2.new(0.391818166, 0, 0.130967781, 0)
		Title.ZIndex = 2
		Title.Font = Enum.Font.SciFi
		Title.Text = "UTG Re-Birth"
		Title.TextColor3 = Color3.fromRGB(255, 255, 255)
		Title.TextScaled = true
		Title.TextSize = 14.000
		Title.TextStrokeColor3 = Color3.fromRGB(61, 61, 61)
		Title.TextStrokeTransparency = 0.000
		Title.TextWrapped = true

		Separator.Name = "Separator"
		Separator.Parent = Menu
		Separator.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Separator.BackgroundTransparency = 1.000
		Separator.Position = UDim2.new(0.00363636366, 10, 1.61247313, -280)
		Separator.Size = UDim2.new(0, 526, 0, 19)
		Separator.ZIndex = 7
		Separator.Font = Enum.Font.SourceSansBold
		Separator.Text = ""
		Separator.TextColor3 = Color3.fromRGB(61, 61, 61)
		Separator.TextSize = 18.000
		Separator.TextWrapped = true

		RoundedBG.Name = "RoundedBG"
		RoundedBG.Parent = Separator
		RoundedBG.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		RoundedBG.BackgroundTransparency = 1.000
		RoundedBG.BorderSizePixel = 0
		RoundedBG.Size = UDim2.new(1, 0, 1, 0)

		Corner.Name = "Corner"
		Corner.Parent = RoundedBG
		Corner.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Corner.BackgroundTransparency = 1.000
		Corner.BorderSizePixel = 0
		Corner.Position = UDim2.new(1, -10, 1, -10)
		Corner.Size = UDim2.new(0, 10, 0, 10)
		Corner.ZIndex = 7
		Corner.Image = "rbxassetid://257730458"
		Corner.ImageColor3 = Color3.fromRGB(152, 255, 152)
		Corner.ImageRectOffset = Vector2.new(384, 384)
		Corner.ImageRectSize = Vector2.new(384, 384)

		Corner_2.Name = "Corner"
		Corner_2.Parent = RoundedBG
		Corner_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Corner_2.BackgroundTransparency = 1.000
		Corner_2.BorderSizePixel = 0
		Corner_2.Position = UDim2.new(0, 0, 1, -10)
		Corner_2.Size = UDim2.new(0, 10, 0, 10)
		Corner_2.ZIndex = 7
		Corner_2.Image = "rbxassetid://257730458"
		Corner_2.ImageColor3 = Color3.fromRGB(152, 255, 152)
		Corner_2.ImageRectOffset = Vector2.new(0, 384)
		Corner_2.ImageRectSize = Vector2.new(384, 384)

		Corner_3.Name = "Corner"
		Corner_3.Parent = RoundedBG
		Corner_3.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Corner_3.BackgroundTransparency = 1.000
		Corner_3.BorderSizePixel = 0
		Corner_3.Position = UDim2.new(1, -10, 0, 0)
		Corner_3.Size = UDim2.new(0, 10, 0, 10)
		Corner_3.ZIndex = 7
		Corner_3.Image = "rbxassetid://257730458"
		Corner_3.ImageColor3 = Color3.fromRGB(152, 255, 152)
		Corner_3.ImageRectOffset = Vector2.new(384, 0)
		Corner_3.ImageRectSize = Vector2.new(384, 384)

		Corner_4.Name = "Corner"
		Corner_4.Parent = RoundedBG
		Corner_4.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Corner_4.BackgroundTransparency = 1.000
		Corner_4.BorderSizePixel = 0
		Corner_4.Size = UDim2.new(0, 10, 0, 10)
		Corner_4.ZIndex = 7
		Corner_4.Image = "rbxassetid://257730458"
		Corner_4.ImageColor3 = Color3.fromRGB(152, 255, 152)
		Corner_4.ImageRectSize = Vector2.new(384, 384)

		Vertical.Name = "Vertical"
		Vertical.Parent = RoundedBG
		Vertical.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		Vertical.BorderSizePixel = 0
		Vertical.Position = UDim2.new(0, 10, 0, 0)
		Vertical.Size = UDim2.new(1, -20, 1, 0)
		Vertical.ZIndex = 7

		Horizon.Name = "Horizon"
		Horizon.Parent = RoundedBG
		Horizon.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		Horizon.BorderSizePixel = 0
		Horizon.Position = UDim2.new(0, 0, 0, 10)
		Horizon.Size = UDim2.new(1, 0, 1, -20)
		Horizon.ZIndex = 7

		Close.Name = "Close"
		Close.Parent = Menu
		Close.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		Close.Position = UDim2.new(0.876363695, 10, 0.93225807, -280)
		Close.Size = UDim2.new(0, 44, 0, 32)
		Close.ZIndex = 7
		Close.Font = Enum.Font.SourceSansBold
		Close.Text = "X"
		Close.TextColor3 = Color3.fromRGB(61, 61, 61)
		Close.TextSize = 18.000
		Close.TextWrapped = true
		Close.MouseButton1Click:Connect(function()
			TrollingGuiOpener:Destroy()
		end)

		UICorner.Parent = Close

		Pages.Name = "Pages"
		Pages.Parent = Menu
		Pages.Active = true
		Pages.BackgroundColor3 = Color3.fromRGB(255, 255, 235)
		Pages.BackgroundTransparency = 1.000
		Pages.BorderSizePixel = 0
		Pages.ClipsDescendants = true
		Pages.Position = UDim2.new(0, -2, 0, 2)
		Pages.Selectable = true
		Pages.Size = UDim2.new(1, 0, 1, 0)
		Pages.ZIndex = 2

		Page1.Name = "Page1"
		Page1.Parent = Pages
		Page1.Active = true
		Page1.BackgroundColor3 = Color3.fromRGB(61, 61, 61)
		Page1.BackgroundTransparency = 1.000
		Page1.BorderSizePixel = 0
		Page1.Position = UDim2.new(0, 0, 0.300000012, 0)
		Page1.Size = UDim2.new(1, 0, 0.600000024, 0)

		ParkourGod.Name = "ParkourGod"
		ParkourGod.Parent = Page1
		ParkourGod.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		ParkourGod.Position = UDim2.new(0.501999974, 10, 1.27499998, -280)
		ParkourGod.Size = UDim2.new(0, 110, 0, 48)
		ParkourGod.ZIndex = 7
		ParkourGod.Font = Enum.Font.SourceSansBold
		ParkourGod.Text = "Parkour God"
		ParkourGod.TextColor3 = Color3.fromRGB(61, 61, 61)
		ParkourGod.TextSize = 18.000
		ParkourGod.TextWrapped = true
		ParkourGod.MouseButton1Click:connect(function()
			local player = game:service("Players").LocalPlayer
			local mouse = player:GetMouse()
			local cam = workspace.CurrentCamera
			local char = player.Character
			local Torsoz = char:findFirstChild("Torso")
			local RA = char:findFirstChild("Right Arm")
			local LA = char:findFirstChild("Left Arm")
			local RL = char:findFirstChild("Right Leg")
			local LL = char:findFirstChild("Left Leg")
			local H = char:findFirstChild("Head")
			local Hu = char:findFirstChild("Humanoid")
			local RS = Torsoz:findFirstChild("Right Shoulder")
			local LS = Torsoz:findFirstChild("Left Shoulder")
			local RH = Torsoz:findFirstChild("Right Hip")
			local LH = Torsoz:findFirstChild("Left Hip")
			local N = Torsoz:findFirstChild("Neck")
			local NV = Vector3.new(0,0,0)
			local FOV = 70
			local Shift, Space, Sitting = false,false,false
			local GravPoint = 0
			local Diving = false
			local DivingCooldown = 0
			local DivingDir = NV
			local DivingCF = CFrame.new(0,0,0)
			local DivingBG, DivingBV
			local HWallRunning = false
			local HWRGravDrop = false
			local HWRLastPart
			local HWRCooldown = 0
			local HWRDir
			local VWallRunning = false
			local VWRLastPart
			local VWRCooldown = 0
			local VWRLeft,VWRRight = false,false
			local Sliding = false
			local SlideCooldown = 0
			local Standing = true
			local Action = "Standing"
			local animplus = true
			local animspeed = 0
			local animangle = 0.01
			local Joint1, Joint2, Joint3, Joint4, Joint5

			for i, v in pairs(char:children()) do
				if (v.className == "LocalScript" and v.Name == "ParkourSkrip") or v.className == "NumberValue" or v.className == "BoolValue" or v.className == "Model" or v.Name == "Animate" then
					v:remove()
				end
			end

			local loadids = {112474909, 112474911, 112474909}

			local stamina = 10000
			local maxstamina = 10000
			local defsprint = 28
			local sprint = defsprint  

			local pause = Instance.new("BoolValue", char)
			pause.Name = "Pause"
			pause.Value = false
			local flow = Instance.new("NumberValue", char)
			flow.Name = "Flow"
			flow.Value = 0
			local flowcooldown = 0

			local m = Instance.new("Model", char)
			m.Name = "FlowChainPartz"

			local P = Instance.new("Part")
			P.Name = "TrailPart"
			P.formFactor = "Custom"
			P.Size = Vector3.new(0.2,0.2,0.2)
			P.Locked = true
			P.Anchored = true
			P.CanCollide = false
			P.TopSurface = 0
			P.BottomSurface = 0

			script.Name = "ParkourSkrip"

			local hue = 0

			function HSV(H,S,V)
				H = H % 360
				local C = V * S
				local H2 = H/60
				local X = C * (1 - math.abs((H2 %2) -1))
				local color = Color3.new(0,0,0)
				if H2 <= 0 then
					color = Color3.new(C,0,0)
				elseif 0 <= H2 and H2 <= 1 then
					color = Color3.new(C,X,0)
				elseif 1 <= H2 and H2 <= 2 then
					color = Color3.new(X,C,0)
				elseif 2 <= H2 and H2 <= 3 then
					color = Color3.new(0,C,X)
				elseif 3 <= H2 and H2 <= 4 then
					color = Color3.new(0,X,C)
				elseif 4 <= H2 and H2 <= 5 then
					color = Color3.new(X,0,C)
				elseif 5 <= H2 and H2 <= 6 then
					color = Color3.new(C,0,X)
				end
				local m = V - C
				return Color3.new(color.r + m, color.g + m, color.b + m)
			end

			function GetWeld(weld)
				if weld:findFirstChild("XAngle") == nil then
					local a = Instance.new("NumberValue", weld)
					a.Name = "XAngle"
				end
				if weld:findFirstChild("YAngle") == nil then
					local a = Instance.new("NumberValue", weld)
					a.Name = "YAngle"
				end
				if weld:findFirstChild("ZAngle") == nil then
					local a = Instance.new("NumberValue", weld)
					a.Name = "ZAngle"
				end
				return weld.C0.p, Vector3.new(weld.XAngle.Value, weld.YAngle.Value, weld.ZAngle.Value)
			end

			function SetWeld(weld, i, loops, origpos,origangle, nextpos,nextangle)
				if weld:findFirstChild("XAngle") == nil then
					local a = Instance.new("NumberValue", weld)
					a.Name = "XAngle"
				end
				if weld:findFirstChild("YAngle") == nil then
					local a = Instance.new("NumberValue", weld)
					a.Name = "YAngle"
				end
				if weld:findFirstChild("ZAngle") == nil then
					local a = Instance.new("NumberValue", weld)
					a.Name = "ZAngle"
				end

				local tox,toy,toz = 0,0,0
				if origangle.x > nextangle.x then
					tox = -math.abs(origangle.x - nextangle.x) /loops*i
				else
					tox = math.abs(origangle.x - nextangle.x) /loops*i
				end
				if origangle.y > nextangle.y then
					toy = -math.abs(origangle.y - nextangle.y) /loops*i
				else
					toy = math.abs(origangle.y - nextangle.y) /loops*i
				end
				if origangle.z > nextangle.z then
					toz = -math.abs(origangle.z - nextangle.z) /loops*i
				else
					toz = math.abs(origangle.z - nextangle.z) /loops*i
				end

				local tox2,toy2,toz2 = 0,0,0
				if origpos.x > nextpos.x then
					tox2 = -math.abs(origpos.x - nextpos.x) /loops*i
				else
					tox2 = math.abs(origpos.x - nextpos.x) /loops*i
				end
				if origpos.y > nextpos.y then
					toy2 = -math.abs(origpos.y - nextpos.y) /loops*i
				else
					toy2 = math.abs(origpos.y - nextpos.y) /loops*i
				end
				if origpos.z > nextpos.z then
					toz2 = -math.abs(origpos.z - nextpos.z) /loops*i
				else
					toz2 = math.abs(origpos.z - nextpos.z) /loops*i
				end

				weld.XAngle.Value = origangle.x + tox
				weld.YAngle.Value = origangle.y + toy
				weld.ZAngle.Value = origangle.z + toz
				weld.C0 = CFrame.new(origpos.x + tox2,origpos.y + toy2,origpos.z + toz2) * CFrame.Angles(origangle.x + tox,origangle.y + toy,origangle.z + toz)
			end

			function LoadTextures()
				local pls = game:service("ContentProvider")
				for i, v in pairs(loadids) do
					pls:Preload("http://www.roblox.com/asset/?id="..v)
					wait(0.04)
				end
			end
			LoadTextures()

			function CreateGui()
				for i, v in pairs(player.PlayerGui:children()) do
					if v.className == "ScreenGui" and v.Name == "staminaGui" then
						v:remove()
					end
				end
				local g = Instance.new("ScreenGui", player.PlayerGui)
				g.Name = "staminaGui"

				local c = Instance.new("Frame", g)
				c.Visible = false
				c.Size = UDim2.new(0,86,0,320)
				c.BackgroundTransparency = 1
				c.Position = UDim2.new(1,-96,0.5,-160)
				c.Name = "Container"

				local t = Instance.new("TextLabel", c)
				t.Size = UDim2.new(0,0,-0.1,0)
				t.Position = UDim2.new(0.3,0,0.5,0)
				t.TextXAlignment = "Right"
				t.Font = "ArialBold"
				t.TextTransparency = 0.1
				t.TextColor3 = Color3.new(0,0.6,0.8)
				t.TextStrokeColor3 = Color3.new(0,0.2,0.8)
				t.TextStrokeTransparency = 0.3
				t.FontSize = 6
				t.BackgroundTransparency = 1
				local t2 = t:Clone()
				t2.Parent = c
				t2.Size = UDim2.new(0,0,0.1,0)
				local l = t:Clone()
				l.Parent = c
				l.Size = UDim2.new(0,0,0,0)
				l.Text = "-----"

				local f1 = Instance.new("Frame", c)
				f1.Name = "Backing"
				f1.ClipsDescendants = true
				f1.Size = UDim2.new(1,0,0,0)
				f1.BackgroundColor3 = Color3.new(0.8,0,0)
				f1.BackgroundTransparency = 1
				local f1img = Instance.new("ImageLabel", f1)
				f1img.BackgroundTransparency = 1
				f1img.Image = "http://www.roblox.com/asset/?id=112474909"
				f1img.Size = UDim2.new(1,0,0,c.Size.Y.Offset)

				local f2 = Instance.new("Frame", c)
				f2.Name = "Overlay"
				f2.ClipsDescendants = true
				f2.Size = UDim2.new(1,0,1,0)
				f2.BackgroundColor3 = Color3.new(0,0,0.8)
				f2.BackgroundTransparency = 1
				local f2img = Instance.new("ImageLabel", f2)
				f2img.BackgroundTransparency = 1
				f2img.Image = "http://www.roblox.com/asset/?id=112474911"
				f2img.Size = UDim2.new(1,0,0,c.Size.Y.Offset)

				function Calculate()
					local ysize = c.Size.Y.Offset
					local per = (stamina/maxstamina) * c.Size.Y.Offset
					local rem = (-(stamina/maxstamina-1)) * c.Size.Y.Offset
					f1.Size = UDim2.new(1,0,0,rem)
					f2.Size = UDim2.new(1,0,0,per)
					f2.Position = UDim2.new(0,0,0,rem)
					f2img.Position = UDim2.new(0,0,0,-rem)
					t.Text = math.floor(stamina)
					t2.Text = maxstamina
				end
				Calculate()

				wait(0.01)
				c.Visible = true
			end
			CreateGui()

			player.CharacterAdded:connect(function()
				char = player.Character
				Torsoz = char:findFirstChild("Torso")
				RA = char:findFirstChild("Right Arm")
				LA = char:findFirstChild("Left Arm")
				RL = char:findFirstChild("Right Leg")
				LL = char:findFirstChild("Left Leg")
				H = char:findFirstChild("Head")
				Hu = char:findFirstChild("Humanoid")
				RS = Torsoz:findFirstChild("Right Shoulder")
				LS = Torsoz:findFirstChild("Left Shoulder")
				RH = Torsoz:findFirstChild("Right Hip")
				LH = Torsoz:findFirstChild("Left Hip")
				N = Torsoz:findFirstChild("Neck")
				stamina = maxstamina
				CreateGui()
			end)

			function RAY(pos, dir, startpos, endpos, distleft, collidedlist)
				collidedlist = collidedlist or {char}
				startpos = startpos or pos
				distleft = distleft or dir.unit * dir.magnitude
				endpos = endpos or pos + distleft
				local ray = Ray.new(pos, distleft)
				local hitz,enz = workspace:FindPartOnRayWithIgnoreList(ray, collidedlist)
--[[
local p = P:Clone()
p.Parent = char
p.Size = Vector3.new(0.4,0.4,0.4)
p.BrickColor = BrickColor.new("Lime green")
p.CanCollide = false
p.CFrame = CFrame.new(enz)
p.Transparency = 0.3
]]
				if hitz ~= nil then
					if hitz.CanCollide == false then
						table.insert(collidedlist, hitz)
						local newpos = enz
						local newdistleft = distleft - (dir.unit * (pos - newpos).magnitude)
						if newdistleft ~= NV then
							return RAY(newpos-(dir*0.01), dir, startpos, endpos, newdistleft+(dir*0.01), collidedlist)
						end
					end
				end

				return hitz, enz, ray
			end

			function Sit()
				Standing = false
				local hitz,enz = RAY(Torsoz.Position, Vector3.new(0,-4.1,0))
				local tordir = Vector3.new(Torsoz.CFrame.lookVector.x,0,Torsoz.CFrame.lookVector.z)
				if (hitz ~= nil and hitz.CanCollide == true) then
					local cf = CFrame.new(enz+Vector3.new(0,1.28,0), enz+Vector3.new(0,1.28,0)+tordir) * CFrame.Angles(math.pi/6,0,0)
					local hitz2,enz2 = RAY(enz+Vector3.new(0,2.25,0), tordir*-2.2)
					Hu.PlatformStand = true
					Torsoz.CFrame = cf
					local bp = Instance.new("BodyPosition", Torsoz)
					bp.Name = "StaminaBodyObject"
					bp.maxForce = Vector3.new(1/0,1/0,1/0)
					bp.D = 100
					bp.position = cf.p
					local bg = Instance.new("BodyGyro", Torsoz)
					bg.Name = "StaminaBodyObject"
					bg.maxTorque = Vector3.new(1/0,1/0,1/0)
					bg.cframe = cf
					bg.D = 100
					SetWeld(Joint1,1,1, NV,NV, Vector3.new(0.34,-1,0.2), Vector3.new((math.pi/2)-(math.pi/6),0,math.pi/8))
					SetWeld(Joint2,1,1, NV,NV, Vector3.new(-0.34,-1,0.2), Vector3.new((math.pi/2)-(math.pi/6),0,-math.pi/8))

					if hitz2 ~= nil and hitz2.CanCollide == true then
						Joint3.C0 = CFrame.new(0.9,0.4,-0.45) * CFrame.Angles(0,math.pi/2.13,0) * CFrame.Angles(math.pi/2.3,0,0)
						Joint4.C0 = CFrame.new(-0.9,0.4,-0.4) * CFrame.Angles(0,-math.pi/2.05,0) * CFrame.Angles(math.pi/2.3,0,0)
						Joint5.C0 = CFrame.new(0,1,0) * CFrame.Angles(-math.pi/8.8,0,0)
					else
						SetWeld(Joint3,1,1, NV,NV, Vector3.new(1.4,0.4,0.1), Vector3.new(-(math.pi/6)-(math.pi/10),0,math.pi/9))
						SetWeld(Joint4,1,1, NV,NV, Vector3.new(-1.4,0.4,0.1), Vector3.new(-(math.pi/6)-(math.pi/10),0,-math.pi/9))
						SetWeld(Joint5,1,1, NV,NV, Vector3.new(0,1,0), Vector3.new(-math.pi/12,0,0))
					end

					Sitting = true
					Action = "Sitting"
				end
			end


			function Stand()
				Hu.PlatformStand = false
				if Sitting == true then
					local tordir = Torsoz.Position + (Torsoz.CFrame.lookVector*10000)
					local cf = CFrame.new(Torsoz.Position + Vector3.new(0,1.8,0), Vector3.new(tordir.x,Torsoz.Position.y,tordir.z))
					Torsoz.CFrame = cf
				end
				for i, v in pairs(Torsoz:children()) do
					if v.Name == "StaminaBodyObject" then
						v:remove()
					end
				end
				RH.Part0 = nil
				LH.Part0 = nil
				RS.Part0 = nil
				LS.Part0 = nil
				Joint1.Part0 = Torsoz
				Joint1.Part1 = RL
				Joint1.C0 = CFrame.new(0.5,-1,0)
				Joint1.C1 = CFrame.new(0,1,0)
				Joint2.Part0 = Torsoz
				Joint2.Part1 = LL
				Joint2.C0 = CFrame.new(-0.5,-1,0)
				Joint2.C1 = CFrame.new(0,1,0)
				Joint3.Part0 = Torsoz
				Joint3.Part1 = RA
				Joint3.C0 = CFrame.new(1.5,0.5,0)
				Joint3.C1 = CFrame.new(0,0.5,0)
				Joint4.Part0 = Torsoz
				Joint4.Part1 = LA
				Joint4.C0 = CFrame.new(-1.5,0.5,0)
				Joint4.C1 = CFrame.new(0,0.5,0)
				Joint5.Part0 = Torsoz
				Joint5.Part1 = H
				Joint5.C0 = CFrame.new(0,1,0)
				Joint5.C1 = CFrame.new(0,-0.5,0)
				Sitting = false
				Diving = false
				Standing = true
				Action = "Standing"
			end

			--------------------------------------- Dive ----------------------------------

			function Dive()
				stamina = stamina - 10
				flow.Value = flow.Value + 10
				if flow.Value > 100 then
					flow.Value = 100
				end
				Standing = false
				local dir = Vector3.new(Torsoz.CFrame.lookVector.x,0,Torsoz.CFrame.lookVector.z)
				GravPoint = 18
				DivingDir = dir
				local cf = CFrame.new(Torsoz.Position, dir+Vector3.new(0,Torsoz.Position.y,0))
				DivingCF = cf
				DivingDir = dir
				Hu.PlatformStand = true
				local bv = Instance.new("BodyVelocity", Torsoz)
				bv.Name = "StaminaBodyObject"
				bv.maxForce = Vector3.new(1/0,1/0,1/0)
				bv.velocity = Vector3.new(DivingDir.x*24,GravPoint,DivingDir.z*24)
				DivingBV = bv
				local bg = Instance.new("BodyGyro", Torsoz)
				bg.Name = "StaminaBodyObject"
				bg.maxTorque = Vector3.new(1/0,1/0,1/0)
				bg.cframe = CFrame.new(Torsoz.Position, Torsoz.Position+bv.velocity) * CFrame.Angles(-math.pi/2,0,0)
				bg.D = 100
				DivingBG = bg

				local joint = Joint3
				joint.C1 = CFrame.new(0,0.5,0)
				local joint2 = Joint4
				joint2.C1 = CFrame.new(0,0.5,0)
				local joint3 = Joint1
				joint3.C1 = CFrame.new(0,1,0)
				local joint4 = Joint2
				joint4.C1 = CFrame.new(0,1,0)

				local joint5 = Joint5

				Diving = true
				Action = "Diving"

				for i = 1, 8 do
					SetWeld(joint,i,8, Vector3.new(1.5,0.5,0), NV, Vector3.new(1.45,0.5,0.1), Vector3.new(-0.2,-math.pi/9,math.pi/13))
					SetWeld(joint2,i,8, Vector3.new(-1.5,0.5,0), NV, Vector3.new(-1.45,0.5,0.1), Vector3.new(-0.2,math.pi/9,-math.pi/13))
					SetWeld(joint3,i,8, Vector3.new(0.5,-1,0), NV, Vector3.new(0.5,-1,0.03), Vector3.new(-0.2,-math.pi/10,math.pi/14))
					SetWeld(joint4,i,8, Vector3.new(-0.5,-1,0), NV, Vector3.new(-0.5,-1,0.03), Vector3.new(-0.2,math.pi/10,-math.pi/14))
					SetWeld(joint5,i,8, Vector3.new(0,1,0), NV, Vector3.new(0,1,0), Vector3.new(0.45,0,0))
					wait(0.025)
				end

				local counter = 0
				while Diving == true do
					counter = counter + 1
					bg.Parent = Torsoz
					local hitz, enz = RAY(Torsoz.Position, bv.velocity.unit*4.6)
					if hitz ~= nil and hitz.CanCollide == true then
						local hitz2, enz2 = RAY(Torsoz.Position, Vector3.new(0,-4,0))
						if hitz2 ~= nil then
							Diving = "Rolling"
							Action = "DiveRolling"
						else
							Torsoz.CFrame = Torsoz.CFrame * CFrame.new(0,-0.3,0)
							Torsoz.Velocity = NV
							flow.Value = 0
							break
						end
					end
					if counter > 190 then
						break
					end
					wait(0.02)
				end

				bv.velocity = (dir*20) + Vector3.new(0,-0.5,0)

				local bgcf = bg.cframe
				local haslanded = false
				local count = 0

				while haslanded == false do
					bg.cframe = bgcf * CFrame.Angles(-0.3*count,0,0)
					local hitz, enz = RAY(Torsoz.Position, ((Torsoz.CFrame*CFrame.new(0,-1,0)).p - Torsoz.CFrame.p).unit*1.6)
					if hitz ~= nil and hitz.CanCollide == true then
						haslanded = true
					end
					local hitz2, enz2 = RAY(Torsoz.Position, Vector3.new(0,-3.8,0))
					if hitz2 == nil then
						Torsoz.Velocity = NV
						break
					elseif haslanded == true then
						local bp = Instance.new("BodyPosition", Torsoz)
						bp.Name = "StaminaJumpFix"
						bp.maxForce = Vector3.new(0,1/0,0)
						bp.P = 7000
						bp.position = enz2 + Vector3.new(0,2.8,0)
						game:service("Debris"):AddItem(bp, 0.3)
					else
						bv.velocity = (dir*20) + Vector3.new(0,-(Torsoz.Position - enz2).magnitude*3,0)

					end
					count = count + 1
					if count <= 6 then
						local i = count
						local j1,j1a = GetWeld(joint)
						local j2,j2a = GetWeld(joint2)
						local j3,j3a = GetWeld(joint3)
						local j4,j4a = GetWeld(joint4)
						local j5,j5a = GetWeld(joint5)
						SetWeld(joint,i,6, j1,j1a, Vector3.new(1.35,0.5,-0.2), Vector3.new(math.pi/2.6,0,-math.pi/5.8))
						SetWeld(joint2,i,6, j2,j2a, Vector3.new(-1.35,0.5,-0.2), Vector3.new(math.pi/2.6,0,math.pi/5.8))
						SetWeld(joint3,i,6, j3,j3a, Vector3.new(0.51,0.4,-0.6), Vector3.new(-0.1,0,0.05))
						SetWeld(joint4,i,6, j4,j4a, Vector3.new(-0.51,0.4,-0.6), Vector3.new(-0.1,0,-0.05))
						SetWeld(joint5,i,6, j5,j5a, Vector3.new(0,1,0), Vector3.new(-0.4,0,0))
					elseif count >= 50 then
						break
					end
					wait(0.02)
				end

				Torsoz.Velocity = NV

				Stand()
				DivingCooldown = 9
			end

			function FindSurface(part, position)
				local obj = part.CFrame:pointToObjectSpace(position)
				local siz = part.Size/2
				for i,v in pairs(Enum.NormalId:GetEnumItems()) do
					local vec = Vector3.FromNormalId(v)
					local wvec = part.CFrame:vectorToWorldSpace(vec)
					local vz = (obj)/(siz*vec)
					if (math.abs(vz.X-1) < 0.01 or math.abs(vz.Y-1) < 0.01 or math.abs(vz.Z-1) < 0.01) then
						return wvec,vec
					end
				end
				if part.className == "WedgePart" then
					return part.CFrame:vectorToWorldSpace(Vector3.new(0,0.707,-0.707)), Vector3.new(0,0.707,-0.707)
				end
			end

			function HWallRun(part, pos, side)
				if (part.className == "Part" and part.Shape == Enum.PartType.Block) or part.className ~= "Part" then
					flow.Value = flow.Value + 9
					Standing = false
					HWallRunning = true
					Action = "HWallRunning"
					GravPoint = 10
					HWRLastPart = part
					local dir, dirc = FindSurface(part, pos)
					towall = -dir
					dir = (CFrame.new(NV, dir) * CFrame.Angles(0,side,0)).lookVector

					local bv = Instance.new("BodyVelocity", Torsoz)
					bv.Name = "StaminaBodyObject"
					bv.maxForce = Vector3.new(1/0,1/0,1/0)
					bv.P = 9000
					bv.velocity = (dir*(sprint-0.5)) + Vector3.new(0,GravPoint,0)
					local bg = Instance.new("BodyGyro", Torsoz)
					bg.Name = "StaminaBodyObject"
					bg.maxTorque = Vector3.new(1/0,1/0,1/0)
					bg.cframe = CFrame.new(Torsoz.Position+(towall*-2), Torsoz.Position) * CFrame.Angles(0,-side,-side/4.2)
					bg.D = 100

					local sid = Instance.new("Snap")

					local joint1 = Joint3
					if side == -math.pi/2 then
						SetWeld(joint1,1,1, NV,NV, Vector3.new(1.5,0.5,0), Vector3.new(math.pi/1.3,0.1,math.pi/2.5))
					else
						sid = joint1
						SetWeld(joint1,1,1, NV,NV, Vector3.new(1.4,0.6,0), Vector3.new(-math.pi/12,0,math.pi/7))
					end
					local j1c0 = joint1.C0

					local joint2 = Joint4
					if side == math.pi/2 then
						SetWeld(joint2,1,1, NV,NV, Vector3.new(-1.5,0.5,0), Vector3.new(math.pi/1.3,-0.1,-math.pi/2.5))
					else
						sid = joint2
						SetWeld(joint2,1,1, NV,NV, Vector3.new(-1.4,0.6,0), Vector3.new(-math.pi/12,0,-math.pi/7))
					end
					local j2c0 = joint2.C0

					local joint3 = Joint1
					joint3.C1 = CFrame.new(0,1,0)
					if side == -math.pi/2 then
						SetWeld(joint3,1,1, NV,NV, Vector3.new(0.5,-0.38,-0.3), Vector3.new(0,math.pi/2,0.14))
					else
						SetWeld(joint3,1,1, NV,NV, Vector3.new(0.5,-0.8,-0.2), Vector3.new(0,math.pi/2,0.2))
					end

					local joint4 = Joint2
					joint4.C1 = CFrame.new(0,1,0)
					if side == -math.pi/2 then
						SetWeld(joint4,1,1, NV,NV, Vector3.new(-0.5,-0.8,-0.2), Vector3.new(0,0,0.2))
					else
						SetWeld(joint4,1,1, NV,NV, Vector3.new(-0.5,-0.38,-0.3), Vector3.new(0,0,0.14))
					end

					local joint5 = Joint5
					SetWeld(joint5,1,1,NV,NV,Vector3.new(0,0.9,0),Vector3.new(0,0,side/7))

					Torsoz.CFrame = CFrame.new(pos+(towall*-2), pos) * CFrame.Angles(0,-side,-side/2.2)
					bg.cframe = CFrame.new(pos+(towall*-2), pos) * CFrame.Angles(0,-side,-side/2.2)

					local aniangle = 0
					local aniplus = true
					local aniangle2 = 0
					local aniplus2 = true

					local prevpart = part
					HWRLastPart = part
					while HWallRunning == true do

						if aniangle > math.pi then
							aniplus = false
						elseif aniangle < -math.pi then
							aniplus = true  
						end
						if aniplus == true then
							aniangle = aniangle + 0.95
						elseif aniplus == false then
							aniangle = aniangle - 0.95
						end

						if aniangle2 > math.pi then
							aniplus2 = false
						elseif aniangle2 < -math.pi then
							aniplus2 = true  
						end
						if aniplus2 == true then
							aniangle2 = aniangle2 + 0.23
						elseif aniplus2 == false then
							aniangle2 = aniangle2 - 0.23
						end

						Hu.PlatformStand = true
						local hitz, enz = RAY(Torsoz.Position, Vector3.new(0,-3,0))
						local hitz2, enz2 = RAY(Torsoz.Position, towall*3.4)

						--- if player ends wall run on ground
						if hitz ~= nil and hitz.CanCollide == true then
							bg.cframe = CFrame.new(enz2+(towall*-2), enz2) * CFrame.Angles(0,-side,0)
							local offset = (bg.cframe.p.y+enz2.y) - bg.cframe.p.y
							Torsoz.CFrame = CFrame.new(Vector3.new(bg.cframe.p.x,offset,bg.cframe.p.z), enz2) * CFrame.Angles(0,-side,0)
							Torsoz.Velocity = NV
							break
						end

						---- if new wall found --------
						if hitz2 ~= nil and hitz2.CanCollide == true then
							if hitz2 ~= prevpart then
								local direct = CFrame.new(Torsoz.Position, Torsoz.Position+dir) * CFrame.Angles(0,side,0)
								local hitz3, enz3 = RAY(Torsoz.Position, (direct * CFrame.Angles(0,-side/2.3,0)).lookVector*4)
								if hitz3 ~= nil then
									Torsoz.CFrame = CFrame.new(enz2+(towall*-2), enz2) * CFrame.Angles(0,-side*1.1,-side/2.2)
									bg.cframe = CFrame.new(enz2+(towall*-2), enz2) * CFrame.Angles(0,-side*1.1,-side/2.2)
									dir, dirc = FindSurface(hitz2, enz2)
									towall = -dir
									dir = (CFrame.new(NV, dir) * CFrame.Angles(0,side,0)).lookVector
									prevpart = hitz2
									HWRLastPart = hitz2
								else
									---- if player fails to find new wall to run on
									Torsoz.CFrame = CFrame.new(Torsoz.Position, Torsoz.Position+dir)
									bg.cframe = CFrame.new(Torsoz.Position, Torsoz.Position+dir)
									Torsoz.Velocity = NV
									HWRCooldown = 5
									break
								end
							end
							--- continue to wall run
							Torsoz.CFrame = CFrame.new(enz2+(towall*-2), enz2) * CFrame.Angles(0,-side,-side/2.2)
							bg.cframe = CFrame.new(enz2+(towall*-2), enz2) * CFrame.Angles(0,-side,-side/2.2)
						else
							---- if player ends wall run at end of wall
							Torsoz.CFrame = CFrame.new(Torsoz.Position, Torsoz.Position+dir)
							bg.cframe = CFrame.new(Torsoz.Position, Torsoz.Position+dir)
							Torsoz.Velocity = NV
							HWRCooldown = 5
							break
						end

						local hitz3, enz3 = RAY(Torsoz.Position, Torsoz.CFrame.lookVector*2)
						if hitz3 ~= nil and hitz3.CanCollide == true then
							Torsoz.CFrame = CFrame.new(Torsoz.Position, Torsoz.Position+dir)
							bg.cframe = CFrame.new(Torsoz.Position, Torsoz.Position+dir)
							Torsoz.Velocity = NV
							HWRCooldown = 5
							break
						end

						bv.Parent = Torsoz
						bv.velocity = (dir*(sprint-0.5)) + Vector3.new(0,GravPoint,0)
						bg.cframe = bg.cframe * CFrame.Angles(aniangle/80,aniangle/80,0)
						Torsoz.CFrame = Torsoz.CFrame * CFrame.Angles(aniangle/80,aniangle/80,0)
						local j3,j3a = GetWeld(joint3)
						local j4,j4a = GetWeld(joint4)
						SetWeld(joint3,1,1, j3,j3a, j3,Vector3.new(-0.2+(aniangle/4),0,0))
						SetWeld(joint4,1,1, j4,j4a, j4,Vector3.new(-0.2+(-aniangle/4),0,0))
						if side == math.pi/2 then
							local j1,j1a = GetWeld(joint1)
							SetWeld(joint1,1,1, j1,j1a, j1, Vector3.new(0,0,0.8+(aniangle2/14)))
						else
							local j2,j2a = GetWeld(joint2)
							SetWeld(joint2,1,1, j2,j2a, j2, Vector3.new(0,0,-0.8-(aniangle2/14)))
						end

						wait(0.025)
						if GravPoint < -100 then
							bg.cframe = CFrame.new(enz2+(towall*-2), enz2) * CFrame.Angles(0,-side,0)
							local offset = math.abs((bg.cframe.p.y+enz2.y) - bg.cframe.p.y)
							Torsoz.CFrame = CFrame.new(Vector3.new(bg.cframe.p.x,offset,bg.cframe.p.z), enz2) * CFrame.Angles(0,-side,0)
							break
						end

					end

					if HWallRunning == "Jumping" then
						HWRCooldown = 6
						joint1.C1 = CFrame.new(0,0.5,0)

						joint2.C1 = CFrame.new(0,0.5,0)
						if side == -math.pi/2 then
							joint2.C0 = CFrame.new(-1.35,0.5,0) * CFrame.Angles(0,side/2.4,-math.pi/3)
						else
							joint2.C0 = CFrame.new(-1.35,0.5,0) * CFrame.Angles(0,side/2.4,-math.pi/4)
						end

						joint3.C1 = CFrame.new(0,1,0)
						if side == -math.pi/2 then
							joint3.C0 = CFrame.new(0.5,-0.8,0) * CFrame.Angles(0,math.pi+(side/2.4),-math.pi/4)
						else
							joint3.C0 = CFrame.new(0.5,-0.8,0) * CFrame.Angles(0,(side/2.4),math.pi/4)
						end
						joint4.MaxVelocity = 10
						joint4.DesiredAngle = 0
						joint4.C1 = CFrame.new(0,1,0)
						if side == -math.pi/2 then
							joint4.C0 = CFrame.new(-0.5,-0.8,0) * CFrame.Angles(0,math.pi+(side/2.4),math.pi/4)
						else
							joint4.C0 = CFrame.new(-0.5,-0.8,0) * CFrame.Angles(0,(side/2.4),-math.pi/4)
						end

						local joint5 = Joint5
						joint5.C1 = CFrame.new(0,-0.5,0) * CFrame.Angles(0,side/2.4,0)
						joint5.C0 = CFrame.new(0,1,0)

						local j1,j1a = GetWeld(joint1)
						local j2,j2a = GetWeld(joint2)
						local j3,j3a = GetWeld(joint3)
						local j4,j4a = GetWeld(joint4)
						local j5,j5a = GetWeld(joint5)

						GravPoint = 26
						local collidecount = 0
						local bgangle = side/2
						local count = 1
						local dir2 = (CFrame.new(NV, dir) * CFrame.Angles(0,-side/2.4,0)).lookVector
						HWRDir = dir2
						bv.velocity = (dir2*(sprint+5)) + Vector3.new(0,GravPoint,0)
						while HWallRunning == "Jumping" do
							local hitz, enz = RAY(Torsoz.Position, Vector3.new(0,-4,0))
							local hitz2, enz2 = RAY(Torsoz.Position, dir2*1.4)
							if hitz ~= nil and hitz.CanCollide == true then
								local offset = math.abs(enz.y - Torsoz.CFrame.p.y)
								Torsoz.CFrame = CFrame.new(enz+Vector3.new(0,2.9,0), enz+Vector3.new(0,2.9,0)+dir2)
								Torsoz.Velocity = NV
								break
							end

							if hitz2 ~= nil and hitz2.CanCollide == true then
								collidecount = collidecount + 1
								if collidecount == 4 then
									Torsoz.CFrame = CFrame.new(Torsoz.Position, Torsoz.Position+dir2) * CFrame.new(0,0,0.4)
									Torsoz.Velocity = Vector3.new(0,Torsoz.Velocity.y,0)
									HWRCooldown = 5
									VWRCooldown = 5
									wait(0.02)
									break
								end
							end

							if side/2 > 0 then
								if bgangle > 0.2 then
									bgangle = bgangle - 0.055
								end
							else
								if bgangle < -0.2 then
									bgangle = bgangle + 0.055
								end
							end

							if count <= 5 then
								if side == -math.pi/2 then
									SetWeld(joint1,count,5, j1,j1a, Vector3.new(1.35,0.5,0), Vector3.new(0,side/2.4,math.pi/4))
									SetWeld(joint2,count,5, j2,j2a, Vector3.new(-1.35,0.5,0), Vector3.new(0,side/2.4,-math.pi/3))
									SetWeld(joint3,count,5, j3,j3a, Vector3.new(0.5,-0.8,0), Vector3.new(0,-side/1.7,0))
									joint3.C0 = joint3.C0 * CFrame.Angles((-math.pi/4)/5*count,0,0)
									SetWeld(joint4,count,5, j4,j4a, Vector3.new(-0.5,-0.8,0), Vector3.new(0,-side/1.7,0))
									joint4.C0 = joint4.C0 * CFrame.Angles((math.pi/4)/5*count,0,0)
								else
									SetWeld(joint1,count,5, j1,j1a, Vector3.new(1.35,0.5,0), Vector3.new(0,side/2.4,math.pi/3))
									SetWeld(joint2,count,5, j2,j2a, Vector3.new(-1.35,0.5,0), Vector3.new(0,side/2.4,-math.pi/4))
									SetWeld(joint3,count,5, j3,j3a, Vector3.new(0.5,-0.8,0), Vector3.new(0,-side/1.7,0))
									joint3.C0 = joint3.C0 * CFrame.Angles((math.pi/4)/5*count,0,0)
									SetWeld(joint4,count,5, j4,j4a, Vector3.new(-0.5,-0.8,0), Vector3.new(0,-side/1.7,0))
									joint4.C0 = joint4.C0 * CFrame.Angles((-math.pi/4)/5*count,0,0)
								end

								count = count + 1
							end

							bg.Parent = Torsoz
							bg.cframe = CFrame.new(NV, dir) * CFrame.Angles(0,side/15,-bgangle)
							bv.velocity = (dir2*(sprint+5)) + Vector3.new(0,GravPoint,0)
							if collidecount ~= 0 then
								bv.velocity = Vector3.new(0,bv.velocity.y,0)
							end
							if GravPoint < -120 then
								break
							end
							wait(0.025)
						end
					end

					Hu.PlatformStand = false
					bv:remove()

					HWRGravDrop = false
					Stand()
					HWallRunning = false
				end
			end

			function VWR(part, pos)
				if (part.className == "Part" and part.Shape == Enum.PartType.Block) or part.className ~= "Part" then
					print("VWR Activated")
					flow.Value = flow.Value + 9
					Standing = false
					VWallRunning = true
					Action = "VWallRunning"
					GravPoint = 0
					local percent = 1
					VWRLastPart = part
					local dir, dirc = FindSurface(part, pos)
					towall = -dir
					dir = (CFrame.new(NV, -dir) * CFrame.Angles(math.pi/2,0,0)).lookVector
--[[
local p = P:Clone()
p.Parent = char
p.Size = Vector3.new(2,2,2)
p.BrickColor = BrickColor.new("Lime green")
p.CanCollide = false
p.CFrame = part.CFrame * CFrame.new(dirc*5)
p.Transparency = 0.3
]]
					local bv = Instance.new("BodyVelocity", Torsoz)
					bv.Name = "StaminaBodyObject"
					bv.maxForce = Vector3.new(1/0,1/0,1/0)
					bv.P = 9000
					bv.velocity = (dir*(sprint-1))*percent

					local bg = Instance.new("BodyGyro", Torsoz)
					bg.Name = "StaminaBodyObject"
					bg.maxTorque = Vector3.new(1/0,1/0,1/0)
					bg.D = 100
					local posi = pos + (-towall*1.8)
					bg.cframe = CFrame.new(posi, posi+towall) * CFrame.Angles((math.pi/5),0,0)
					Torsoz.CFrame = CFrame.new(posi, posi+towall) * CFrame.Angles((math.pi/5),0,0)

					local joint1 = Joint3
					SetWeld(joint1,1,1, NV,NV, Vector3.new(1.4,0.45,-0.1), Vector3.new(-math.pi/3.2,0,math.pi/8))

					local joint2 = Joint4
					SetWeld(joint2,1,1, NV,NV, Vector3.new(-1.4,0.45,-0.1), Vector3.new(-math.pi/3.2,0,-math.pi/8))

					local joint3 = Joint1
					SetWeld(joint3,1,1, NV,NV, Vector3.new(0.48,-0.6,-0.1), Vector3.new(0,math.pi/2,0))
					joint3.C1 = CFrame.new(0,0.7,0.2) * CFrame.Angles(0,math.pi/2,0)

					local joint4 = Joint2
					SetWeld(joint4,1,1, NV,NV, Vector3.new(-0.48,-0.6,-0.1), Vector3.new(0,math.pi/2,0))
					joint4.C1 = CFrame.new(0,0.7,0.2) * CFrame.Angles(0,math.pi/2,0)

					local joint5 = Joint5
					SetWeld(joint5,1,1, NV,NV, Vector3.new(0,1,0), Vector3.new(math.pi/20,0,0))

					local aniangle = 0
					local aniplus = true

					while VWallRunning == true do
						local hitz, enz = RAY(Torsoz.Position, towall*2.1)
						local hitz2, enz2 = RAY(Torsoz.Position, (CFrame.new(NV,towall)*CFrame.Angles(math.pi/2,0,0)).lookVector*2.4)

						if aniangle > math.pi then
							aniplus = false
						elseif aniangle < -math.pi then
							aniplus = true  
						end
						if aniplus == true then
							aniangle = aniangle + (1.3*(percent+0.2))
						elseif aniplus == false then
							aniangle = aniangle - (1.3*(percent+0.2))
						end

						bv.velocity = (dir*(sprint-1))*percent
						if VWRLeft == true then
							bv.velocity = bv.velocity + ((CFrame.new(NV, towall) * CFrame.Angles(0,math.pi/2,0)).lookVector * (11*percent+5))
						end
						if VWRRight == true then
							bv.velocity = bv.velocity - ((CFrame.new(NV, towall) * CFrame.Angles(0,math.pi/2,0)).lookVector * (11*percent+5))
						end

						bg.cframe = CFrame.new(posi, posi+towall) * CFrame.Angles((math.pi/5),0,0) * CFrame.Angles(0,aniangle/60,0)

						SetWeld(joint1,1,1, NV,NV, Vector3.new(1.4,0.45,-0.1), Vector3.new(-math.pi/3.2,aniangle/52,(math.pi/8)+(aniangle/30)))
						SetWeld(joint2,1,1, NV,NV, Vector3.new(-1.4,0.45,-0.1), Vector3.new(-math.pi/3.2,aniangle/52,(-math.pi/8)+(-aniangle/30)))
						SetWeld(joint3,1,1, NV,NV, Vector3.new(0.51,-0.75,-(aniangle/30)), Vector3.new(0,math.pi/2,(aniangle/8)-0.3))
						SetWeld(joint4,1,1, NV,NV, Vector3.new(-0.51,-0.75,(aniangle/30)), Vector3.new(0,math.pi/2,(-aniangle/8)-0.3))

						if hitz == nil then
							local lv = Torsoz.Position + (Torsoz.CFrame.lookVector*100)
							Torsoz.CFrame = CFrame.new(Torsoz.Position, Vector3.new(lv.x,Torsoz.Position.y,lv.z))
							break
						end

						if hitz2 ~= nil then
							percent = 0
							VWallRunning = "Falling"
							Action = "VWRFalling"
							GravPoint = -7
							break
						end

						wait(0.02)
						percent = percent - 0.028
						if percent <= 0.15 then
							VWallRunning = "Falling"
							Action = "VWRFalling"
						end
					end

					-------------------------- Falling from VWR ------------------------------
					if VWallRunning == "Falling" then
						GravPoint = GravPoint - 1
						local dirpos = (-towall *5) + Vector3.new(0,GravPoint,0)
						bv.velocity = CFrame.new(NV, dirpos).lookVector * dirpos.magnitude

						local j1,j1a = GetWeld(joint1)
						local j2,j2a = GetWeld(joint2)
						local j3,j3a = GetWeld(joint3)
						local j4,j4a = GetWeld(joint4)
						local j5,j5a = GetWeld(joint5)

						local counter = 0
						while VWallRunning == "Falling" do
							counter = counter + 1
							local hitz, enz = RAY(H.Position, Vector3.new(0,-2.4,0))

							dirpos = (-towall *5) + Vector3.new(0,GravPoint,0)
							bv.velocity = CFrame.new(NV, dirpos).lookVector * dirpos.magnitude
							if VWRLeft == true then
								bv.velocity = bv.velocity + ((CFrame.new(NV, towall) * CFrame.Angles(0,math.pi/2,0)).lookVector * 9)
							end
							if VWRRight == true then
								bv.velocity = bv.velocity - ((CFrame.new(NV, towall) * CFrame.Angles(0,math.pi/2,0)).lookVector * 9)
							end
							bg.cframe = CFrame.new(NV, (-towall*30) + Vector3.new(0,GravPoint,0)) * CFrame.Angles(-math.pi/2.55,math.pi,0)

							if counter <= 35 then
								SetWeld(joint1,counter,35, j1,j1a, Vector3.new(1.4,0.45,-0.1), Vector3.new(math.pi/9,0,math.pi/9))
								SetWeld(joint2,counter,35, j2,j2a, Vector3.new(-1.4,0.45,-0.1), Vector3.new(math.pi/9,0,-math.pi/9))
								SetWeld(joint3,counter,35, j3,j3a, Vector3.new(0.5,-0.75,0), Vector3.new(0,math.pi/2,math.pi/9))
								joint3.C1 = CFrame.new(0,0.7 + (0.3/35*counter),0.2 - (0.2/35*counter)) * CFrame.Angles(0,math.pi/2,0)
								SetWeld(joint4,counter,35, j4,j4a, Vector3.new(-0.5,-0.75,0), Vector3.new(0,math.pi/2,math.pi/9))
								joint4.C1 = CFrame.new(0,0.7 + (0.3/35*counter),0.2 - (0.2/35*counter)) * CFrame.Angles(0,math.pi/2,0)
								SetWeld(joint5,counter,35, j5,j5a, Vector3.new(0,1,0), Vector3.new(-math.pi/6,0,0))
							end

							if hitz ~= nil then
								bv:remove()
								Torsoz.CFrame = CFrame.new(enz+Vector3.new(0,2,0), (enz+Vector3.new(0,2,0)) + ((-towall*25) + Vector3.new(0,GravPoint,0))) * CFrame.Angles(-math.pi/2.55,math.pi,0)
								Torsoz.Velocity = NV
								Torsoz.RotVelocity = NV
								local bp = Instance.new("BodyPosition", Torsoz)
								bp.maxForce = Vector3.new(1/0,1/0,1/0)
								bp.position = Torsoz.CFrame.p
								game:service("Debris"):AddItem(bp, 0.16)
								flow.Value = 0
								break
							end

							if GravPoint > - 180 then
								GravPoint = GravPoint - 1.9
							end
							if counter > 200 then
								break
							end
							wait(0.02)
						end

						local bp = Instance.new("BodyPosition")

						local counter2 = counter
						local bgangleplus = 0

						local j1,j1a = GetWeld(joint1)
						local j2,j2a = GetWeld(joint2)
						local j3,j3a = GetWeld(joint3)
						local j4,j4a = GetWeld(joint4)
						local j5,j5a = GetWeld(joint5)

						local landingpos

						while VWallRunning == "BackflipFromFall" do
							counter2 = counter2 + 1
							local hitz, enz = RAY(H.Position+Vector3.new(0,2,0), Vector3.new(0,-4.4,0))

							if counter2 - counter < 13 then
								bgangleplus = bgangleplus - ((math.pi*1.1)/13)
							end
							if counter2 - counter <= 13 then
								SetWeld(joint1,counter2-counter,13, j1,j1a, Vector3.new(1.4,0.5,0.1), Vector3.new(math.pi/2,0.1,math.pi/2))
								SetWeld(joint2,counter2-counter,13, j2,j2a, Vector3.new(-1.4,0.5,0.1), Vector3.new(math.pi/2,-0.1,-math.pi/2))
								SetWeld(joint3,counter2-counter,13, j3,j3a, Vector3.new(0.52,-0.3,-0.65), Vector3.new(0,math.pi/2,0))
								SetWeld(joint4,counter2-counter,13, j4,j4a, Vector3.new(-0.51,-0.9,-0.05), Vector3.new(0,math.pi/2,0))
								SetWeld(joint5,counter2-counter,13, j5,j5a, Vector3.new(0,0.9,0), Vector3.new(-math.pi/7,0,0))
							end

							dirpos = (-towall *5) + Vector3.new(0,GravPoint,0)
							--bv.velocity = Vector3.new(0,-2,0)
							bv.velocity = CFrame.new(NV, dirpos).lookVector * dirpos.magnitude
							if VWRLeft == true then
								bv.velocity = bv.velocity + ((CFrame.new(NV, towall) * CFrame.Angles(0,math.pi/2,0)).lookVector * 9)
							end
							if VWRRight == true then
								bv.velocity = bv.velocity - ((CFrame.new(NV, towall) * CFrame.Angles(0,math.pi/2,0)).lookVector * 9)
							end
							bg.cframe = CFrame.new(NV, (-towall*30) + Vector3.new(0,GravPoint,0)) * CFrame.Angles((-math.pi/2.4) + bgangleplus,math.pi,0)

							if hitz ~= nil then
								bv:remove()
								landingpos = enz - (towall*1.3)
								if counter2 - counter > 8 then
									bp = Instance.new("BodyPosition", Torsoz)
									bp.maxForce = Vector3.new(1/0,1/0,1/0)
									bp.position = enz+Vector3.new(0,2.4,0) + (-towall*1)
									VWallRunning = "LandingFall"
								else
									Torsoz.CFrame = bg.cframe + (enz+Vector3.new(0,2.3,0))
									Torsoz.Velocity = NV
									Torsoz.RotVelocity = NV
									local bp = Instance.new("BodyPosition", Torsoz)
									bp.maxForce = Vector3.new(1/0,1/0,1/0)
									bp.position = Torsoz.CFrame.p
									game:service("Debris"):AddItem(bp, 0.14)
									flow.Value = 0
								end
								break
							end

							if GravPoint > - 180 then
								GravPoint = GravPoint - 1.9
							end
							if counter2 > 200 then
								break
							end
							wait(0.02)
						end

						if VWallRunning == "LandingFall" then
							print("Landing")

							joint3.C1 = CFrame.new(0,1,0) * CFrame.Angles(0,math.pi/2,0)
							joint4.C1 = CFrame.new(0,1,0) * CFrame.Angles(0,math.pi/2,0)
							local j1,j1a = GetWeld(joint1)
							local j2,j2a = GetWeld(joint2)
							local j3,j3a = GetWeld(joint3)
							local j4,j4a = GetWeld(joint4)
							local j5,j5a = GetWeld(joint5)

							local a
							local mesh
							if GravPoint < -70 then
								a = P:Clone()
								a.Parent = Torsoz
								a.Name = "AirLandingEffect"
								a.BrickColor = BrickColor.new("Medium stone grey")
								a.Transparency = 0.3
								a.CFrame = CFrame.new(landingpos+Vector3.new(0,0.4,0))
								mesh = Instance.new("SpecialMesh", a)
								mesh.MeshId = "http://www.roblox.com/asset/?id=20329976"
								mesh.Scale = Vector3.new(0,0,0)
							end

							local bgcf = CFrame.new(NV, Vector3.new(towall.x,0,towall.z))
							bg.cframe = bgcf * CFrame.Angles(-math.pi/7,0,0)
							local bgval = math.pi/7/2

							for i = 1, 6 do
								Hu.PlatformStand = true
								SetWeld(joint1,i,6, j1,j1a, Vector3.new(1.2,0.5,0.2), Vector3.new(math.pi/2,0.5,math.pi/1.2))
								SetWeld(joint2,i,6, j2,j2a, Vector3.new(-1.2,0.5,0.2), Vector3.new(math.pi/2,-0.5,-math.pi/1.2))
								SetWeld(joint3,i,6, j3,j3a, Vector3.new(0.51,-0.3,-0.8), Vector3.new(0,math.pi/2,-math.pi/7))
								SetWeld(joint4,i,6, j4,j4a, Vector3.new(-0.51,-0.8,-0.7), Vector3.new(0,math.pi/2,-math.pi/3))
								SetWeld(joint5,i,6, j5,j5a, Vector3.new(0,0.85,0), Vector3.new(-math.pi/8,0,0))
								bp.position = bp.position + Vector3.new(0,-0.07,0)
								bg.cframe = bgcf * CFrame.Angles((-bgval*2) + (bgval/6*i),0,0)
								Torsoz.CFrame = bg.cframe + bp.position
								if a ~= nil then
									mesh.Scale = mesh.Scale + Vector3.new(1.3,0.35,1.3)
									a.Transparency = 0.3 + (0.7/6*i)
								end
								wait(0.02)
							end
							if a ~= nil then
								a:remove()
							end
							local j1,j1a = GetWeld(joint1)
							local j2,j2a = GetWeld(joint2)
							local j3,j3a = GetWeld(joint3)
							local j4,j4a = GetWeld(joint4)
							local j5,j5a = GetWeld(joint5)
							for i = 1, 6 do
								Hu.PlatformStand = true
								SetWeld(joint1,i,6, j1,j1a, Vector3.new(1.5,0.5,0), Vector3.new(0,0,0))
								SetWeld(joint2,i,6, j2,j2a, Vector3.new(-1.5,0.5,0), Vector3.new(0,0,0))
								SetWeld(joint3,i,6, j3,j3a, Vector3.new(0.5,-1,0), Vector3.new(0,math.pi/2,0))
								SetWeld(joint4,i,6, j4,j4a, Vector3.new(-0.5,-1,0), Vector3.new(0,math.pi/2,0))
								SetWeld(joint5,i,6, j5,j5a, Vector3.new(0,1,0), Vector3.new(0,0,0))
								bp.position = bp.position + Vector3.new(0,0.1,0)
								bg.cframe = bgcf * CFrame.Angles(-bgval + (bgval/6*i),0,0)
								Torsoz.CFrame = bg.cframe + bp.position
								wait(0.02)
							end

							bp:remove()
						end

					end

					bv:remove()
					bg:remove()
					VWallRunning = false
					Stand()
				end
			end

			function Slide(pos)
				flow.Value = flow.Value + 6
				Action = "Sliding"
				Sliding = true
				GravPoint = Torsoz.Velocity.y
				local spd = Vector3.new(Torsoz.Velocity.x,0,Torsoz.Velocity.z).magnitude + 10
				local dir = Vector3.new(Torsoz.Velocity.x,0,Torsoz.Velocity.z).unit

				local bv = Instance.new("BodyVelocity", Torsoz)
				bv.maxForce = Vector3.new(1/0,1/0,1/0)
				bv.velocity = dir*spd
				local bg = Instance.new("BodyGyro", Torsoz)
				bg.maxTorque = Vector3.new(1/0,1/0,1/0)
				bg.cframe = CFrame.new(NV, dir) * CFrame.Angles(math.pi/2.2,0.24,0)

				local joint1 = Joint1
				local joint2 = Joint2
				local joint3 = Joint3
				local joint4 = Joint4
				local joint5 = Joint5
				local j1,j1a = GetWeld(joint1)
				local j2,j2a = GetWeld(joint2)

				SetWeld(joint1,1,1, NV,NV, Vector3.new(j1.x,j1.y,j1.z), Vector3.new(j1a.x,math.pi/2,j1a.z))
				joint1.C1 = CFrame.new(0,1,0) * CFrame.Angles(0,math.pi/2,0)
				SetWeld(joint2,1,1, NV,NV, Vector3.new(j2.x,j2.y,j2.z), Vector3.new(j2a.x,math.pi/2,j2a.z))
				joint2.C1 = CFrame.new(0,1,0) * CFrame.Angles(0,math.pi/2,0)

				local j1,j1a = GetWeld(joint1)
				local j2,j2a = GetWeld(joint2)
				local j3,j3a = GetWeld(joint3)
				local j4,j4a = GetWeld(joint4)
				local j5,j5a = GetWeld(joint5)

				local count = 0
				local lastpos

				while Sliding == true do
					count = count + 1
					Hu.PlatformStand = true
					local hitz1, enz1 = RAY(Torsoz.Position+Vector3.new(0,0.03,0), dir *2.5)
					local hitz2, enz2 = RAY(Torsoz.Position-Vector3.new(0,0.2,0), dir *2.5)
					local ghitz, genz = RAY(Torsoz.Position, Vector3.new(0,-2.6,0))
					bv.velocity = dir*spd + Vector3.new(0,GravPoint,0)

					if count <= 5 then
						SetWeld(joint1,count,5, j1,j1a, Vector3.new(0.5,-0.8,-0.15), Vector3.new(0,(math.pi/2)+0.1,-0.4))
						SetWeld(joint2,count,5, j2,j2a, Vector3.new(-0.5,-1,0), Vector3.new(0,(math.pi/2)-0.4,0))
						SetWeld(joint3,count,5, j3,j3a, Vector3.new(1.5,0.5,0), Vector3.new(-0.7,-0.24,math.pi/5))
						SetWeld(joint4,count,5, j4,j4a, Vector3.new(-1.5,0.5,0), Vector3.new(-0.1,0,-math.pi/1.5))
						SetWeld(joint5,count,5, j5,j5a, Vector3.new(0,1,0), Vector3.new(-0.5,-0.2,0))
					end

					if (hitz1 ~= nil and hitz1.CanCollide == true) or (hitz2 ~= nil and  hitz2.CanCollide == true) then
						bv:remove()
						bg:remove()
						Sliding = "HitObject"
					end
					if ghitz ~= nil then
						GravPoint = 0
						Torsoz.CFrame = CFrame.new(genz, genz+dir) * CFrame.Angles(math.pi/2.2,0.24,0) + Vector3.new(0,0.7,0)
						spd = spd - 0.95
					else
						if GravPoint > -180 then
							GravPoint = GravPoint - 5.6
						end
						spd = spd - 0.36
					end
					if spd < 7 then
						Sliding = false
					end
					wait(0.02)
				end

				if Sliding == false then
					local j1,j1a = GetWeld(joint1)
					local j2,j2a = GetWeld(joint2)
					local j3,j3a = GetWeld(joint3)
					local j4,j4a = GetWeld(joint4)
					local j5,j5a = GetWeld(joint5)
					for i = 1, 4 do
						SetWeld(joint1,i,4, j1,j1a, Vector3.new(0.5,-1,0), Vector3.new(0,math.pi/2,0))
						SetWeld(joint2,i,4, j2,j2a, Vector3.new(-0.5,-1,0), Vector3.new(0,math.pi/2,0))
						SetWeld(joint3,i,4, j3,j3a, Vector3.new(1.5,0.5,0), NV)
						SetWeld(joint4,i,4, j4,j4a, Vector3.new(-1.5,0.5,0), NV)
						SetWeld(joint5,i,4, j5,j5a, Vector3.new(0,1,0), NV)
						local hitz, enz = RAY(Torsoz.Position, Vector3.new(0,-2.6,0))
						bg.cframe = CFrame.new(NV, dir) * CFrame.Angles((math.pi/2.2) - ((math.pi/2.2)/4*i),0.24 - (0.24/4*i),0)
						bv.velocity = dir*spd + Vector3.new(0,GravPoint,0)

						if hitz ~= nil then
							GravPoint = 0
							Torsoz.CFrame = CFrame.new(enz, enz+dir) * CFrame.Angles((math.pi/2.2) - ((math.pi/2.2)/4*i),0.24 - (0.24/4*i),0) + Vector3.new(0,0.7+(1.8/4*i),0)
							spd = spd - 0.95
						else
							if GravPoint > -180 then
								GravPoint = GravPoint - 5.6
							end
							spd = spd - 0.36
						end
						wait(0.02)
					end
					local hitz, enz = RAY(Torsoz.Position, Vector3.new(0,-2.6,0))
					Torsoz.CFrame = CFrame.new(enz, enz+dir) + Vector3.new(0,3,0)
				end
				bv:remove()
				bg:remove()
				SlideCooldown = 10
				Stand()
			end

			function KD(key)
				if pause.Value == false then
					if key == string.char(32) then
						Space = true

						local ghitz, genz = RAY(Torsoz.Position, Vector3.new(0,-3.7,0))
						local hitz, enz = RAY(Torsoz.Position+Vector3.new(0,1.1,0), Torsoz.CFrame.lookVector*2.3)
						local righthitz, rightenz
						local lefthitz, leftenz

						if HWallRunning == false then
							righthitz, rightenz = RAY(Torsoz.Position, ((Torsoz.CFrame * CFrame.new(1.5,0,-0.2)).p - Torsoz.CFrame.p).unit*3.9)
							lefthitz, leftenz = RAY(Torsoz.Position, ((Torsoz.CFrame * CFrame.new(-1.5,0,-0.2)).p - Torsoz.CFrame.p).unit*3.9)

						elseif HWallRunning == "Jumping" then
							righthitz, rightenz = RAY(Torsoz.Position, ((CFrame.new(Torsoz.Position, Torsoz.Position + HWRDir) * CFrame.new(1.5,0,-0.2)).p - Torsoz.Position).unit*3.9)
							lefthitz, leftenz = RAY(Torsoz.Position, ((CFrame.new(Torsoz.Position, Torsoz.Position + HWRDir) * CFrame.new(-1.5,0,-0.2)).p - Torsoz.Position).unit*3.9)

						end

						if Action == "Standing" and Shift == true and (hitz == nil or hitz.CanCollide == false) and (righthitz == nil or righthitz.CanCollide == false) and (lefthitz == nil or lefthitz.CanCollide == false) and (ghitz == nil or ghitz.CanCollide == false) and (Torsoz.Velocity.y > 6 and Torsoz.Velocity.y < 50) and DivingCooldown <= 0 then
							if stamina >= 10 then
								--if Vector3.new(Torsoz.Velocity.x,0,Torsoz.Velocity.z).magnitude > 12 then
								Dive()
								--end
							end
						end

						if hitz == nil and VWallRunning == "Falling" then
							VWallRunning = "BackflipFromFall"
						end

						if Shift == true and Torsoz.Velocity.y > -50 and Diving == false and DivingCooldown <= 0 then
							local hitz2, enz2 = RAY(Torsoz.Position, Vector3.new(0,-3.5,0))

							if hitz ~= nil then
								if Action == "Standing" and VWRCooldown == 0 then
									if hitz2 == nil or hitz2.CanCollide == false then
										VWR(hitz, enz)
									end
								end
							end

							if (HWallRunning == false or (HWallRunning == "Jumping" and (HWRLastPart ~= righthitz or HWRLastPart ~= lefthitz))) and HWRCooldown == 0 and VWallRunning == false then

								if (hitz == nil or HWallRunning == "Jumping") and ((righthitz ~= nil and righthitz.Parent:findFirstChild("Humanoid") == nil and righthitz.Parent.className ~= "Hat") or (lefthitz ~= nil and lefthitz.Parent:findFirstChild("Humanoid") == nil and lefthitz.Parent.className ~= "Hat")) then
									if hitz2 == nil or hitz2.CanCollide == false then
										local right = (rightenz - Torsoz.Position).magnitude
										local left = (leftenz - Torsoz.Position).magnitude
										if right < left then
											if HWallRunning == "Jumping" and HWRLastPart ~= righthitz then
												HWallRunning = false
												while Standing == false do
													wait(0.01)
												end
												print("2nd Right Activated!")
												HWallRun(righthitz, rightenz, -math.pi/2)
											else
												if hitz == nil then
													print("Right Activated")
													HWallRun(righthitz, rightenz, -math.pi/2)
												end
											end
										elseif left < right then
											if HWallRunning == "Jumping" and HWRLastPart ~= lefthitz then
												HWallRunning = false
												while Standing == false do
													wait(0.01)
												end
												print("2nd Left Activated!")
												HWallRun(lefthitz, leftenz, math.pi/2)
											else
												if hitz == nil then
													print("Left Activated")
													HWallRun(lefthitz, leftenz, math.pi/2)
												end
											end
										end
									end
								end
							end

						end

						if HWallRunning == true then
							HWallRunning = "Jumping"
							Action = "HWRJumping"
						end

					elseif key == string.char(48) then
						Shift = true
					elseif key == string.char(50) then
						if Action == "Standing" then
							Sit()
						elseif HWallRunning == true then
							HWRGravDrop = true
						end
					elseif key == string.char(52) then
						if Shift == true and Action == "Standing" and SlideCooldown == 0 and Vector3.new(Torsoz.Velocity.x,0,Torsoz.Velocity.z).magnitude > 15 and Torsoz.Velocity.y > -40 then
							print("Sliding")
							Slide()
						end
					elseif key == "a" then
						VWRLeft = true
					elseif key == "d" then
						VWRRight = true
					end
				end
			end

			function KU(key)
				if key == string.char(32) then
					Space = false
				elseif key == string.char(48) then
					Shift = false
				elseif key == string.char(50) then
					if Action == "Sitting" then
						Stand()
					end
				elseif key == string.char(52) then
					Sliding = false
				elseif key == "a" then
					VWRLeft = false
				elseif key == "d" then
					VWRRight = false
				end
			end

			mouse.KeyDown:connect(function(key) KD(key) end)
			mouse.KeyUp:connect(function(key) KU(key) end)

			Joint1 = Instance.new("Snap", Torsoz)
			GetWeld(Joint1)
			Joint2 = Instance.new("Snap", Torsoz)
			GetWeld(Joint2)
			Joint3 = Instance.new("Snap", Torsoz)
			GetWeld(Joint3)
			Joint4 = Instance.new("Snap", Torsoz)
			GetWeld(Joint4)
			Joint5 = Instance.new("Snap", Torsoz)
			GetWeld(Joint5)
			Stand()

			local animatebg = Instance.new("BodyGyro")
			animatebg.D = 100
			local GravAction = "Idle"
			local PrevGravAction = GravAction

			local prevrapos = (RA.CFrame * CFrame.new(0,-1,0)).p
			local prevlapos = (LA.CFrame * CFrame.new(0,-1,0)).p
			local hue = 0
			local recyclecount = 0
			local tickoffset = tick()
			local fadetab = {}
			local fadetab2 = {}
			local animatebgcount = 0

			for i = 1, 13 do
				local p = P:Clone()
				p.Name = "Part"..i
				local mesh = Instance.new("SpecialMesh", p)
				mesh.MeshId = "http://www.roblox.com/Asset/?id=9856898"
				mesh.TextureId = "http://www.roblox.com/Asset/?id=48358980"
				table.insert(fadetab, {p, mesh})
			end
			for i = 1, 13 do
				local p = P:Clone()
				p.Name = "Part"..i
				local mesh = Instance.new("SpecialMesh", p)
				mesh.MeshId = "http://www.roblox.com/Asset/?id=9856898"
				mesh.TextureId = "http://www.roblox.com/Asset/?id=48358980"
				table.insert(fadetab2, {p, mesh})
			end

			game:service("RunService").Stepped:connect(function()
				GravAction = "Idle"
				hue = hue + 3
				hue = hue % 360

				------------- anim angle changing --------
				if animangle > math.pi then
					animplus = false
				elseif animangle < -math.pi then
					animplus = true  
				end
				if animplus == true then
					animangle = animangle + animspeed
				elseif animplus == false then
					animangle = animangle - animspeed
				end

				local hitz, enz = RAY(Torsoz.Position, Vector3.new(0,-3.9,0))
				if Shift == true then
					Hu.WalkSpeed = sprint
				else
					Hu.WalkSpeed = 16
				end
				if (FOV >= 70 and FOV < 74) and Vector3.new(Torsoz.Velocity.x,0,Torsoz.Velocity.z).magnitude > 25 then
					FOV = FOV + 1
				elseif (FOV <= 74 and FOV > 70) and Vector3.new(Torsoz.Velocity.x,0,Torsoz.Velocity.z).magnitude < 20 then
					FOV = FOV - 1
				end
				if pause.Value == true then
					Hu.WalkSpeed = 0
				end
				if Sitting == true then
					local hitz2, enz2 = RAY(Torsoz.Position, Vector3.new(0,-2.2,0))
					Hu.PlatformStand = true
					if hitz2 == nil then
						Stand()
					end
				end
				if Diving == true then
					Hu.PlatformStand = true
					DivingBV.velocity = Vector3.new(DivingDir.x*(sprint+2),GravPoint,DivingDir.z*(sprint+2))
					DivingBG.cframe = CFrame.new(Torsoz.Position, Torsoz.Position+DivingBV.velocity) * CFrame.Angles(-math.pi/2,0,0)

					if GravPoint > -180 then
						GravPoint = GravPoint - 2
					end
				end
				if DivingCooldown > 0 then
					DivingCooldown = DivingCooldown - 1
				end
				if HWallRunning == true then
					if HWRGravDrop == false then
						GravPoint = GravPoint - 0.4
					else
						GravPoint = GravPoint - 2
					end
				elseif HWallRunning == "Jumping" then
					GravPoint = GravPoint - 1.7
				end
				----------------------------- stamina ----------------------------------------
				if Vector3.new(Torsoz.Velocity.x, 0, Torsoz.Velocity.z).magnitude > 18 and Action == "Standing" and Shift == true then
					if stamina > 0 then
						stamina = stamina - 0.5
						if stamina < 0 then
							Shift = false
							stamina = 0
						end
					else
						Shift = false
						stamina = 0
					end
					if Action == "Standing" then
						animspeed = 0.85
						SetWeld(Joint1,1,1, NV,NV, Vector3.new(0.5,-1,0), Vector3.new(-animangle/4.85,0,0))
						SetWeld(Joint2,1,1, NV,NV, Vector3.new(-0.5,-1,0), Vector3.new(animangle/4.85,0,0))
						SetWeld(Joint3,1,1, NV,NV, Vector3.new(1.5,0.5,0), Vector3.new(animangle/3.5,0,0))
						SetWeld(Joint4,1,1, NV,NV, Vector3.new(-1.5,0.5,0), Vector3.new(-animangle/3.5,0,0))
					end
				elseif Vector3.new(Torsoz.Velocity.x, 0, Torsoz.Velocity.z).magnitude > 12 and Action ~= "Sliding" then
					if stamina < maxstamina then
						stamina = stamina + 0.5
						if stamina > maxstamina then
							stamina = maxstamina
						end
					else
						stamina = maxstamina
					end
					if Action == "Standing" then
						animspeed = 0.65
						SetWeld(Joint1,1,1, NV,NV, Vector3.new(0.5,-1,0), Vector3.new(-animangle/7,0,0))
						SetWeld(Joint2,1,1, NV,NV, Vector3.new(-0.5,-1,0), Vector3.new(animangle/7,0,0))
						SetWeld(Joint3,1,1, NV,NV, Vector3.new(1.5,0.5,0), Vector3.new(animangle/5,0,0))
						SetWeld(Joint4,1,1, NV,NV, Vector3.new(-1.5,0.5,0), Vector3.new(-animangle/5,0,0))
					end
				elseif Vector3.new(Torsoz.Velocity.x, 0, Torsoz.Velocity.z).magnitude < 2 then
					animspeed = 0.1
					if Action == "Standing" then
						SetWeld(Joint1,1,1, NV,NV, Vector3.new(0.5,-1,0), Vector3.new(-animangle/38,0,0))
						SetWeld(Joint2,1,1, NV,NV, Vector3.new(-0.5,-1,0), Vector3.new(animangle/38,0,0))
						SetWeld(Joint3,1,1, NV,NV, Vector3.new(1.5,0.5,0), Vector3.new(animangle/30,0,0))
						SetWeld(Joint4,1,1, NV,NV, Vector3.new(-1.5,0.5,0), Vector3.new(-animangle/30,0,0))
					end
					if stamina < maxstamina then
						if Sitting == false then
							stamina = stamina + 0.65
						else
							stamina = stamina + 1.02
						end
						if stamina > maxstamina then
							stamina = maxstamina
						end
					else
						stamina = maxstamina
					end
				end

				if hitz == nil then
					if Torsoz.Velocity.y > 1 or (Torsoz.Velocity.y < -1 and Torsoz.Velocity.y > -90) then
						if Action == "Standing" then
							GravAction = "Rising"
							animspeed = 0.1
							SetWeld(Joint1,1,1, NV,NV, Vector3.new(0.5,-1,0), Vector3.new(-animangle/38,0,0))
							SetWeld(Joint2,1,1, NV,NV, Vector3.new(-0.5,-1,0), Vector3.new(animangle/38,0,0))
							SetWeld(Joint3,1,1, NV,NV, Vector3.new(1.5,0.5,0), Vector3.new((math.pi-0.2)+(animangle/30),0,0))
							SetWeld(Joint4,1,1, NV,NV, Vector3.new(-1.5,0.5,0), Vector3.new((math.pi-0.2)+(-animangle/30),0,0))
							if animatebg.Parent ~= nil then
								animatebg.Parent = Torsoz
								animatebg.maxTorque = Vector3.new(1/0,10000,1/0)
								local lokvec = Torsoz.CFrame.lookVector*100
								animatebg.cframe = CFrame.new(NV, Vector3.new(lokvec.x,0,lokvec.z))
								animatebg.Parent = nil
							end
						end
					end
				end

				if hitz == nil then
					local hitz2, enz2 = RAY(Torsoz.Position, Vector3.new(0,-6,0))
					if hitz2 == nil then
						if Torsoz.Velocity.y < -90 then
							if Action == "Standing" then
								GravAction = "Falling"
								animspeed = 1.1
								animatebg.Parent = Torsoz
								animatebg.maxTorque = Vector3.new(1/0,10000,1/0)
								local lokvec = Torsoz.CFrame.lookVector*100
								animatebg.cframe = CFrame.new(NV, Vector3.new(lokvec.x,0,lokvec.z)) * CFrame.Angles(-math.pi/11,animangle/70,0)
								SetWeld(Joint1,1,1, NV,NV, Vector3.new(0.45,-0.8,0), Vector3.new((animangle/27)-0.3,0,0.18))
								SetWeld(Joint2,1,1, NV,NV, Vector3.new(-0.45,-0.8,0), Vector3.new((-animangle/27)-0.3,0,-0.18))
								SetWeld(Joint3,1,1, NV,NV, Vector3.new(1.4,0.5,0), Vector3.new((math.pi+0.2)+(animangle/26),0,0.18))
								SetWeld(Joint4,1,1, NV,NV, Vector3.new(-1.4,0.5,0), Vector3.new((math.pi+0.2)+(-animangle/26),0,-0.18))
							end
						end
					elseif hitz2.CanCollide == true then
						if animatebg.Parent ~= nil then
							animatebg.Parent = Torsoz
							animatebg.maxTorque = Vector3.new(1/0,10000,1/0)
							local lokvec = Torsoz.CFrame.lookVector*100
							animatebg.cframe = CFrame.new(NV, Vector3.new(lokvec.x,0,lokvec.z))
							animatebg.Parent = nil
						end
					end
				end

				if GravAction == "Idle" and animatebg.Parent ~= nil then
					animatebg.Parent = nil
				end

				if math.abs(tickoffset - tick()) > 0.05 then
					tickoffset = tick()
					local flowcolor = HSV(hue, 0.7,1)
					recyclecount = (recyclecount % #fadetab) + 1
					if flow.Value > 25 then
						local lapos = (LA.CFrame * CFrame.new(0,-1,0)).p
						local rapos = (RA.CFrame * CFrame.new(0,-1,0)).p
						local p = fadetab[recyclecount]
						p[1].Parent = m
						p[1].CFrame = CFrame.new((lapos+prevlapos)/2, lapos)
						p[2].Scale = Vector3.new(0.5,0.5,(lapos-prevlapos).magnitude*2)
						p[2].VertexColor = Vector3.new(flowcolor.r,flowcolor.g,flowcolor.b)
						p[1].Transparency = math.abs((flow.Value/120) - 0.8)
						p[1].Transparency = p[1].Transparency + (1/#fadetab)
						local p = fadetab2[recyclecount]
						p[1].Parent = m
						p[1].CFrame = CFrame.new((rapos+prevrapos)/2, rapos)
						p[2].Scale = Vector3.new(0.5,0.5,(rapos-prevrapos).magnitude*2)
						p[2].VertexColor = Vector3.new(flowcolor.r,flowcolor.g,flowcolor.b)
						p[1].Transparency = math.abs((flow.Value/120) - 0.8)
						p[1].Transparency = p[1].Transparency + (1/#fadetab)
					end

					for i, v in pairs(fadetab) do
						if v[1].Transparency < 0.9 then
							v[1].Transparency = v[1].Transparency + (1/#fadetab)
							fadetab2[i][1].Transparency = fadetab2[i][1].Transparency + (1/#fadetab)
						elseif v[1].Transparency ~= 1 then
							v[1].Transparency = 1
							v[1].Position = Vector3.new(50000,0,0)
							fadetab2[i][1].Transparency = 1
							fadetab2[i][1].Position = Vector3.new(50000,0,0)
						end
					end

					prevrapos = (RA.CFrame * CFrame.new(0,-1,0)).p
					prevlapos = (LA.CFrame * CFrame.new(0,-1,0)).p
				end

				if flow.Value > 140 then
					if char.Parent ~= nil then
						char:remove()
					end
				end

				if flowcooldown > 0 then
					flowcooldown = flowcooldown - 1
				end
				if HWRCooldown > 0 then
					HWRCooldown = HWRCooldown - 1
				end
				if VWRCooldown > 0 then
					if hitz ~= nil and VWRCooldown > 0 then
						VWRCooldown = VWRCooldown - 1
					end
				end
				if SlideCooldown > 0 then
					SlideCooldown = SlideCooldown - 1
				end

				if Action == "HWallRunning" or Action == "VWallRunning" then
					flow.Value = flow.Value + 0.24
					if flow.Value > 100 then
						flow.Value = 100
					end
					flowcooldown = 40
				elseif Action == "Diving" then
					flowcooldown = 30
				elseif Action == "Sliding" then
					flowcooldown = 15
				elseif Action == "Standing" or Action == "Sitting" then
					if flow.Value > 0 and flowcooldown <= 0 then
						flow.Value = flow.Value - 0.37
						if flow.Value < 0 then
							flow.Value = 0
						end
					end
				end

				cam.FieldOfView = FOV
				prevanimbgcount = animatebgcount
				sprint = defsprint + ((flow.Value/100)*2.4)
				PrevGravAction = GravAction
				Calculate()
			end)
		end)

		UICorner_2.Parent = ParkourGod

		ServerAdmin.Name = "ServerAdmin"
		ServerAdmin.Parent = Page1
		ServerAdmin.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		ServerAdmin.Position = UDim2.new(0.501999974, 10, 1.875, -280)
		ServerAdmin.Size = UDim2.new(0, 110, 0, 48)
		ServerAdmin.ZIndex = 7
		ServerAdmin.Font = Enum.Font.SourceSansBold
		ServerAdmin.Text = "Server Admin"
		ServerAdmin.TextColor3 = Color3.fromRGB(61, 61, 61)
		ServerAdmin.TextSize = 18.000
		ServerAdmin.TextWrapped = true
		ServerAdmin.MouseButton1Click:connect(function() -- server admin
			loadstring(game:HttpGet("https://raw.githubusercontent.com/ONEReverseCard/My-Scripts/main/Netless%20Server%20Admin.md"))()
		end)

		UICorner_3.Parent = ServerAdmin

		slinger.Name = "slinger"
		slinger.Parent = Page1
		slinger.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		slinger.Position = UDim2.new(0.00400000019, 10, 1.57500005, -280)
		slinger.Size = UDim2.new(0, 110, 0, 48)
		slinger.ZIndex = 7
		slinger.Font = Enum.Font.SourceSansBold
		slinger.Text = "Slinger"
		slinger.TextColor3 = Color3.fromRGB(61, 61, 61)
		slinger.TextSize = 18.000
		slinger.TextWrapped = true
		slinger.MouseButton1Click:Connect(function()
			local lp = game:FindService("Players").LocalPlayer

			local function gplr(String)
				local Found = {}
				local strl = String:lower()
				if strl == "all" then
					for i,v in pairs(game:FindService("Players"):GetPlayers()) do
						table.insert(Found,v)
					end
				elseif strl == "others" then
					for i,v in pairs(game:FindService("Players"):GetPlayers()) do
						if v.Name ~= lp.Name then
							table.insert(Found,v)
						end
					end 
				elseif strl == "me" then
					for i,v in pairs(game:FindService("Players"):GetPlayers()) do
						if v.Name == lp.Name then
							table.insert(Found,v)
						end
					end 
				else
					for i,v in pairs(game:FindService("Players"):GetPlayers()) do
						if v.Name:lower():sub(1, #String) == String:lower() then
							table.insert(Found,v)
						end
					end 
				end
				return Found 
			end

			local function notif(str,dur)
				game:FindService("StarterGui"):SetCore("SendNotification", {
					Title = "yeet gui",
					Text = str,
					Icon = "rbxassetid://2005276185",
					Duration = dur or 3
				})
			end

			--// sds

			local h = Instance.new("ScreenGui")
			local Main = Instance.new("ImageLabel")
			local Top = Instance.new("Frame")
			local Title = Instance.new("TextLabel")
			local TextBox = Instance.new("TextBox")
			local TextButton = Instance.new("TextButton")

			h.Name = "h"
			h.Parent = game:GetService("CoreGui")
			h.ResetOnSpawn = false

			Main.Name = "Main"
			Main.Parent = h
			Main.Active = true
			Main.Draggable = true
			Main.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Main.BorderSizePixel = 0
			Main.Position = UDim2.new(0.174545452, 0, 0.459574461, 0)
			Main.Size = UDim2.new(0, 454, 0, 218)
			Main.Image = "rbxassetid://2005276185"

			Top.Name = "Top"
			Top.Parent = Main
			Top.BackgroundColor3 = Color3.fromRGB(57, 57, 57)
			Top.BorderSizePixel = 0
			Top.Size = UDim2.new(0, 454, 0, 44)

			Title.Name = "Title"
			Title.Parent = Top
			Title.BackgroundColor3 = Color3.fromRGB(49, 49, 49)
			Title.BorderSizePixel = 0
			Title.Position = UDim2.new(0, 0, 0.295454562, 0)
			Title.Size = UDim2.new(0, 454, 0, 30)
			Title.Font = Enum.Font.SourceSans
			Title.Text = "FE Yeet Gui (trollface edition)"
			Title.TextColor3 = Color3.fromRGB(255, 255, 255)
			Title.TextScaled = true
			Title.TextSize = 14.000
			Title.TextWrapped = true

			TextBox.Parent = Main
			TextBox.BackgroundColor3 = Color3.fromRGB(49, 49, 49)
			TextBox.BorderSizePixel = 0
			TextBox.Position = UDim2.new(0.0704845786, 0, 0.270642221, 0)
			TextBox.Size = UDim2.new(0, 388, 0, 62)
			TextBox.Font = Enum.Font.SourceSans
			TextBox.PlaceholderText = "Who do i destroy(can be shortened)"
			TextBox.Text = ""
			TextBox.TextColor3 = Color3.fromRGB(255, 255, 255)
			TextBox.TextScaled = true
			TextBox.TextSize = 14.000
			TextBox.TextWrapped = true

			TextButton.Parent = Main
			TextButton.BackgroundColor3 = Color3.fromRGB(49, 49, 49)
			TextButton.BorderSizePixel = 0
			TextButton.Position = UDim2.new(0.10352423, 0, 0.596330225, 0)
			TextButton.Size = UDim2.new(0, 359, 0, 50)
			TextButton.Font = Enum.Font.SourceSans
			TextButton.Text = "Cheese em'"
			TextButton.TextColor3 = Color3.fromRGB(255, 255, 255)
			TextButton.TextScaled = true
			TextButton.TextSize = 14.000
			TextButton.TextWrapped = true
			TextButton.MouseButton1Click:Connect(function()
				local Target = gplr(TextBox.Text)
				if Target[1] then
					Target = Target[1]

					local Thrust = Instance.new('BodyThrust', lp.Character.HumanoidRootPart)
					Thrust.Force = Vector3.new(9999,9999,9999)
					Thrust.Name = "YeetForce"
					repeat
						lp.Character.HumanoidRootPart.CFrame = Target.Character.HumanoidRootPart.CFrame
						Thrust.Location = Target.Character.HumanoidRootPart.Position
						game:FindService("RunService").Heartbeat:wait()
					until not Target.Character:FindFirstChild("Head")
				else
					notif("Invalid player")
				end
				notif("Loaded successfully! Created by scuba#0001", 5)
			end)
		end)

		UICorner_4.Parent = slinger

		feutgv2.Name = "feutgv2"
		feutgv2.Parent = Page1
		feutgv2.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		feutgv2.Position = UDim2.new(0.75999999, 10, 1.875, -280)
		feutgv2.Size = UDim2.new(0, 110, 0, 48)
		feutgv2.ZIndex = 7
		feutgv2.Font = Enum.Font.SourceSansBold
		feutgv2.Text = "FE UTG v2"
		feutgv2.TextColor3 = Color3.fromRGB(61, 61, 61)
		feutgv2.TextSize = 18.000
		feutgv2.TextWrapped = true
		feutgv2.MouseButton1Click:connect(function()
			local UTG_V2 = Instance.new("ScreenGui")
			local Main = Instance.new("Frame")
			local UIGradient = Instance.new("UIGradient")
			local UICorner = Instance.new("UICorner")
			local Title = Instance.new("TextLabel")
			local SubTitile = Instance.new("TextLabel")
			local Welcome = Instance.new("TextLabel")
			local UICorner_2 = Instance.new("UICorner")
			local Credits = Instance.new("TextLabel")
			local UICorner_3 = Instance.new("UICorner")
			local OptionListFrame = Instance.new("Frame")
			local OptionList = Instance.new("ScrollingFrame")
			local Sonic = Instance.new("TextButton")
			local UICorner_4 = Instance.new("UICorner")
			local Gale = Instance.new("TextButton")
			local UICorner_5 = Instance.new("UICorner")
			local Among_Us = Instance.new("TextButton")
			local UICorner_6 = Instance.new("UICorner")
			local Killbot = Instance.new("TextButton")
			local UICorner_7 = Instance.new("UICorner")
			local NekoMaid = Instance.new("TextButton")
			local UICorner_8 = Instance.new("UICorner")
			local Smug = Instance.new("TextButton")
			local UICorner_9 = Instance.new("UICorner")
			local ShadowBlade = Instance.new("TextButton")
			local UICorner_10 = Instance.new("UICorner")
			local SwordStand = Instance.new("TextButton")
			local UICorner_11 = Instance.new("UICorner")
			local Neptunion = Instance.new("TextButton")
			local UICorner_12 = Instance.new("UICorner")
			local RbNeptunion = Instance.new("TextButton")
			local UICorner_13 = Instance.new("UICorner")
			local Wall = Instance.new("TextButton")
			local UICorner_14 = Instance.new("UICorner")
			local achroGlicher = Instance.new("TextButton")
			local UICorner_15 = Instance.new("UICorner")
			local FlamingCube = Instance.new("TextButton")
			local UICorner_16 = Instance.new("UICorner")
			local Spider = Instance.new("TextButton")
			local UICorner_17 = Instance.new("UICorner")
			local Cop = Instance.new("TextButton")
			local UICorner_18 = Instance.new("UICorner")
			local Chips = Instance.new("TextButton")
			local UICorner_19 = Instance.new("UICorner")
			local Joy = Instance.new("TextButton")
			local UICorner_20 = Instance.new("UICorner")
			local UMD = Instance.new("TextButton")
			local UICorner_21 = Instance.new("UICorner")
			local Chill = Instance.new("TextButton")
			local UICorner_22 = Instance.new("UICorner")
			local Grapple = Instance.new("TextButton")
			local UICorner_23 = Instance.new("UICorner")
			local ServerAdmin = Instance.new("TextButton")
			local UICorner_24 = Instance.new("UICorner")
			local Ender = Instance.new("TextButton")
			local UICorner_25 = Instance.new("UICorner")
			local Ban = Instance.new("TextButton")
			local UICorner_26 = Instance.new("UICorner")
			local Netless = Instance.new("TextButton")
			local UICorner_27 = Instance.new("UICorner")
			local Shadow = Instance.new("Frame")
			local UICorner_28 = Instance.new("UICorner")
			local TextLabel = Instance.new("TextLabel")
			local AntiReport = Instance.new("TextButton")
			local UICorner_29 = Instance.new("UICorner")
			local Shadow_2 = Instance.new("Frame")
			local UICorner_30 = Instance.new("UICorner")
			local TextLabel_2 = Instance.new("TextLabel")
			local X = Instance.new("TextButton")
			local UICorner_31 = Instance.new("UICorner")
			local OpenUTG = Instance.new("TextButton")

			--Properties:

			UTG_V2.Name = "UTG_V2"
			UTG_V2.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
			UTG_V2.ResetOnSpawn = false

			Main.Name = "Main"
			Main.Parent = UTG_V2
			Main.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Main.BorderColor3 = Color3.fromRGB(27, 42, 53)
			Main.BorderSizePixel = 0
			Main.Position = UDim2.new(0.0592107326, 0, 0.0301492307, 0)
			Main.Size = UDim2.new(0, 451, 0, 534)

			UIGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(137, 0, 254)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(223, 0, 255))}
			UIGradient.Parent = Main

			UICorner.CornerRadius = UDim.new(0, 5)
			UICorner.Parent = Main

			Title.Name = "Title"
			Title.Parent = Main
			Title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Title.BackgroundTransparency = 1.000
			Title.Position = UDim2.new(0.0711524412, 0, -0.00186577276, 0)
			Title.Size = UDim2.new(0, 385, 0, 54)
			Title.Font = Enum.Font.SourceSans
			Title.Text = "ULTIMATE TROLLING GUI V2"
			Title.TextColor3 = Color3.fromRGB(255, 255, 255)
			Title.TextScaled = true
			Title.TextSize = 38.000
			Title.TextWrapped = true

			SubTitile.Name = "SubTitile"
			SubTitile.Parent = Title
			SubTitile.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			SubTitile.BackgroundTransparency = 1.000
			SubTitile.Position = UDim2.new(-0.285957217, 0, 0.388888925, 0)
			SubTitile.Size = UDim2.new(0, 611, 0, 54)
			SubTitile.Font = Enum.Font.SourceSans
			SubTitile.Text = "FE UTG is back! And is now V2! Thx for using! :)"
			SubTitile.TextColor3 = Color3.fromRGB(255, 255, 255)
			SubTitile.TextSize = 20.000

			Welcome.Name = "Welcome"
			Welcome.Parent = Main
			Welcome.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Welcome.Position = UDim2.new(0.0505445786, 0, 0.114676468, 0)
			Welcome.Size = UDim2.new(0, 403, 0, 36)
			Welcome.Font = Enum.Font.SourceSansBold
			Welcome.Text = "Welcome to the brand new FE UTG! Made by Bulkez"
			Welcome.TextColor3 = Color3.fromRGB(0, 0, 0)
			Welcome.TextScaled = true
			Welcome.TextSize = 14.000
			Welcome.TextWrapped = true

			UICorner_2.Parent = Welcome

			Credits.Name = "Credits"
			Credits.Parent = Main
			Credits.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Credits.Position = UDim2.new(0.0527422242, 0, 0.772552848, 0)
			Credits.Size = UDim2.new(0, 405, 0, 44)
			Credits.Font = Enum.Font.SourceSansBold
			Credits.Text = "Made by Blukez also credit to the original script creators"

			Credits.TextColor3 = Color3.fromRGB(0, 0, 0)
			Credits.TextScaled = true
			Credits.TextSize = 14.000
			Credits.TextWrapped = true

			UICorner_3.Parent = Credits

			OptionListFrame.Name = "OptionListFrame"
			OptionListFrame.Parent = Main
			OptionListFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			OptionListFrame.BackgroundTransparency = 1.000
			OptionListFrame.Position = UDim2.new(0.0279720332, 0, 0.191011235, 0)
			OptionListFrame.Size = UDim2.new(0, 403, 0, 711)

			OptionList.Name = "OptionList"
			OptionList.Parent = OptionListFrame
			OptionList.Active = true
			OptionList.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			OptionList.Position = UDim2.new(0.0351866931, 0, 0.00994348992, 0)
			OptionList.Size = UDim2.new(0, 402, 0, 296)

			Sonic.Name = "Sonic"
			Sonic.Parent = OptionList
			Sonic.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
			Sonic.Position = UDim2.new(0.0231197979, 0, 0.00696475245, 0)
			Sonic.Size = UDim2.new(0, 370, 0, 50)
			Sonic.Font = Enum.Font.SourceSans
			Sonic.Text = "Sonic"
			Sonic.TextColor3 = Color3.fromRGB(255, 255, 255)
			Sonic.TextScaled = true
			Sonic.TextSize = 14.000
			Sonic.TextWrapped = true

			UICorner_4.Parent = Sonic

			Gale.Name = "Gale"
			Gale.Parent = OptionList
			Gale.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
			Gale.Position = UDim2.new(0.0231197979, 0, 0.0506699458, 0)
			Gale.Size = UDim2.new(0, 370, 0, 50)
			Gale.Font = Enum.Font.SourceSans
			Gale.Text = "Gale"
			Gale.TextColor3 = Color3.fromRGB(255, 255, 255)
			Gale.TextScaled = true
			Gale.TextSize = 14.000
			Gale.TextWrapped = true

			UICorner_5.Parent = Gale

			Among_Us.Name = "Among_Us"
			Among_Us.Parent = OptionList
			Among_Us.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
			Among_Us.Position = UDim2.new(0.0231197979, 0, 0.092793569, 0)
			Among_Us.Size = UDim2.new(0, 370, 0, 50)
			Among_Us.Font = Enum.Font.SourceSans
			Among_Us.Text = "Among us"
			Among_Us.TextColor3 = Color3.fromRGB(255, 255, 255)
			Among_Us.TextScaled = true
			Among_Us.TextSize = 14.000
			Among_Us.TextWrapped = true

			UICorner_6.Parent = Among_Us

			Killbot.Name = "Killbot"
			Killbot.Parent = OptionList
			Killbot.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
			Killbot.Position = UDim2.new(0.0231197979, 0, 0.1349172, 0)
			Killbot.Size = UDim2.new(0, 370, 0, 50)
			Killbot.Font = Enum.Font.SourceSans
			Killbot.Text = "Killbot"
			Killbot.TextColor3 = Color3.fromRGB(255, 255, 255)
			Killbot.TextScaled = true
			Killbot.TextSize = 14.000
			Killbot.TextWrapped = true

			UICorner_7.Parent = Killbot

			NekoMaid.Name = "NekoMaid"
			NekoMaid.Parent = OptionList
			NekoMaid.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
			NekoMaid.Position = UDim2.new(0.0231197979, 0, 0.177534401, 0)
			NekoMaid.Size = UDim2.new(0, 370, 0, 50)
			NekoMaid.Font = Enum.Font.SourceSans
			NekoMaid.Text = "Neko Maid"
			NekoMaid.TextColor3 = Color3.fromRGB(255, 255, 255)
			NekoMaid.TextScaled = true
			NekoMaid.TextSize = 14.000
			NekoMaid.TextWrapped = true

			UICorner_8.Parent = NekoMaid

			Smug.Name = "Smug"
			Smug.Parent = OptionList
			Smug.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
			Smug.Position = UDim2.new(0.0231197979, 0, 0.22079052, 0)
			Smug.Size = UDim2.new(0, 370, 0, 50)
			Smug.Font = Enum.Font.SourceSans
			Smug.Text = "Smug Dance V6"
			Smug.TextColor3 = Color3.fromRGB(255, 255, 255)
			Smug.TextScaled = true
			Smug.TextSize = 14.000
			Smug.TextWrapped = true

			UICorner_9.Parent = Smug

			ShadowBlade.Name = "ShadowBlade"
			ShadowBlade.Parent = OptionList
			ShadowBlade.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
			ShadowBlade.Position = UDim2.new(0.0231197979, 0, 0.263522238, 0)
			ShadowBlade.Size = UDim2.new(0, 370, 0, 50)
			ShadowBlade.Font = Enum.Font.SourceSans
			ShadowBlade.Text = "Shadow Blade"
			ShadowBlade.TextColor3 = Color3.fromRGB(255, 255, 255)
			ShadowBlade.TextScaled = true
			ShadowBlade.TextSize = 14.000
			ShadowBlade.TextWrapped = true

			UICorner_10.Parent = ShadowBlade

			SwordStand.Name = "SwordStand"
			SwordStand.Parent = OptionList
			SwordStand.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
			SwordStand.Position = UDim2.new(0.0231197979, 0, 0.304071069, 0)
			SwordStand.Size = UDim2.new(0, 370, 0, 50)
			SwordStand.Font = Enum.Font.SourceSans
			SwordStand.Text = "Sword Stand"
			SwordStand.TextColor3 = Color3.fromRGB(255, 255, 255)
			SwordStand.TextScaled = true
			SwordStand.TextSize = 14.000
			SwordStand.TextWrapped = true

			UICorner_11.Parent = SwordStand

			Neptunion.Name = "Neptunion"
			Neptunion.Parent = OptionList
			Neptunion.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
			Neptunion.Position = UDim2.new(0.0231197979, 0, 0.347187638, 0)
			Neptunion.Size = UDim2.new(0, 370, 0, 50)
			Neptunion.Font = Enum.Font.SourceSans
			Neptunion.Text = "Neptunion V"
			Neptunion.TextColor3 = Color3.fromRGB(255, 255, 255)
			Neptunion.TextScaled = true
			Neptunion.TextSize = 14.000
			Neptunion.TextWrapped = true

			UICorner_12.Parent = Neptunion

			RbNeptunion.Name = "RbNeptunion"
			RbNeptunion.Parent = OptionList
			RbNeptunion.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
			RbNeptunion.Position = UDim2.new(0.0231197979, 0, 0.390972137, 0)
			RbNeptunion.Size = UDim2.new(0, 370, 0, 50)
			RbNeptunion.Font = Enum.Font.SourceSans
			RbNeptunion.Text = "RB Neptunion"
			RbNeptunion.TextColor3 = Color3.fromRGB(255, 255, 255)
			RbNeptunion.TextScaled = true
			RbNeptunion.TextSize = 14.000
			RbNeptunion.TextWrapped = true

			UICorner_13.Parent = RbNeptunion

			Wall.Name = "Wall"
			Wall.Parent = OptionList
			Wall.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
			Wall.Position = UDim2.new(0.0231197979, 0, 0.434192657, 0)
			Wall.Size = UDim2.new(0, 370, 0, 50)
			Wall.Font = Enum.Font.SourceSans
			Wall.Text = "Wall"
			Wall.TextColor3 = Color3.fromRGB(255, 255, 255)
			Wall.TextScaled = true
			Wall.TextSize = 14.000
			Wall.TextWrapped = true

			UICorner_14.Parent = Wall

			achroGlicher.Name = "achroGlicher"
			achroGlicher.Parent = OptionList
			achroGlicher.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
			achroGlicher.Position = UDim2.new(0.0231197979, 0, 0.47801882, 0)
			achroGlicher.Size = UDim2.new(0, 370, 0, 50)
			achroGlicher.Font = Enum.Font.SourceSans
			achroGlicher.Text = "Achromatic Glicher"
			achroGlicher.TextColor3 = Color3.fromRGB(255, 255, 255)
			achroGlicher.TextScaled = true
			achroGlicher.TextSize = 14.000
			achroGlicher.TextWrapped = true

			UICorner_15.Parent = achroGlicher

			FlamingCube.Name = "FlamingCube"
			FlamingCube.Parent = OptionList
			FlamingCube.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
			FlamingCube.Position = UDim2.new(0.0231197979, 0, 0.521497488, 0)
			FlamingCube.Size = UDim2.new(0, 370, 0, 50)
			FlamingCube.Font = Enum.Font.SourceSans
			FlamingCube.Text = "Flaming Cube"
			FlamingCube.TextColor3 = Color3.fromRGB(255, 255, 255)
			FlamingCube.TextScaled = true
			FlamingCube.TextSize = 14.000
			FlamingCube.TextWrapped = true

			UICorner_16.Parent = FlamingCube

			Spider.Name = "Spider"
			Spider.Parent = OptionList
			Spider.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
			Spider.Position = UDim2.new(0.0231197979, 0, 0.564180851, 0)
			Spider.Size = UDim2.new(0, 370, 0, 50)
			Spider.Font = Enum.Font.SourceSans
			Spider.Text = "Spider"
			Spider.TextColor3 = Color3.fromRGB(255, 255, 255)
			Spider.TextScaled = true
			Spider.TextSize = 14.000
			Spider.TextWrapped = true

			UICorner_17.Parent = Spider

			Cop.Name = "Cop"
			Cop.Parent = OptionList
			Cop.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
			Cop.Position = UDim2.new(0.0231197979, 0, 0.606966078, 0)
			Cop.Size = UDim2.new(0, 370, 0, 50)
			Cop.Font = Enum.Font.SourceSans
			Cop.Text = "Cop"
			Cop.TextColor3 = Color3.fromRGB(255, 255, 255)
			Cop.TextScaled = true
			Cop.TextSize = 14.000
			Cop.TextWrapped = true

			UICorner_18.Parent = Cop

			Chips.Name = "Chips"
			Chips.Parent = OptionList
			Chips.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
			Chips.Position = UDim2.new(0.0231197979, 0, 0.649766564, 0)
			Chips.Size = UDim2.new(0, 370, 0, 50)
			Chips.Font = Enum.Font.SourceSans
			Chips.Text = "Chips"
			Chips.TextColor3 = Color3.fromRGB(255, 255, 255)
			Chips.TextScaled = true
			Chips.TextSize = 14.000
			Chips.TextWrapped = true

			UICorner_19.Parent = Chips

			Joy.Name = "Joy"
			Joy.Parent = OptionList
			Joy.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
			Joy.Position = UDim2.new(0.0231197979, 0, 0.69195044, 0)
			Joy.Size = UDim2.new(0, 370, 0, 50)
			Joy.Font = Enum.Font.SourceSans
			Joy.Text = ":Joy:"
			Joy.TextColor3 = Color3.fromRGB(255, 255, 255)
			Joy.TextScaled = true
			Joy.TextSize = 14.000
			Joy.TextWrapped = true

			UICorner_20.Parent = Joy

			UMD.Name = "UMD"
			UMD.Parent = OptionList
			UMD.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
			UMD.Position = UDim2.new(0.0231197979, 0, 0.732523978, 0)
			UMD.Size = UDim2.new(0, 370, 0, 50)
			UMD.Font = Enum.Font.SourceSans
			UMD.Text = "Ultimate meme dance"
			UMD.TextColor3 = Color3.fromRGB(255, 255, 255)
			UMD.TextScaled = true
			UMD.TextSize = 14.000
			UMD.TextWrapped = true

			UICorner_21.Parent = UMD

			Chill.Name = "Chill"
			Chill.Parent = OptionList
			Chill.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
			Chill.Position = UDim2.new(0.0231197979, 0, 0.772394419, 0)
			Chill.Size = UDim2.new(0, 370, 0, 50)
			Chill.Font = Enum.Font.SourceSans
			Chill.Text = "Chill"
			Chill.TextColor3 = Color3.fromRGB(255, 255, 255)
			Chill.TextScaled = true
			Chill.TextSize = 14.000
			Chill.TextWrapped = true

			UICorner_22.Parent = Chill

			Grapple.Name = "Grapple"
			Grapple.Parent = OptionList
			Grapple.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
			Grapple.Position = UDim2.new(0.0231197979, 0, 0.815179646, 0)
			Grapple.Size = UDim2.new(0, 370, 0, 50)
			Grapple.Font = Enum.Font.SourceSans
			Grapple.Text = "Grapple"
			Grapple.TextColor3 = Color3.fromRGB(255, 255, 255)
			Grapple.TextScaled = true
			Grapple.TextSize = 14.000
			Grapple.TextWrapped = true

			UICorner_23.Parent = Grapple

			ServerAdmin.Name = "ServerAdmin"
			ServerAdmin.Parent = OptionList
			ServerAdmin.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
			ServerAdmin.Position = UDim2.new(0.0231197979, 0, 0.858780205, 0)
			ServerAdmin.Size = UDim2.new(0, 370, 0, 50)
			ServerAdmin.Font = Enum.Font.SourceSans
			ServerAdmin.Text = "Server Admin"
			ServerAdmin.TextColor3 = Color3.fromRGB(255, 255, 255)
			ServerAdmin.TextScaled = true
			ServerAdmin.TextSize = 14.000
			ServerAdmin.TextWrapped = true

			UICorner_24.Parent = ServerAdmin

			Ender.Name = "Ender"
			Ender.Parent = OptionList
			Ender.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
			Ender.Position = UDim2.new(0.0231197979, 0, 0.902380705, 0)
			Ender.Size = UDim2.new(0, 370, 0, 50)
			Ender.Font = Enum.Font.SourceSans
			Ender.Text = "Ender"
			Ender.TextColor3 = Color3.fromRGB(255, 255, 255)
			Ender.TextScaled = true
			Ender.TextSize = 14.000
			Ender.TextWrapped = true

			UICorner_25.Parent = Ender

			Ban.Name = "Ban"
			Ban.Parent = OptionList
			Ban.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
			Ban.Position = UDim2.new(0.0231197979, 0, 0.945981264, 0)
			Ban.Size = UDim2.new(0, 370, 0, 50)
			Ban.Font = Enum.Font.SourceSans
			Ban.Text = "Ban Hammer"
			Ban.TextColor3 = Color3.fromRGB(255, 255, 255)
			Ban.TextScaled = true
			Ban.TextSize = 14.000
			Ban.TextWrapped = true

			UICorner_26.Parent = Ban

			Netless.Name = "Netless"
			Netless.Parent = Main
			Netless.BackgroundColor3 = Color3.fromRGB(77, 156, 115)
			Netless.BorderSizePixel = 0
			Netless.Position = UDim2.new(0.51807934, 0, 0.868913829, 0)
			Netless.Size = UDim2.new(0, 195, 0, 57)
			Netless.ZIndex = 2
			Netless.Font = Enum.Font.GothamSemibold
			Netless.Text = ""
			Netless.TextColor3 = Color3.fromRGB(255, 255, 255)
			Netless.TextScaled = true
			Netless.TextSize = 14.000
			Netless.TextWrapped = true

			UICorner_27.Parent = Netless

			Shadow.Name = "Shadow"
			Shadow.Parent = Netless
			Shadow.BackgroundColor3 = Color3.fromRGB(58, 118, 86)
			Shadow.BorderSizePixel = 0
			Shadow.Size = UDim2.new(1, 0, 1, 4)

			UICorner_28.Parent = Shadow

			TextLabel.Parent = Netless
			TextLabel.AnchorPoint = Vector2.new(0.5, 0.5)
			TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			TextLabel.BackgroundTransparency = 1.000
			TextLabel.BorderColor3 = Color3.fromRGB(27, 42, 53)
			TextLabel.BorderSizePixel = 0
			TextLabel.Position = UDim2.new(0.5, 0, 0.49999997, 0)
			TextLabel.Size = UDim2.new(1, -20, 1, -20)
			TextLabel.ZIndex = 2
			TextLabel.Font = Enum.Font.GothamSemibold
			TextLabel.Text = "Netless (Use AFTER any scripts)"
			TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
			TextLabel.TextScaled = true
			TextLabel.TextSize = 14.000
			TextLabel.TextWrapped = true

			AntiReport.Name = "AntiReport"
			AntiReport.Parent = Main
			AntiReport.BackgroundColor3 = Color3.fromRGB(77, 156, 115)
			AntiReport.BorderSizePixel = 0
			AntiReport.Position = UDim2.new(0.0489794947, 0, 0.868913829, 0)
			AntiReport.Size = UDim2.new(0, 197, 0, 57)
			AntiReport.ZIndex = 2
			AntiReport.Font = Enum.Font.GothamSemibold
			AntiReport.Text = ""
			AntiReport.TextColor3 = Color3.fromRGB(255, 255, 255)
			AntiReport.TextScaled = true
			AntiReport.TextSize = 14.000
			AntiReport.TextWrapped = true

			UICorner_29.Parent = AntiReport

			Shadow_2.Name = "Shadow"
			Shadow_2.Parent = AntiReport
			Shadow_2.BackgroundColor3 = Color3.fromRGB(58, 118, 86)
			Shadow_2.BorderSizePixel = 0
			Shadow_2.Size = UDim2.new(1, 0, 1, 4)

			UICorner_30.Parent = Shadow_2

			TextLabel_2.Parent = AntiReport
			TextLabel_2.AnchorPoint = Vector2.new(0.5, 0.5)
			TextLabel_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			TextLabel_2.BackgroundTransparency = 1.000
			TextLabel_2.BorderColor3 = Color3.fromRGB(27, 42, 53)
			TextLabel_2.BorderSizePixel = 0
			TextLabel_2.Position = UDim2.new(0.5, 0, 0.5, 0)
			TextLabel_2.Size = UDim2.new(1, -20, 1, -20)
			TextLabel_2.ZIndex = 2
			TextLabel_2.Font = Enum.Font.GothamSemibold
			TextLabel_2.Text = "AntiReport"
			TextLabel_2.TextColor3 = Color3.fromRGB(255, 255, 255)
			TextLabel_2.TextScaled = true
			TextLabel_2.TextSize = 14.000
			TextLabel_2.TextWrapped = true

			X.Name = "X"
			X.Parent = Main
			X.BackgroundColor3 = Color3.fromRGB(251, 98, 92)
			X.BorderSizePixel = 0
			X.Position = UDim2.new(0.927937925, 0, -0.0262172297, 0)
			X.Size = UDim2.new(0, 47, 0, 45)
			X.ZIndex = 2
			X.Font = Enum.Font.GothamSemibold
			X.Text = "X"
			X.TextColor3 = Color3.fromRGB(255, 255, 255)
			X.TextSize = 32.000
			X.TextWrapped = true

			UICorner_31.CornerRadius = UDim.new(1, 0)
			UICorner_31.Parent = X

			OpenUTG.Name = "OpenUTG"
			OpenUTG.Parent = UTG_V2
			OpenUTG.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			OpenUTG.BackgroundTransparency = 1.000
			OpenUTG.Position = UDim2.new(0.79603678, 0, 0.698529005, 0)
			OpenUTG.Size = UDim2.new(0, 165, 0, 62)
			OpenUTG.Visible = false
			OpenUTG.Font = Enum.Font.SourceSans
			OpenUTG.Text = "Open UTG"
			OpenUTG.TextColor3 = Color3.fromRGB(255, 255, 255)
			OpenUTG.TextScaled = true
			OpenUTG.TextSize = 14.000
			OpenUTG.TextWrapped = true

			-- Scripts:

			local function MBUQEV_fake_script() -- Main.DraggableScript 
				local script = Instance.new('LocalScript', Main)

				local UIS = game:GetService('UserInputService')
				local frame = script.Parent
				local dragToggle = nil
				local dragSpeed = 0.25
				local dragStart = nil
				local startPos = nil

				local function updateInput(input)
					local delta = input.Position - dragStart
					local position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X,
						startPos.Y.Scale, startPos.Y.Offset + delta.Y)
					game:GetService('TweenService'):Create(frame, TweenInfo.new(dragSpeed), {Position = position}):Play()
				end

				frame.InputBegan:Connect(function(input)
					if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) then 
						dragToggle = true
						dragStart = input.Position
						startPos = frame.Position
						input.Changed:Connect(function()
							if input.UserInputState == Enum.UserInputState.End then
								dragToggle = false
							end
						end)
					end
				end)

				UIS.InputChanged:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
						if dragToggle then
							updateInput(input)
						end
					end
				end)

			end
			coroutine.wrap(MBUQEV_fake_script)()
			local function NWAVVF_fake_script() -- Netless.NetlessScript 
				local script = Instance.new('LocalScript', Netless)

				script.Parent.MouseButton1Click:Connect(function()
					for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
						if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then 
							game:GetService("RunService").Heartbeat:connect(function()
								v.Velocity = Vector3.new(0,35,0)
								wait(0.5)
							end)
						end
					end

					game:GetService("StarterGui"):SetCore("SendNotification", { 
						Title = "Notification";
						Text = "Netless activated";
						Icon = "rbxthumb://type=Asset&id=5107182114&w=150&h=150"})
					Duration = 16;
				end)
			end
			coroutine.wrap(NWAVVF_fake_script)()
			local function KZZCO_fake_script() -- OpenUTG.OpenUTGScript 
				local script = Instance.new('LocalScript', OpenUTG)

				script.Parent.MouseButton1Click:Connect(function()
					script.Parent.Parent.Main.Visible = true
					script.Parent.Visible = false
				end)
			end
			coroutine.wrap(KZZCO_fake_script)()

			AntiReport.MouseButton1Click:Connect(function()
				setfflag("AbuseReportScreenshotPercentage", 0)
				setfflag("DFFlagAbuseReportScreenshot", "False")
				print("Anti-Report loaded")
			end)

			Among_Us.MouseButton1Click:Connect(function()
				loadstring(game:HttpGet("https://pastebin.com/raw/JXUMavf3", true))()
			end)

			Ban.MouseButton1Click:Connect(function()
				loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/killermaster9999mega/thing/main/README.md"))()
			end)

			Chill.MouseButton1Click:Connect(function()
				loadstring(game:HttpGetAsync("https://pastebin.com/raw/XmHFdTij"))()
			end)

			Chips.MouseButton1Click:Connect(function()
				loadstring(game:HttpGetAsync("https://pastebin.com/raw/b289ts36"))()
			end)

			Cop.MouseButton1Click:Connect(function()
				loadstring(game:HttpGetAsync("https://pastebin.com/raw/VAA5Mf60"))()
			end)

			Ender.MouseButton1Click:Connect(function()
				loadstring(game:HttpGetAsync("https://pastebin.com/raw/bndCgupK"))()
			end)

			FlamingCube.MouseButton1Click:Connect(function()
				loadstring(game:HttpGet("https://pastebin.com/raw/D7pigANg"))()
			end)

			Gale.MouseButton1Click:Connect(function()
				loadstring(game:HttpGet(("https://pastebin.com/raw/PjJNLaFa"), true))()
			end)

			Grapple.MouseButton1Click:Connect(function()
				loadstring(game:HttpGetAsync("https://pastebin.com/raw/AyASkDEG"))()
			end)

			Joy.MouseButton1Click:Connect(function()
				loadstring(game:HttpGetAsync("https://pastebin.com/raw/LEAQuKj0"))()
			end)

			Killbot.MouseButton1Click:Connect(function()
				loadstring(game:HttpGetAsync("https://pastebin.com/raw/G24tcRXA"))()
			end)

			NekoMaid.MouseButton1Click:Connect(function()
				loadstring(game:HttpGetAsync("https://paste.ee/d/6bCwm/0"))()
			end)

			Neptunion.MouseButton1Click:Connect(function()
				loadstring(game:HttpGetAsync("https://pastebin.com/raw/t0Mkc33N"))()
			end)

			RbNeptunion.MouseButton1Click:Connect(function()
				loadstring(game:HttpGetAsync("https://pastebin.com/raw/gDi503fB"))()
			end)

			ServerAdmin.MouseButton1Click:Connect(function()
				loadstring(game:HttpGet("https://raw.githubusercontent.com/ONEReverseCard/My-Scripts/main/Netless%20Server%20Admin.md"))()
			end)

			ShadowBlade.MouseButton1Click:Connect(function()
				loadstring(game:HttpGetAsync("https://pastebin.com/raw/kMYThpNG"))()
			end)

			Smug.MouseButton1Click:Connect(function()
				loadstring(game:HttpGetAsync("https://pastebin.com/raw/ZuKy7HFF"))()
			end)

			Sonic.MouseButton1Click:Connect(function()
				loadstring(game:HttpGetAsync("https://pastebin.com/raw/SyF5t70A"))()
			end)

			Spider.MouseButton1Click:Connect(function()
				loadstring(game:HttpGetAsync("https://pastebin.com/raw/txsk1LJg"))()
			end)

			SwordStand.MouseButton1Click:Connect(function()
				loadstring(game:HttpGetAsync("https://paste.ee/r/NwGVX/0"))()
			end)

			UMD.MouseButton1Click:Connect(function()
				loadstring(game:HttpGetAsync("https://pastebin.com/raw/0QfjMKrF"))()
			end)

			Wall.MouseButton1Click:Connect(function()
				loadstring(game:HttpGetAsync("https://pastebin.com/raw/AY6kA2AV"))()
			end)

			achroGlicher.MouseButton1Click:Connect(function()
				loadstring(game:HttpGetAsync("https://pastebin.com/raw/T7cmny7C"))()
			end)
		end)

		UICorner_5.Parent = feutgv2

		radio1.Name = "radio1"
		radio1.Parent = Page1
		radio1.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		radio1.Position = UDim2.new(0.75999999, 10, 1.57500005, -280)
		radio1.Size = UDim2.new(0, 110, 0, 48)
		radio1.ZIndex = 7
		radio1.Font = Enum.Font.SourceSansBold
		radio1.Text = "Radio 1"
		radio1.TextColor3 = Color3.fromRGB(61, 61, 61)
		radio1.TextSize = 18.000
		radio1.TextWrapped = true
		radio1.MouseButton1Click:Connect(function()
			loadstring(game:HttpGetAsync("https://paste.ee/r/F5d4Y"))()
		end)

		UICorner_6.Parent = radio1

		radio2.Name = "radio2"
		radio2.Parent = Page1
		radio2.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		radio2.Position = UDim2.new(0.75999999, 10, 1.27499998, -280)
		radio2.Size = UDim2.new(0, 110, 0, 48)
		radio2.ZIndex = 7
		radio2.Font = Enum.Font.SourceSansBold
		radio2.Text = "Radio 2"
		radio2.TextColor3 = Color3.fromRGB(61, 61, 61)
		radio2.TextSize = 18.000
		radio2.TextWrapped = true
		radio2.MouseButton1Click:Connect(function()
			loadstring(game:HttpGetAsync("https://paste.ee/r/vtC71"))()
		end)

		UICorner_7.Parent = radio2

		SpectrumGlitcher.Name = "SpectrumGlitcher"
		SpectrumGlitcher.Parent = Page1
		SpectrumGlitcher.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		SpectrumGlitcher.Position = UDim2.new(0.254999995, 10, 1.58037639, -280)
		SpectrumGlitcher.Size = UDim2.new(0, 110, 0, 48)
		SpectrumGlitcher.ZIndex = 7
		SpectrumGlitcher.Font = Enum.Font.SourceSansBold
		SpectrumGlitcher.Text = "Spectrum Glitcher"
		SpectrumGlitcher.TextColor3 = Color3.fromRGB(61, 61, 61)
		SpectrumGlitcher.TextSize = 18.000
		SpectrumGlitcher.TextWrapped = true
		SpectrumGlitcher.MouseButton1Click:Connect(function()
			loadstring("\108\111\97\100\115\116\114\105\110\103\40\103\97\109\101\58\72\116\116\112\71\101\116\65\115\121\110\99\40\34\104\116\116\112\115\58\47\47\112\97\115\116\101\46\101\101\47\114\47\101\103\112\71\100\47\48\34\41\41\40\41\10")()
		end)

		UICorner_8.Parent = SpectrumGlitcher

		TypicalHub.Name = "TypicalHub"
		TypicalHub.Parent = Page1
		TypicalHub.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		TypicalHub.Position = UDim2.new(0.501999974, 10, 1.57500005, -280)
		TypicalHub.Size = UDim2.new(0, 110, 0, 48)
		TypicalHub.ZIndex = 7
		TypicalHub.Font = Enum.Font.SourceSansBold
		TypicalHub.Text = "Typical Hub"
		TypicalHub.TextColor3 = Color3.fromRGB(61, 61, 61)
		TypicalHub.TextSize = 18.000
		TypicalHub.TextWrapped = true
		TypicalHub.MouseButton1Click:Connect(function()
			loadstring(game:HttpGet("https://raw.githubusercontent.com/mgamingpro/TypicalHub/main/source", true))()
		end)

		UICorner_9.Parent = TypicalHub

		GravityPuller.Name = "GravityPuller"
		GravityPuller.Parent = Page1
		GravityPuller.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		GravityPuller.Position = UDim2.new(0.254999995, 10, 1.27499998, -280)
		GravityPuller.Size = UDim2.new(0, 110, 0, 48)
		GravityPuller.ZIndex = 7
		GravityPuller.Font = Enum.Font.SourceSansBold
		GravityPuller.Text = "Gravity Puller"
		GravityPuller.TextColor3 = Color3.fromRGB(61, 61, 61)
		GravityPuller.TextSize = 18.000
		GravityPuller.TextWrapped = true
		GravityPuller.MouseButton1Click:connect(function() -- gravity puller script
			function sandbox(var,func)
				local env = getfenv(func)
				local newenv = setmetatable({},{
					__index = function(self,k)
						if k=="script" then
							return var
						else
							return env[k]
						end
					end,
				})
				setfenv(func,newenv)
				return func
			end
			cors = {}
			mas = Instance.new("Model",game:GetService("Lighting"))
			Tool0 = Instance.new("Tool")
			Part1 = Instance.new("Part")
			CylinderMesh2 = Instance.new("CylinderMesh")
			Part3 = Instance.new("Part")
			LocalScript4 = Instance.new("LocalScript")
			Script5 = Instance.new("Script")
			LocalScript6 = Instance.new("LocalScript")
			Script7 = Instance.new("Script")
			LocalScript8 = Instance.new("LocalScript")
			Part9 = Instance.new("Part")
			Script10 = Instance.new("Script")
			Part11 = Instance.new("Part")
			Script12 = Instance.new("Script")
			Part13 = Instance.new("Part")
			Script14 = Instance.new("Script")
			Tool0.Name = "Gay Puller By FO10"
			Tool0.Parent = mas
			Tool0.CanBeDropped = false
			Part1.Name = "Handle"
			Part1.Parent = Tool0
			Part1.Material = Enum.Material.Neon
			Part1.BrickColor = BrickColor.new("Cyan")
			Part1.Transparency = 1
			Part1.Rotation = Vector3.new(0, 15.4200001, 0)
			Part1.CanCollide = false
			Part1.FormFactor = Enum.FormFactor.Custom
			Part1.Size = Vector3.new(1, 0.400000036, 0.300000012)
			Part1.CFrame = CFrame.new(-55.2695465, 0.696546972, 0.383156985, 0.96399641, -4.98074878e-05, 0.265921414, 4.79998416e-05, 1, 1.32960558e-05, -0.265921414, -5.30653779e-08, 0.96399641)
			Part1.BottomSurface = Enum.SurfaceType.Smooth
			Part1.TopSurface = Enum.SurfaceType.Smooth
			Part1.Color = Color3.new(0.0156863, 0.686275, 0.92549)
			Part1.Position = Vector3.new(-55.2695465, 0.696546972, 0.383156985)
			Part1.Orientation = Vector3.new(0, 15.4200001, 0)
			Part1.Color = Color3.new(0.0156863, 0.686275, 0.92549)
			CylinderMesh2.Parent = Part1
			CylinderMesh2.Scale = Vector3.new(0.100000001, 0.100000001, 0.100000001)
			CylinderMesh2.Scale = Vector3.new(0.100000001, 0.100000001, 0.100000001)
			Part3.Name = "Shoot"
			Part3.Parent = Tool0
			Part3.Material = Enum.Material.Neon
			Part3.BrickColor = BrickColor.new("Cyan")
			Part3.Reflectance = 0.30000001192093
			Part3.Transparency = 1
			Part3.Rotation = Vector3.new(90.9799957, 0.25999999, -91.409996)
			Part3.CanCollide = false
			Part3.FormFactor = Enum.FormFactor.Custom
			Part3.Size = Vector3.new(0.200000003, 0.25, 0.310000032)
			Part3.CFrame = CFrame.new(-54.7998123, 0.774299085, -0.757350147, -0.0245519895, 0.99968797, 0.00460194098, 0.0169109926, 0.00501798885, -0.999844491, -0.999555528, -0.0244703442, -0.0170289185)
			Part3.BottomSurface = Enum.SurfaceType.Smooth
			Part3.TopSurface = Enum.SurfaceType.Smooth
			Part3.Color = Color3.new(0.0156863, 0.686275, 0.92549)
			Part3.Position = Vector3.new(-54.7998123, 0.774299085, -0.757350147)
			Part3.Orientation = Vector3.new(88.9899979, 164.87999, 73.4700012)
			Part3.Color = Color3.new(0.0156863, 0.686275, 0.92549)
			LocalScript4.Parent = Tool0
			table.insert(cors,sandbox(LocalScript4,function()
				-- Variables for services
				local render = game:GetService("RunService").RenderStepped
				local contextActionService = game:GetService("ContextActionService")
				local userInputService = game:GetService("UserInputService")

				local player = game.Players.LocalPlayer
				local mouse = player:GetMouse()
				local Tool = script.Parent

				-- Variables for Module Scripts
				local screenSpace = require(Tool:WaitForChild("ScreenSpace"))

				local connection
				-- Variables for character joints

				local neck, shoulder, oldNeckC0, oldShoulderC0 

				local mobileShouldTrack = true

				-- Thourough check to see if a character is sitting
				local function amISitting(character)
					local t = character.Torso
					for _, part in pairs(t:GetConnectedParts(true)) do
						if part:IsA("Seat") or part:IsA("VehicleSeat") then
							return true
						end
					end
				end

				-- Function to call on renderstepped. Orients the character so it is facing towards
				-- the player mouse's position in world space. If character is sitting then the torso
				-- should not track
				local function frame(mousePosition)
					-- Special mobile consideration. We don't want to track if the user was touching a ui
					-- element such as the movement controls. Just return out of function if so to make sure
					-- character doesn't track
					if not mobileShouldTrack then return end

					-- Make sure character isn't swiming. If the character is swimming the following code will
					-- not work well; the character will not swim correctly. Besides, who shoots underwater?
					if player.Character.Humanoid:GetState() ~= Enum.HumanoidStateType.Swimming then
						local torso = player.Character.Torso
						local head = player.Character.Head

						local toMouse = (mousePosition - head.Position).unit
						local angle = math.acos(toMouse:Dot(Vector3.new(0,1,0)))

						local neckAngle = angle

						-- Limit how much the head can tilt down. Too far and the head looks unnatural
						if math.deg(neckAngle) > 110 then
							neckAngle = math.rad(110)
						end
						neck.C0 = CFrame.new(0,1,0) * CFrame.Angles(math.pi - neckAngle,math.pi,0)

						-- Calculate horizontal rotation
						local arm = player.Character:FindFirstChild("Right Arm")
						local fromArmPos = torso.Position + torso.CFrame:vectorToWorldSpace(Vector3.new(
							torso.Size.X/2 + arm.Size.X/2, torso.Size.Y/2 - arm.Size.Z/2, 0))
						local toMouseArm = ((mousePosition - fromArmPos) * Vector3.new(1,0,1)).unit
						local look = (torso.CFrame.lookVector * Vector3.new(1,0,1)).unit
						local lateralAngle = math.acos(toMouseArm:Dot(look))		

						-- Check for rogue math
						if tostring(lateralAngle) == "-1.#IND" then
							lateralAngle = 0
						end		

						-- Handle case where character is sitting down
						if player.Character.Humanoid:GetState() == Enum.HumanoidStateType.Seated then			

							local cross = torso.CFrame.lookVector:Cross(toMouseArm)
							if lateralAngle > math.pi/2 then
								lateralAngle = math.pi/2
							end
							if cross.Y < 0 then
								lateralAngle = -lateralAngle
							end
						end	

						-- Turn shoulder to point to mouse
						shoulder.C0 = CFrame.new(1,0.5,0) * CFrame.Angles(math.pi/2 - angle,math.pi/2 + lateralAngle,0)	

						-- If not sitting then aim torso laterally towards mouse
						if not amISitting(player.Character) then
							torso.CFrame = CFrame.new(torso.Position, torso.Position + (Vector3.new(
								mousePosition.X, torso.Position.Y, mousePosition.Z)-torso.Position).unit)
						else
							--print("sitting")		
						end	
					end
				end

				-- Function to bind to render stepped if player is on PC
				local function pcFrame()
					frame(mouse.Hit.p)
				end

				-- Function to bind to touch moved if player is on mobile
				local function mobileFrame(touch, processed)
					-- Check to see if the touch was on a UI element. If so, we don't want to update anything
					if not processed then
						-- Calculate touch position in world space. Uses Stravant's ScreenSpace Module script
						-- to create a ray from the camera.
						local test = screenSpace.ScreenToWorld(touch.Position.X, touch.Position.Y, 1)
						local nearPos = game.Workspace.CurrentCamera.CoordinateFrame:vectorToWorldSpace(screenSpace.ScreenToWorld(touch.Position.X, touch.Position.Y, 1))
						nearPos = game.Workspace.CurrentCamera.CoordinateFrame.p - nearPos
						local farPos = screenSpace.ScreenToWorld(touch.Position.X, touch.Position.Y,50) 
						farPos = game.Workspace.CurrentCamera.CoordinateFrame:vectorToWorldSpace(farPos) * -1
						if farPos.magnitude > 900 then
							farPos = farPos.unit * 900
						end
						local ray = Ray.new(nearPos, farPos)
						local part, pos = game.Workspace:FindPartOnRay(ray, player.Character)

						-- if a position was found on the ray then update the character's rotation
						if pos then
							frame(pos)
						end
					end
				end

				local oldIcon = nil
				-- Function to bind to equip event
				local function equip()
					local torso = player.Character.Torso

					-- Setup joint variables
					neck = torso.Neck	
					oldNeckC0 = neck.C0
					shoulder = torso:FindFirstChild("Right Shoulder")
					oldShoulderC0 = shoulder.C0

					-- Remember old mouse icon and update current
					oldIcon = mouse.Icon
					mouse.Icon = "rbxassetid:// 2184939409"

					-- Bind TouchMoved event if on mobile. Otherwise connect to renderstepped
					if userInputService.TouchEnabled then
						connection = userInputService.TouchMoved:connect(mobileFrame)
					else
						connection = render:connect(pcFrame)
					end

					-- Bind TouchStarted and TouchEnded. Used to determine if character should rotate
					-- during touch input
					userInputService.TouchStarted:connect(function(touch, processed)
						mobileShouldTrack = not processed
					end)	
					userInputService.TouchEnded:connect(function(touch, processed)
						mobileShouldTrack = false
					end)

					-- Fire server's equip event
					game.ReplicatedStorage.ROBLOX_PistolEquipEvent:FireServer()

					-- Bind event for when mouse is clicked to fire server's fire event
					mouse.Button1Down:connect(function()
						game.ReplicatedStorage.ROBLOX_PistolFireEvent:FireServer(mouse.Hit.p)
					end)

					-- Bind reload event to mobile button and r key
					contextActionService:BindActionToInputTypes("Reload", function() 
						game.ReplicatedStorage.ROBLOX_PistolReloadEvent:FireServer()		
					end, true, "")

					-- If game uses filtering enabled then need to update server while tool is
					-- held by character.
					if workspace.FilteringEnabled then
						while connection do
							wait()
							game.ReplicatedStorage.ROBLOX_PistolUpdateEvent:FireServer(neck.C0, shoulder.C0)
						end
					end
				end

				-- Function to bind to Unequip event
				local function unequip()
					if connection then connection:disconnect() end
					contextActionService:UnbindAction("Reload")
					game.ReplicatedStorage.ROBLOX_PistolUnequipEvent:FireServer()
					mouse.Icon = oldIcon
					neck.C0 = oldNeckC0
					shoulder.C0 = oldShoulderC0
				end

				-- Bind tool events
				Tool.Equipped:connect(equip)
				Tool.Unequipped:connect(unequip)
			end))
			Script5.Name = "qPerfectionWeld"
			Script5.Parent = Tool0
			table.insert(cors,sandbox(Script5,function()
				-- Created by Quenty (@Quenty, follow me on twitter).
				-- Should work with only ONE copy, seamlessly with weapons, trains, et cetera.
				-- Parts should be ANCHORED before use. It will, however, store relatives values and so when tools are reparented, it'll fix them.

--[[ INSTRUCTIONS
- Place in the model
- Make sure model is anchored
- That's it. It will weld the model and all children. 

THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 

This script is designed to be used is a regular script. In a local script it will weld, but it will not attempt to handle ancestory changes. 
]]

--[[ DOCUMENTATION
- Will work in tools. If ran more than once it will not create more than one weld.  This is especially useful for tools that are dropped and then picked up again.
- Will work in PBS servers
- Will work as long as it starts out with the part anchored
- Stores the relative CFrame as a CFrame value
- Takes careful measure to reduce lag by not having a joint set off or affected by the parts offset from origin
- Utilizes a recursive algorith to find all parts in the model
- Will reweld on script reparent if the script is initially parented to a tool.
- Welds as fast as possible
]]

				-- qPerfectionWeld.lua
				-- Created 10/6/2014
				-- Author: Quenty
				-- Version 1.0.3

				-- Updated 10/14/2014 - Updated to 1.0.1
				--- Bug fix with existing ROBLOX welds ? Repro by asimo3089

				-- Updated 10/14/2014 - Updated to 1.0.2
				--- Fixed bug fix. 

				-- Updated 10/14/2014 - Updated to 1.0.3
				--- Now handles joints semi-acceptably. May be rather hacky with some joints. :/

				local NEVER_BREAK_JOINTS = false -- If you set this to true it will never break joints (this can create some welding issues, but can save stuff like hinges).


				local function CallOnChildren(Instance, FunctionToCall)
					-- Calls a function on each of the children of a certain object, using recursion.  

					FunctionToCall(Instance)

					for _, Child in next, Instance:GetChildren() do
						CallOnChildren(Child, FunctionToCall)
					end
				end

				local function GetNearestParent(Instance, ClassName)
					-- Returns the nearest parent of a certain class, or returns nil

					local Ancestor = Instance
					repeat
						Ancestor = Ancestor.Parent
						if Ancestor == nil then
							return nil
						end
					until Ancestor:IsA(ClassName)

					return Ancestor
				end

				local function GetBricks(StartInstance)
					local List = {}

					-- if StartInstance:IsA("BasePart") then
					-- 	List[#List+1] = StartInstance
					-- end

					CallOnChildren(StartInstance, function(Item)
						if Item:IsA("BasePart") then
							List[#List+1] = Item;
						end
					end)

					return List
				end

				local function Modify(Instance, Values)
					-- Modifies an Instance by using a table.  

					assert(type(Values) == "table", "Values is not a table");

					for Index, Value in next, Values do
						if type(Index) == "number" then
							Value.Parent = Instance
						else
							Instance[Index] = Value
						end
					end
					return Instance
				end

				local function Make(ClassType, Properties)
					-- Using a syntax hack to create a nice way to Make new items.  

					return Modify(Instance.new(ClassType), Properties)
				end

				local Surfaces = {"TopSurface", "BottomSurface", "LeftSurface", "RightSurface", "FrontSurface", "BackSurface"}
				local HingSurfaces = {"Hinge", "Motor", "SteppingMotor"}

				local function HasWheelJoint(Part)
					for _, SurfaceName in pairs(Surfaces) do
						for _, HingSurfaceName in pairs(HingSurfaces) do
							if Part[SurfaceName].Name == HingSurfaceName then
								return true
							end
						end
					end

					return false
				end

				local function ShouldBreakJoints(Part)
					--- We do not want to break joints of wheels/hinges. This takes the utmost care to not do this. There are
					--  definitely some edge cases. 

					if NEVER_BREAK_JOINTS then
						return false
					end

					if HasWheelJoint(Part) then
						return false
					end

					local Connected = Part:GetConnectedParts()

					if #Connected == 1 then
						return false
					end

					for _, Item in pairs(Connected) do
						if HasWheelJoint(Item) then
							return false
						elseif not Item:IsDescendantOf(script.Parent) then
							return false
						end
					end

					return true
				end

				local function WeldTogether(Part0, Part1, JointType, WeldParent)
					--- Weld's 2 parts together
					-- @param Part0 The first part
					-- @param Part1 The second part (Dependent part most of the time).
					-- @param [JointType] The type of joint. Defaults to weld.
					-- @param [WeldParent] Parent of the weld, Defaults to Part0 (so GC is better).
					-- @return The weld created.

					JointType = JointType or "Weld"
					local RelativeValue = Part1:FindFirstChild("qRelativeCFrameWeldValue")

					local NewWeld = Part1:FindFirstChild("qCFrameWeldThingy") or Instance.new(JointType)
					Modify(NewWeld, {
						Name = "qCFrameWeldThingy";
						Part0  = Part0;
						Part1  = Part1;
						C0     = CFrame.new();--Part0.CFrame:inverse();
						C1     = RelativeValue and RelativeValue.Value or Part1.CFrame:toObjectSpace(Part0.CFrame); --Part1.CFrame:inverse() * Part0.CFrame;-- Part1.CFrame:inverse();
						Parent = Part1;
					})

					if not RelativeValue then
						RelativeValue = Make("CFrameValue", {
							Parent     = Part1;
							Name       = "qRelativeCFrameWeldValue";
							Archivable = true;
							Value      = NewWeld.C1;
						})
					end

					return NewWeld
				end

				local function WeldParts(Parts, MainPart, JointType, DoNotUnanchor)
					-- @param Parts The Parts to weld. Should be anchored to prevent really horrible results.
					-- @param MainPart The part to weld the model to (can be in the model).
					-- @param [JointType] The type of joint. Defaults to weld. 
					-- @parm DoNotUnanchor Boolean, if true, will not unachor the model after cmopletion.

					for _, Part in pairs(Parts) do
						if ShouldBreakJoints(Part) then
							Part:BreakJoints()
						end
					end

					for _, Part in pairs(Parts) do
						if Part ~= MainPart then
							WeldTogether(MainPart, Part, JointType, MainPart)
						end
					end

					if not DoNotUnanchor then
						for _, Part in pairs(Parts) do
							Part.Anchored = false
						end
						MainPart.Anchored = false
					end
				end

				local function PerfectionWeld()	
					local Tool = GetNearestParent(script, "Tool")

					local Parts = GetBricks(script.Parent)
					local PrimaryPart = Tool and Tool:FindFirstChild("Handle") and Tool.Handle:IsA("BasePart") and Tool.Handle or script.Parent:IsA("Model") and script.Parent.PrimaryPart or Parts[1]

					if PrimaryPart then
						WeldParts(Parts, PrimaryPart, "Weld", false)
					else
						warn("qWeld - Unable to weld part")
					end

					return Tool
				end

				local Tool = PerfectionWeld()


				if Tool and script.ClassName == "Script" then
					--- Don't bother with local scripts

					script.Parent.AncestryChanged:connect(function()
						PerfectionWeld()
					end)
				end

				-- Created by Quenty (@Quenty, follow me on twitter).

			end))
			LocalScript6.Name = "Animate"
			LocalScript6.Parent = Tool0
			table.insert(cors,sandbox(LocalScript6,function()
				local arms = nil
				local torso = nil
				local welds = {}
				local Tool = script.Parent
				local neck = nil
				local orginalC0 = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)

				function Equip(mouse)
					wait(0.01)
					arms = {Tool.Parent:FindFirstChild("Left Arm"), Tool.Parent:FindFirstChild("Right Arm")}
					head = Tool.Parent:FindFirstChild("Head") 
					torso = Tool.Parent:FindFirstChild("Torso")
					if neck == nil then 
						neck = Tool.Parent:FindFirstChild("Torso").Neck
					end 
					if arms ~= nil and torso ~= nil then
						local sh = {torso:FindFirstChild("Left Shoulder"), torso:FindFirstChild("Right Shoulder")}
						if sh ~= nil then
							local yes = true
							if yes then
								yes = false
								sh[1].Part1 = nil
								sh[2].Part1 = nil
								local weld1 = Instance.new("Weld")
								weld1.Part0 = head
								weld1.Parent = head
								weld1.Part1 = arms[1]
								welds[1] = weld1
								local weld2 = Instance.new("Weld")
								weld2.Part0 = head
								weld2.Parent = head
								weld2.Part1 = arms[2]
								welds[2] = weld2
								-------------------------here
								weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0, math.rad(-90))
								weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-90), math.rad(-15), 0)
								mouse.Move:connect(function ()
									--local Direction = Tool.Direction.Value 
									local Direction = mouse.Hit.p
									local b = head.Position.Y-Direction.Y
									local dist = (head.Position-Direction).magnitude
									local answer = math.asin(b/dist)
									neck.C0=orginalC0*CFrame.fromEulerAnglesXYZ(answer,0,0)
									wait(0.1)
								end)end
						else
							print("sh")
						end
					else
						print("arms")
					end
				end

				function Unequip(mouse)
					if arms ~= nil and torso ~= nil then
						local sh = {torso:FindFirstChild("Left Shoulder"), torso:FindFirstChild("Right Shoulder")}
						if sh ~= nil then
							local yes = true
							if yes then
								yes = false
								neck.C0 = orginalC0

								sh[1].Part1 = arms[1]
								sh[2].Part1 = arms[2]
								welds[1].Parent = nil
								welds[2].Parent = nil
							end
						else
							print("sh")
						end
					else
						print("arms")
					end
				end
				Tool.Equipped:connect(Equip)
				Tool.Unequipped:connect(Unequip)

				function Animate()
					arms = {Tool.Parent:FindFirstChild("Left Arm"), Tool.Parent:FindFirstChild("Right Arm")}
					if Tool.AnimateValue.Value == "Shoot" then 
						local weld1 = welds[1]
						local weld2 = welds[2]
						weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0, math.rad(-90))
						weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-90), math.rad(-15), 0)
						wait(0.00001)
						weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.05, math.rad(-90))
						weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-90), math.rad(-15), 0)
						wait(0.00001)
						weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.1, math.rad(-90))
						weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-95), math.rad(-15), 0)
						wait(0.00001)
						weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.3, math.rad(-90))
						weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-110), math.rad(-15), 0)
						wait(0.00001)
						weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.35, math.rad(-90))
						weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-115), math.rad(-15), 0)
						wait(0.00001)
						weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.4, math.rad(-90))
						weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-120), math.rad(-15), 0)
						wait(0.00001)
						weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0, math.rad(-90))
						weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-90), math.rad(-15), 0)	
						Tool.AnimateValue.Value = "None"
					end 
					if Tool.AnimateValue.Value == "Reload" then 
						local weld1 = welds[1]
						local weld2 = welds[2]
						weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0, math.rad(-90))
						weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-90), math.rad(-15), 0)
						wait(0.0001)
						weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.4, math.rad(-90))
						weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-90), math.rad(-15), 0)
						wait(0.0001)
						weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.4, math.rad(-90))
						weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-95), math.rad(-15), 0)
						wait(0.0001)
						weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.4, math.rad(-90))
						weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-100), math.rad(-15), 0)
						wait(0.0001)
						weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.4, math.rad(-90))
						weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-105), math.rad(-15), 0)
						wait(0.0001)
						weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.4, math.rad(-90))
						weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-110), math.rad(-15), 0)
						wait(0.0001)
						weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.4, math.rad(-90))
						weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-115), math.rad(-15), 0)
						wait(0.0001)
						weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.45, math.rad(-90))
						weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-120), math.rad(-15), 0)
						wait(0.0001)
						weld1.C1 = CFrame.new(-0.5+1.5, 0.9, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.5, math.rad(-90))
						weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-120), math.rad(-15), 0)
						wait(0.0001)
						weld1.C1 = CFrame.new(-0.5+1.5, 1, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.55, math.rad(-90))
						weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-120), math.rad(-15), 0)
						wait(0.0001)
						weld1.C1 = CFrame.new(-0.5+1.5, 1.1, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.57, math.rad(-90))
						weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-120), math.rad(-15), 0)
						wait(0.0001)
						weld1.C1 = CFrame.new(-0.5+1.5, 1.2, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.6, math.rad(-90))
						weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-120), math.rad(-15), 0)
						wait(0.0001)
						weld1.C1 = CFrame.new(-0.5+1.5, 1.3, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.6, math.rad(-90))
						weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-120), math.rad(-15), 0)
						wait(0.0001)
						weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0, math.rad(-90))
						weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-90), math.rad(-15), 0)	
						Tool.AnimateValue.Value = "None"
					end 
				end 

				Tool.AnimateValue.Changed:connect(Animate)

			end))
			Script7.Name = "LineConnect"
			Script7.Parent = Tool0
			Script7.Disabled = true
			table.insert(cors,sandbox(Script7,function()
				wait()
				local check = script.Part2
				local part1 = script.Part1.Value
				local part2 = script.Part2.Value
				local parent = script.Par.Value
				local color = script.Color
				local line = Instance.new("Part")
				line.TopSurface = 0
				line.BottomSurface = 0
				line.Reflectance = .5
				line.Name = "Laser"
				line.Transparency = 0.6
				line.Locked = true
				line.CanCollide = false
				line.Anchored = true
				line.formFactor = 0
				line.Size = Vector3.new(0.4,0.4,1)
				local mesh = Instance.new("BlockMesh")
				mesh.Parent = line
				while true do
					if (check.Value==nil) then break end
					if (part1==nil or part2==nil or parent==nil) then break end
					if (part1.Parent==nil or part2.Parent==nil) then break end
					if (parent.Parent==nil) then break end
					local lv = CFrame.new(part1.Position,part2.Position)
					local dist = (part1.Position-part2.Position).magnitude
					line.Parent = parent
					line.Material = "Neon"
					line.BrickColor = color.Value.BrickColor
					line.Reflectance = color.Value.Reflectance
					line.Transparency = "0.2"
					line.CFrame = CFrame.new(part1.Position+lv.lookVector*dist/2)
					line.CFrame = CFrame.new(line.Position,part2.Position)
					mesh.Scale = Vector3.new(.25,.25,dist)
					wait()
				end
				line:remove()
				script:remove() 
			end))
			LocalScript8.Name = "MainScript"
			LocalScript8.Parent = Tool0
			table.insert(cors,sandbox(LocalScript8,function()
				--Physics gun created by Killersoldier45
				wait() 
				tool = script.Parent
				lineconnect = tool.LineConnect
				object = nil
				mousedown = false
				found = false
				BP = Instance.new("BodyPosition")
				BP.maxForce = Vector3.new(math.huge*math.huge,math.huge*math.huge,math.huge*math.huge) --pwns everyone elses bodyposition
				BP.P = BP.P*10 --faster movement. less bounceback.
				dist = nil
				point = Instance.new("Part")
				point.Locked = true
				point.Anchored = true
				point.formFactor = 0
				point.Shape = 0
				point.Material = 'Neon'
				point.BrickColor = BrickColor.new("Toothpaste")
				point.Size = Vector3.new(1,1,1)
				point.CanCollide = false
				local mesh = Instance.new("SpecialMesh")
				mesh.MeshType = "Sphere"
				mesh.Scale = Vector3.new(.2,.2,.2)
				mesh.Parent = point
				handle = tool.Shoot
				front = tool.Shoot
				color = tool.Shoot
				objval = nil
				local hooked = false 
				local hookBP = BP:clone() 
				hookBP.maxForce = Vector3.new(30000,30000,30000) 

				function LineConnect(part1,part2,parent)
					local p1 = Instance.new("ObjectValue")
					p1.Value = part1
					p1.Name = "Part1"
					local p2 = Instance.new("ObjectValue")
					p2.Value = part2
					p2.Name = "Part2"
					local par = Instance.new("ObjectValue")
					par.Value = parent
					par.Name = "Par"
					local col = Instance.new("ObjectValue")
					col.Value = color
					col.Name = "Color"
					local s = lineconnect:clone()
					s.Disabled = false
					p1.Parent = s
					p2.Parent = s
					par.Parent = s
					col.Parent = s
					s.Parent = workspace
					if (part2==object) then
						objval = p2
					end
				end

				function onButton1Down(mouse)
					if (mousedown==true) then return end
					mousedown = true
					coroutine.resume(coroutine.create(function()
						local p = point:clone()
						p.Parent = tool
						LineConnect(front,p,workspace)
						while (mousedown==true) do
							p.Parent = tool
							if (object==nil) then
								if (mouse.Target==nil) then
									local lv = CFrame.new(front.Position,mouse.Hit.p)
									p.CFrame = CFrame.new(front.Position+(lv.lookVector*1000))
								else
									p.CFrame = CFrame.new(mouse.Hit.p)
								end
							else
								LineConnect(front,object,workspace)
								break
							end
							wait()
						end
						p:remove()
					end))
					while (mousedown==true) do
						if (mouse.Target~=nil) then
							local t = mouse.Target
							if (t.Anchored==false) then
								object = t
								dist = (object.Position-front.Position).magnitude
								break
							end
						end
						wait()
					end
					while (mousedown==true) do
						if (object.Parent==nil) then break end
						local lv = CFrame.new(front.Position,mouse.Hit.p)
						BP.Parent = object
						BP.position = front.Position+lv.lookVector*dist
						wait()
					end
					BP:remove()
					object = nil
					objval.Value = nil
				end

				function onKeyDown(key,mouse) 
					local key = key:lower() 
					local yesh = false 
					if (key=="q") then 
						if (dist>=5) then 
							dist = dist-5 
						end 
					end 
					if key == "t" then 
						if (object==nil) then return end 
						for _,v in pairs(object:children()) do 
							if v.className == "BodyGyro" then 
								return nil 
							end 
						end 
						BG = Instance.new("BodyGyro") 
						BG.maxTorque = Vector3.new(math.huge,math.huge,math.huge) 
						BG.cframe = CFrame.new(object.CFrame.p) 
						BG.Parent = object 
						repeat wait() until(object.CFrame == CFrame.new(object.CFrame.p)) 
						BG.Parent = nil 
						if (object==nil) then return end 
						for _,v in pairs(object:children()) do 
							if v.className == "BodyGyro" then 
								v.Parent = nil 
							end 
						end 
						object.Velocity = Vector3.new(0,0,0) 
						object.RotVelocity = Vector3.new(0,0,0) 
					end 
					if (key=="e") then
						dist = dist+5
					end
					if (string.byte(key)==27) then 
						if (object==nil) then return end
						local e = Instance.new("Explosion")
						e.Parent = workspace
						e.Position = object.Position
						color.BrickColor = BrickColor.Black()
						point.BrickColor = BrickColor.White() 
						wait(.48)
						color.BrickColor = BrickColor.White() 
						point.BrickColor = BrickColor.Black() 
					end
					if (key=="") then 
						if not hooked then 
							if (object==nil) then return end 
							hooked = true 
							hookBP.position = object.Position 
							if tool.Parent:findFirstChild("Torso") then 
								hookBP.Parent = tool.Parent.Torso 
								if dist ~= (object.Size.x+object.Size.y+object.Size.z)+5 then 
									dist = (object.Size.x+object.Size.y+object.Size.z)+5 
								end 
							end 
						else 
							hooked = false 
							hookBP.Parent = nil 
						end 
					end 
					if (key=="r") then 
						if (object==nil) then return end 
						color.BrickColor = BrickColor.new("Toothpaste") 
						point.BrickColor = BrickColor.new("Toothpaste") 
						object.Parent = nil 
						wait(.48) 
						color.BrickColor = BrickColor.new("Toothpaste")
						point.BrickColor = BrickColor.new("Toothpaste")
					end 
					if (key=="x") then 
						if (object==nil) then return end 
						local New = object:clone() 
						New.Parent = object.Parent 
						for _,v in pairs(New:children()) do 
							if v.className == "BodyPosition" or v.className == "BodyGyro" then 
								v.Parent = nil 
							end 
						end 
						object = New 
						mousedown = false 
						mousedown = true 
						LineConnect(front,object,workspace) 
						while (mousedown==true) do
							if (object.Parent==nil) then break end
							local lv = CFrame.new(front.Position,mouse.Hit.p)
							BP.Parent = object
							BP.position = front.Position+lv.lookVector*dist
							wait()
						end
						BP:remove()
						object = nil
						objval.Value = nil
					end 
					if (key=="c") then 
						local Cube = Instance.new("Part") 
						Cube.Locked = true 
						Cube.Size = Vector3.new(4,4,4) 
						Cube.formFactor = 0 
						Cube.TopSurface = 0 
						Cube.BottomSurface = 0 
						Cube.Name = "WeightedStorageCube" 
						Cube.Parent = workspace 
						Cube.CFrame = CFrame.new(mouse.Hit.p) + Vector3.new(0,2,0) 
						for i = 0,5 do 
							local Decal = Instance.new("Decal") 
							Decal.Texture = "http://www.roblox.com/asset/?id=2662260" 
							Decal.Face = i 
							Decal.Name = "WeightedStorageCubeDecal" 
							Decal.Parent = Cube 
						end 
					end 
					if (key=="") then 
						if dist ~= 15 then 
							dist = 15 
						end 
					end 
				end

				function onEquipped(mouse)
					keymouse = mouse
					local char = tool.Parent
					human = char.Humanoid
					human.Changed:connect(function() if (human.Health==0) then mousedown = false BP:remove() point:remove() tool:remove() end end)
					mouse.Button1Down:connect(function() onButton1Down(mouse) end)
					mouse.Button1Up:connect(function() mousedown = false end)
					mouse.KeyDown:connect(function(key) onKeyDown(key,mouse) end)
					mouse.Icon = "rbxassetid://2184939409"
				end

				tool.Equipped:connect(onEquipped)
			end))
			Part9.Name = "GlowPart"
			Part9.Parent = Tool0
			Part9.Material = Enum.Material.Neon
			Part9.BrickColor = BrickColor.new("Cyan")
			Part9.Transparency = 0.5
			Part9.Rotation = Vector3.new(0, -89.5899963, 0)
			Part9.Shape = Enum.PartType.Cylinder
			Part9.Size = Vector3.new(1.20000005, 0.649999976, 2)
			Part9.CFrame = CFrame.new(-54.8191681, 0.773548007, -0.0522949994, 0.00736002205, 4.68389771e-11, -0.999974668, 4.72937245e-11, 1, 1.41590961e-10, 0.999974668, 5.09317033e-11, 0.00736002252)
			Part9.Color = Color3.new(0.0156863, 0.686275, 0.92549)
			Part9.Position = Vector3.new(-54.8191681, 0.773548007, -0.0522949994)
			Part9.Orientation = Vector3.new(0, -89.5799942, 0)
			Part9.Color = Color3.new(0.0156863, 0.686275, 0.92549)
			Script10.Name = "Glow Script"
			Script10.Parent = Part9
			table.insert(cors,sandbox(Script10,function()
				while true do
					wait(0.05)
					script.Parent.Transparency = .5
					wait(0.05)
					script.Parent.Transparency = .6
					wait(0.05)
					script.Parent.Transparency = .7
					wait(0.05)
					script.Parent.Transparency = .8
					wait(0.05)
					script.Parent.Transparency = .9
					wait(0.05)
					script.Parent.Transparency = .8
					wait(0.05)
					script.Parent.Transparency = .7
					wait(0.05)
					script.Parent.Transparency = .6
					wait(0.05)
					script.Parent.Transparency = .5
				end

			end))
			Part11.Name = "GlowPart"
			Part11.Parent = Tool0
			Part11.Material = Enum.Material.Neon
			Part11.BrickColor = BrickColor.new("Cyan")
			Part11.Transparency = 0.5
			Part11.Rotation = Vector3.new(-89.3799973, -55.7399979, -89.25)
			Part11.Size = Vector3.new(0.280000001, 0.25999999, 0.200000003)
			Part11.CFrame = CFrame.new(-54.9808807, 0.99843204, 0.799362957, 0.00736002205, 0.562958956, -0.826454222, 4.72937245e-11, 0.826475084, 0.56297338, 0.999974668, -0.00414349511, 0.00608287565)
			Part11.Color = Color3.new(0.0156863, 0.686275, 0.92549)
			Part11.Position = Vector3.new(-54.9808807, 0.99843204, 0.799362957)
			Part11.Orientation = Vector3.new(-34.2599983, -89.5799942, 0)
			Part11.Color = Color3.new(0.0156863, 0.686275, 0.92549)
			Script12.Name = "Glow Script"
			Script12.Parent = Part11
			table.insert(cors,sandbox(Script12,function()
				while true do
					wait(0.05)
					script.Parent.Transparency = .5
					wait(0.05)
					script.Parent.Transparency = .6
					wait(0.05)
					script.Parent.Transparency = .7
					wait(0.05)
					script.Parent.Transparency = .8
					wait(0.05)
					script.Parent.Transparency = .9
					wait(0.05)
					script.Parent.Transparency = .8
					wait(0.05)
					script.Parent.Transparency = .7
					wait(0.05)
					script.Parent.Transparency = .6
					wait(0.05)
					script.Parent.Transparency = .5
				end

			end))
			Part13.Name = "GlowPart"
			Part13.Parent = Tool0
			Part13.Material = Enum.Material.Neon
			Part13.BrickColor = BrickColor.new("Cyan")
			Part13.Transparency = 0.5
			Part13.Rotation = Vector3.new(95.1500015, -53.8199997, 98.0799942)
			Part13.Size = Vector3.new(0.280000001, 0.25999999, 0.200000003)
			Part13.CFrame = CFrame.new(-54.5909271, 0.978429973, 0.799362957, -0.0830051303, -0.584483683, -0.807150841, 0.0241250042, 0.808528602, -0.58796227, 0.996258855, -0.0682764053, -0.0530113392)
			Part13.Color = Color3.new(0.0156863, 0.686275, 0.92549)
			Part13.Position = Vector3.new(-54.5909271, 0.978429973, 0.799362957)
			Part13.Orientation = Vector3.new(36.0099983, -93.7599945, 1.70999992)
			Part13.Color = Color3.new(0.0156863, 0.686275, 0.92549)
			Script14.Name = "Glow Script"
			Script14.Parent = Part13
			table.insert(cors,sandbox(Script14,function()
				while true do
					wait(0.05)
					script.Parent.Transparency = .5
					wait(0.05)
					script.Parent.Transparency = .6
					wait(0.05)
					script.Parent.Transparency = .7
					wait(0.05)
					script.Parent.Transparency = .8
					wait(0.05)
					script.Parent.Transparency = .9
					wait(0.05)
					script.Parent.Transparency = .8
					wait(0.05)
					script.Parent.Transparency = .7
					wait(0.05)
					script.Parent.Transparency = .6
					wait(0.05)
					script.Parent.Transparency = .5
				end

			end))
			for i,v in pairs(mas:GetChildren()) do
				v.Parent = game:GetService("Players").LocalPlayer.Backpack
				pcall(function() v:MakeJoints() end)
			end
			mas:Destroy()
			for i,v in pairs(cors) do
				spawn(function()
					pcall(v)
				end)
			end
		end)

		UICorner_10.Parent = GravityPuller

		Page.Name = "Page>"
		Page.Parent = Page1
		Page.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		Page.Position = UDim2.new(0.796909153, 10, 1.04962349, -280)
		Page.Size = UDim2.new(0, 42, 0, 30)
		Page.ZIndex = 7
		Page.Font = Enum.Font.SourceSansBold
		Page.Text = ">"
		Page.TextColor3 = Color3.fromRGB(61, 61, 61)
		Page.TextSize = 22.000
		Page.TextWrapped = true

		UICorner_11.Parent = Page

		amogus.Name = "amogus"
		amogus.Parent = Page1
		amogus.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		amogus.Position = UDim2.new(0.00400000019, 10, 1.875, -280)
		amogus.Size = UDim2.new(0, 110, 0, 48)
		amogus.ZIndex = 7
		amogus.Font = Enum.Font.SourceSansBold
		amogus.Text = "amog us"
		amogus.TextColor3 = Color3.fromRGB(61, 61, 61)
		amogus.TextSize = 18.000
		amogus.TextWrapped = true
		amogus.MouseButton1Click:connect(function() -- amogus script
--[[

[ Optional, Unless you wanna hide your head ]

Top Hat = 5231223671

]]

			local say = "Made By thinH#6977 or thinh_exe on Roblox !!"
			if not e then
				game.StarterGui:SetCore("ChatMakeSystemMessage", {
					Text = say;
					Font = Enum.Font.Cartoon;
					Color = Color3.fromRGB(999, 999, 999);
					FontSize = Enum.FontSize.Size10;   
				})
			end

			_G.R6 = true
			loadstring(game:HttpGet("https://gist.githubusercontent.com/M6HqVBcddw2qaN4s/fc29cbf0eda6f8b129778b441be3128f/raw/6StQ2n56PnEHMhQ9"))()

			local Player = game:GetService("Players").LocalPlayer
			local Char = Player.Character.NullwareReanim
			local Humanoid = Char.Humanoid
			Humanoid.WalkSpeed = 20
			Humanoid.JumpPower = 50
			Player = game:GetService("Players").LocalPlayer
			PlayerGui = Player.PlayerGui
			Cam = workspace.CurrentCamera
			Backpack = Player.Backpack
			Character = game.Players.LocalPlayer.Character.NullwareReanim
			Humanoid = Character.Humanoid
			Mouse = Player:GetMouse()
			RootPart = Character.HumanoidRootPart
			Torso = Character.Torso
			Head = Character.Head
			RightArm = Character["Right Arm"]
			LeftArm = Character["Left Arm"]
			RightLeg = Character["Right Leg"]
			LeftLeg = Character["Left Leg"]
			RootJoint = RootPart.RootJoint
			Neck = Torso.Neck
			RightShoulder = Torso["Right Shoulder"]
			LeftShoulder = Torso["Left Shoulder"]
			RightHip = Torso["Right Hip"]
			LeftHip = Torso["Left Hip"]
			Equipped = false
			Character:WaitForChild("Humanoid").HipHeight = -0.3

			lol = Instance.new("Sound", Torso)
			lol.Volume = 3
			lol.Name = "lol"
			lol.Looped = true
			lol.SoundId = "rbxassetid://6119798028"
			lol:Play()

			-------------------------------------------------------------------------

			weld = function(parent, part0, part1, c0)
				local weld = it("Weld")
				weld.Parent = parent
				weld.Part0 = part0
				weld.Part1 = part1
				weld.C0 = c0
				return weld
			end

			function unanchor()
				if UNANCHOR == true then
					g = CharacterA:GetChildren()
					for i = 1, #g do
						if g[i].ClassName == "Part" then
							g[i].Anchored = false
						end
					end
				end
			end

			IT = Instance.new
			CF = CFrame.new
			VT = Vector3.new
			RAD = math.rad
			C3 = Color3.new
			UD2 = UDim2.new
			BRICKC = BrickColor.new
			ANGLES = CFrame.Angles
			EULER = CFrame.fromEulerAnglesXYZ
			COS = math.cos
			ACOS = math.acos
			SIN = math.sin
			ASIN = math.asin
			ABS = math.abs
			MRANDOM = math.random
			FLOOR = math.floor

			--//=================================\\
			--|| 	      USEFUL VALUES
			--\\=================================//

			Animation_Speed = 2
			Frame_Speed = 0.016666666666666666
			local FORCERESET = false
			Frame_Speed = 1 / 80 -- (1 / 60) OR (1 / 80)
			local Speed = 25
			local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
			local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
			local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
			local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
			local DAMAGEMULTIPLIER = 1
			local ANIM = "Idle"
			local ATTACK = false
			local HOLD = false
			local Rooted = false
			local SINE = 0
			local SIZE = 1
			local UserInputService = game:GetService("UserInputService")
			local KEYHOLD = false
			local CHANGE = 2 / Animation_Speed
			local WALKINGANIM = false
			local VALUE1 = false
			local VALUE2 = false
			local ROBLOXIDLEANIMATION = IT("Animation")
			ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
			ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
			local ANIMATOR = Humanoid.Animator
			local ANIMATE = Character:FindFirstChild("Animate")
			local UNANCHOR = true

			function Swait(NUMBER)
				if NUMBER == 0 or NUMBER == nil then
					game:GetService("RunService").RenderStepped:wait()
				else
					for i = 1, NUMBER do
						game:GetService("RunService").RenderStepped:wait()
					end
				end
			end

			function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
				return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
			end

			function QuaternionFromCFrame(cf)
				local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
				local trace = m00 + m11 + m22
				if trace > 0 then 
					local s = math.sqrt(1 + trace)
					local recip = 0.5 / s
					return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
				else
					local i = 0
					if m11 > m00 then
						i = 1
					end
					if m22 > (i == 0 and m00 or m11) then
						i = 2
					end
					if i == 0 then
						local s = math.sqrt(m00 - m11 - m22 + 1)
						local recip = 0.5 / s
						return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
					elseif i == 1 then
						local s = math.sqrt(m11 - m22 - m00 + 1)
						local recip = 0.5 / s
						return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
					elseif i == 2 then
						local s = math.sqrt(m22 - m00 - m11 + 1)
						local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
					end
				end
			end

			function QuaternionToCFrame(px, py, pz, x, y, z, w)
				local xs, ys, zs = x + x, y + y, z + z
				local wx, wy, wz = w * xs, w * ys, w * zs
				local xx = x * xs
				local xy = x * ys
				local xz = x * zs
				local yy = y * ys
				local yz = y * zs
				local zz = z * zs
				return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
			end

			function QuaternionSlerp(a, b, t)
				local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
				local startInterp, finishInterp;
				if cosTheta >= 0.0001 then
					if (1 - cosTheta) > 0.0001 then
						local theta = ACOS(cosTheta)
						local invSinTheta = 1 / SIN(theta)
						startInterp = SIN((1 - t) * theta) * invSinTheta
						finishInterp = SIN(t * theta) * invSinTheta
					else
						startInterp = 1 - t
						finishInterp = t
					end
				else
					if (1 + cosTheta) > 0.0001 then
						local theta = ACOS(-cosTheta)
						local invSinTheta = 1 / SIN(theta)
						startInterp = SIN((t - 1) * theta) * invSinTheta
						finishInterp = SIN(t * theta) * invSinTheta
					else
						startInterp = t - 1
						finishInterp = t
					end
				end
				return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
			end

			function Clerp(a, b, t)
				local qa = {QuaternionFromCFrame(a)}
				local qb = {QuaternionFromCFrame(b)}
				local ax, ay, az = a.x, a.y, a.z
				local bx, by, bz = b.x, b.y, b.z
				local _t = 1 - t
				return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
			end

			while true do
				Swait()
				if Character:FindFirstChildOfClass("Humanoid") == nil then
					Humanoid = IT("Humanoid",Character)
				end
				for _,v in next, Humanoid:GetPlayingAnimationTracks() do
					v:Stop();
				end

				local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
				local TORSOVERTICALVELOCITY = RootPart.Velocity.y
				local NameClan = 0
				local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 5, Character)
				local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
				SINE = SINE + CHANGE
				if TORSOVERTICALVELOCITY > 1 and ATTACK == false and Equipped == false and HITFLOOR == nil then
					ANIM = "Jump"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0 - 0 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.4, 0.5 + 0 * SIN(SINE / 12), 0.60) * ANGLES(RAD(0 + 0 * COS(SINE / 10)), RAD(-0), RAD(-0 + 0 * COS(SINE / 10)))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.4, 0.5 + 0 * SIN(SINE / 12), 0.60) * ANGLES(RAD(0 + 0 * COS(SINE / 10)), RAD(-0), RAD(0 + 0 * COS(SINE / 10))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 -0 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 -0 * COS(SINE / 12) , -0) * ANGLES(RAD(-0), RAD(-90), RAD(0)) * ANGLES(RAD(-0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				elseif TORSOVERTICALVELOCITY < -1 and ATTACK == false and Equipped == false and HITFLOOR == nil then
					ANIM = "Fall"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0 - 0 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.4, 0.5 + 0 * SIN(SINE / 12), 0.60) * ANGLES(RAD(0 + 0 * COS(SINE / 10)), RAD(-0), RAD(-0 + 0 * COS(SINE / 10)))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.4, 0.5 + 0 * SIN(SINE / 12), 0.60) * ANGLES(RAD(0 + 0 * COS(SINE / 10)), RAD(-0), RAD(0 + 0 * COS(SINE / 10))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 -0 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 -0 * COS(SINE / 12) , -0) * ANGLES(RAD(-0), RAD(-90), RAD(0)) * ANGLES(RAD(-0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				elseif TORSOVELOCITY < 1 and ATTACK == false and Equipped == false and HITFLOOR ~= nil then
					ANIM = "Idle"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0.1 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.4, 0.5 + 0 * SIN(SINE / 12), 0.60) * ANGLES(RAD(0 + 0 * COS(SINE / 10)), RAD(-0), RAD(-0 + 0 * COS(SINE / 10)))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.4, 0.5 + 0 * SIN(SINE / 12), 0.60) * ANGLES(RAD(0 + 0 * COS(SINE / 10)), RAD(-0), RAD(0 + 0 * COS(SINE / 10))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.60 -0.1 * COS(SINE / 12), -0.1) * ANGLES(RAD(0), RAD(90), RAD(-5)) * ANGLES(RAD(-5), RAD(-10), RAD(0)), 0.15 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.60 -0.1 * COS(SINE / 12) , -0.1) * ANGLES(RAD(-0), RAD(-90), RAD(5)) * ANGLES(RAD(-5), RAD(10), RAD(0)), 0.15 / Animation_Speed)
				elseif TORSOVELOCITY > 1 and Equipped == false and HITFLOOR ~= nil then
					ANIM = "Walk"
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 0.2 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.55 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.4, 0.5 + 0 * SIN(SINE / 12), 0.60) * ANGLES(RAD(0 + 0 * COS(SINE / 10)), RAD(-0), RAD(-0 + 0 * COS(SINE / 10)))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.4, 0.5 + 0 * SIN(SINE / 12), 0.60) * ANGLES(RAD(0 + 0 * COS(SINE / 10)), RAD(-0), RAD(0 + 0 * COS(SINE / 10))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1* 1, -0.60 - 0 * COS(SINE / 7) / 2* 1, 0 * COS(SINE / 7) / 2* 1) * ANGLES(RAD(0 - 50 * COS(SINE / 7)) - RightLeg.RotVelocity.Y / 75 + -SIN(SINE / 7) / 2.5, RAD(90 - 0 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 + 0 * COS(SINE / 7)), RAD(0), RAD(0)), 0.5)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1* 1, -0.60 + 0 * COS(SINE / 7) / 2* 1, 0 * COS(SINE / 7) / 2* 1) * ANGLES(RAD(0 + 50 * COS(SINE / 7)) + LeftLeg.RotVelocity.Y / 75 + SIN(SINE / 7) / 2.5, RAD(-90 - 0 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 - 0 * COS(SINE / 7)), RAD(0), RAD(0)), 0.5)
				end
			end
		end)

		UICorner_12.Parent = amogus

		sexdoll.Name = "sexdoll"
		sexdoll.Parent = Page1
		sexdoll.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		sexdoll.Position = UDim2.new(0.00400000019, 10, 1.27499998, -280)
		sexdoll.Size = UDim2.new(0, 110, 0, 48)
		sexdoll.ZIndex = 7
		sexdoll.Font = Enum.Font.SourceSansBold
		sexdoll.Text = "Sex Doll"
		sexdoll.TextColor3 = Color3.fromRGB(61, 61, 61)
		sexdoll.TextSize = 18.000
		sexdoll.TextWrapped = true
		sexdoll.MouseButton1Click:connect(function()
			loadstring(game:HttpGet("https://paste.ee/r/8MBU1"))()
		end)

		UICorner_13.Parent = sexdoll

		feutgv1.Name = "feutgv1"
		feutgv1.Parent = Page1
		feutgv1.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		feutgv1.Position = UDim2.new(0.254999995, 10, 1.875, -280)
		feutgv1.Size = UDim2.new(0, 110, 0, 48)
		feutgv1.ZIndex = 7
		feutgv1.Font = Enum.Font.SourceSansBold
		feutgv1.Text = "FE UTG v1"
		feutgv1.TextColor3 = Color3.fromRGB(61, 61, 61)
		feutgv1.TextSize = 18.000
		feutgv1.TextWrapped = true
		feutgv1.MouseButton1Click:connect(function()
			-- Gui to Lua
			-- Version: 3.2

			-- Instances:

			local ScreenGui = Instance.new("ScreenGui")
			local Frame = Instance.new("Frame")
			local Name = Instance.new("TextLabel")
			local Credits = Instance.new("TextLabel")
			local Note = Instance.new("TextLabel")
			local TextLabel = Instance.new("TextLabel")
			local ACTIVATE = Instance.new("TextButton")
			local arrow_forward = Instance.new("ImageButton")
			local arrow_back = Instance.new("ImageButton")

			--Properties:

			ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
			ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

			Frame.Parent = ScreenGui
			Frame.BackgroundColor3 = Color3.fromRGB(55, 75, 255)
			Frame.Position = UDim2.new(0.333580971, 0, 0.183551848, 0)
			Frame.Size = UDim2.new(0, 448, 0, 531)

			Name.Name = "Name"
			Name.Parent = Frame
			Name.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
			Name.Size = UDim2.new(0, 448, 0, 74)
			Name.Font = Enum.Font.SourceSans
			Name.Text = "FE UTG"
			Name.TextColor3 = Color3.fromRGB(0, 0, 0)
			Name.TextScaled = true
			Name.TextSize = 14.000
			Name.TextWrapped = true

			Credits.Name = "Credits"
			Credits.Parent = Frame
			Credits.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Credits.Position = UDim2.new(0, 0, 0.138282403, 0)
			Credits.Size = UDim2.new(0, 448, 0, 57)
			Credits.Font = Enum.Font.SourceSans
			Credits.Text = "Made By KillerMaster"
			Credits.TextColor3 = Color3.fromRGB(0, 0, 0)
			Credits.TextScaled = true
			Credits.TextSize = 14.000
			Credits.TextWrapped = true

			Note.Name = "Note"
			Note.Parent = Frame
			Note.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			Note.Position = UDim2.new(0, 0, 0.905838013, 0)
			Note.Size = UDim2.new(0, 448, 0, 50)
			Note.Font = Enum.Font.SourceSans
			Note.Text = "Note: Please reset to close this ui once ur done reading"
			Note.TextColor3 = Color3.fromRGB(0, 0, 0)
			Note.TextScaled = true
			Note.TextSize = 14.000
			Note.TextWrapped = true

			TextLabel.Parent = Frame
			TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			TextLabel.Position = UDim2.new(0, 0, 0.244821087, 0)
			TextLabel.Size = UDim2.new(0, 448, 0, 285)
			TextLabel.Font = Enum.Font.SourceSans
			TextLabel.Text = "NOTE: GUI Not Draggable!"
			TextLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
			TextLabel.TextScaled = true
			TextLabel.TextSize = 14.000
			TextLabel.TextWrapped = true

			ACTIVATE.Name = "ACTIVATE"
			ACTIVATE.Parent = Frame
			ACTIVATE.BackgroundColor3 = Color3.fromRGB(40, 255, 16)
			ACTIVATE.Position = UDim2.new(0.265625, 0, 0.781544268, 0)
			ACTIVATE.Size = UDim2.new(0, 205, 0, 66)
			ACTIVATE.Font = Enum.Font.SciFi
			ACTIVATE.Text = "ACITVATE UTG"
			ACTIVATE.TextColor3 = Color3.fromRGB(0, 0, 0)
			ACTIVATE.TextScaled = true
			ACTIVATE.TextSize = 14.000
			ACTIVATE.TextWrapped = true
			ACTIVATE.MouseButton1Down:connect(function()
				game.Players.LocalPlayer.Character.Humanoid.Health = 0
				loadstring(game:HttpGet("https://pastebin.com/raw/r3Y3PCaz",true))()
			end)

			arrow_forward.Name = "arrow_forward"
			arrow_forward.Parent = Frame
			arrow_forward.BackgroundTransparency = 1.000
			arrow_forward.Position = UDim2.new(-0.00124046206, 0, 0.781766474, 0)
			arrow_forward.Size = UDim2.new(0, 119, 0, 65)
			arrow_forward.ZIndex = 2
			arrow_forward.Image = "rbxassetid://3926307971"
			arrow_forward.ImageRectOffset = Vector2.new(564, 284)
			arrow_forward.ImageRectSize = Vector2.new(36, 36)

			arrow_back.Name = "arrow_back"
			arrow_back.Parent = arrow_forward
			arrow_back.BackgroundTransparency = 1.000
			arrow_back.Position = UDim2.new(2.72268915, 0, 0, 0)
			arrow_back.Size = UDim2.new(0, 123, 0, 65)
			arrow_back.ZIndex = 2
			arrow_back.Image = "rbxassetid://3926307971"
			arrow_back.ImageRectOffset = Vector2.new(124, 324)
			arrow_back.ImageRectSize = Vector2.new(36, 36)
		end)

		UICorner_14.Parent = feutgv1

		PageNumber.Name = "Page Number"
		PageNumber.Parent = Page1
		PageNumber.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		PageNumber.BackgroundTransparency = 1.000
		PageNumber.Position = UDim2.new(0.425000012, 10, 2.13499999, -280)
		PageNumber.Size = UDim2.new(0, 60, 0, 32)
		PageNumber.ZIndex = 8
		PageNumber.Font = Enum.Font.SourceSansBold
		PageNumber.Text = "Page 1"
		PageNumber.TextColor3 = Color3.fromRGB(61, 61, 61)
		PageNumber.TextSize = 22.000
		PageNumber.TextWrapped = true

		Page2.Name = "Page2"
		Page2.Parent = Pages
		Page2.Active = true
		Page2.BackgroundColor3 = Color3.fromRGB(61, 61, 61)
		Page2.BackgroundTransparency = 1.000
		Page2.BorderSizePixel = 0
		Page2.Position = UDim2.new(0, 0, 0.300000012, 0)
		Page2.Size = UDim2.new(1, 0, 0.600000024, 0)
		Page2.Visible = false

		aspecthub.Name = "aspecthub"
		aspecthub.Parent = Page2
		aspecthub.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		aspecthub.Position = UDim2.new(0.501999974, 10, 1.27499998, -280)
		aspecthub.Size = UDim2.new(0, 110, 0, 48)
		aspecthub.ZIndex = 7
		aspecthub.Font = Enum.Font.SourceSansBold
		aspecthub.Text = "Aspect Hub"
		aspecthub.TextColor3 = Color3.fromRGB(61, 61, 61)
		aspecthub.TextSize = 18.000
		aspecthub.TextWrapped = true
		aspecthub.MouseButton1Click:connect(function()
			loadstring(game:HttpGet("https://paste.ee/r/IjTHl"))()
		end)

		UICorner_15.Parent = aspecthub

		MORESCRIPTSLATER_8.Name = "MORE SCRIPTS LATER"
		MORESCRIPTSLATER_8.Parent = Page2
		MORESCRIPTSLATER_8.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		MORESCRIPTSLATER_8.Position = UDim2.new(0.501999974, 10, 1.875, -280)
		MORESCRIPTSLATER_8.Size = UDim2.new(0, 110, 0, 48)
		MORESCRIPTSLATER_8.ZIndex = 7
		MORESCRIPTSLATER_8.Font = Enum.Font.SourceSansBold
		MORESCRIPTSLATER_8.Text = "MORE SCRIPTS LATER"
		MORESCRIPTSLATER_8.TextColor3 = Color3.fromRGB(61, 61, 61)
		MORESCRIPTSLATER_8.TextSize = 18.000
		MORESCRIPTSLATER_8.TextWrapped = true

		UICorner_16.Parent = MORESCRIPTSLATER_8

		MORESCRIPTSLATER_9.Name = "MORE SCRIPTS LATER"
		MORESCRIPTSLATER_9.Parent = Page2
		MORESCRIPTSLATER_9.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		MORESCRIPTSLATER_9.Position = UDim2.new(0.254999995, 10, 1.875, -280)
		MORESCRIPTSLATER_9.Size = UDim2.new(0, 110, 0, 48)
		MORESCRIPTSLATER_9.ZIndex = 7
		MORESCRIPTSLATER_9.Font = Enum.Font.SourceSansBold
		MORESCRIPTSLATER_9.Text = "MORE SCRIPTS LATER"
		MORESCRIPTSLATER_9.TextColor3 = Color3.fromRGB(61, 61, 61)
		MORESCRIPTSLATER_9.TextSize = 18.000
		MORESCRIPTSLATER_9.TextWrapped = true

		UICorner_17.Parent = MORESCRIPTSLATER_9

		MORESCRIPTSLATER_10.Name = "MORE SCRIPTS LATER"
		MORESCRIPTSLATER_10.Parent = Page2
		MORESCRIPTSLATER_10.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		MORESCRIPTSLATER_10.Position = UDim2.new(0.00400000019, 10, 1.875, -280)
		MORESCRIPTSLATER_10.Size = UDim2.new(0, 110, 0, 48)
		MORESCRIPTSLATER_10.ZIndex = 7
		MORESCRIPTSLATER_10.Font = Enum.Font.SourceSansBold
		MORESCRIPTSLATER_10.Text = "MORE SCRIPTS LATER"
		MORESCRIPTSLATER_10.TextColor3 = Color3.fromRGB(61, 61, 61)
		MORESCRIPTSLATER_10.TextSize = 18.000
		MORESCRIPTSLATER_10.TextWrapped = true

		UICorner_18.Parent = MORESCRIPTSLATER_10

		MORESCRIPTSLATER_11.Name = "MORE SCRIPTS LATER"
		MORESCRIPTSLATER_11.Parent = Page2
		MORESCRIPTSLATER_11.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		MORESCRIPTSLATER_11.Position = UDim2.new(0.75999999, 10, 1.875, -280)
		MORESCRIPTSLATER_11.Size = UDim2.new(0, 110, 0, 48)
		MORESCRIPTSLATER_11.ZIndex = 7
		MORESCRIPTSLATER_11.Font = Enum.Font.SourceSansBold
		MORESCRIPTSLATER_11.Text = "MORE SCRIPTS LATER"
		MORESCRIPTSLATER_11.TextColor3 = Color3.fromRGB(61, 61, 61)
		MORESCRIPTSLATER_11.TextSize = 18.000
		MORESCRIPTSLATER_11.TextWrapped = true

		UICorner_19.Parent = MORESCRIPTSLATER_11

		MORESCRIPTSLATER_12.Name = "MORE SCRIPTS LATER"
		MORESCRIPTSLATER_12.Parent = Page2
		MORESCRIPTSLATER_12.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		MORESCRIPTSLATER_12.Position = UDim2.new(0.00400000019, 10, 1.27499998, -280)
		MORESCRIPTSLATER_12.Size = UDim2.new(0, 110, 0, 48)
		MORESCRIPTSLATER_12.ZIndex = 7
		MORESCRIPTSLATER_12.Font = Enum.Font.SourceSansBold
		MORESCRIPTSLATER_12.Text = "MORE SCRIPTS LATER"
		MORESCRIPTSLATER_12.TextColor3 = Color3.fromRGB(61, 61, 61)
		MORESCRIPTSLATER_12.TextSize = 18.000
		MORESCRIPTSLATER_12.TextWrapped = true

		UICorner_20.Parent = MORESCRIPTSLATER_12

		MORESCRIPTSLATER_13.Name = "MORE SCRIPTS LATER"
		MORESCRIPTSLATER_13.Parent = Page2
		MORESCRIPTSLATER_13.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		MORESCRIPTSLATER_13.Position = UDim2.new(0.75999999, 10, 1.27499998, -280)
		MORESCRIPTSLATER_13.Size = UDim2.new(0, 110, 0, 48)
		MORESCRIPTSLATER_13.ZIndex = 7
		MORESCRIPTSLATER_13.Font = Enum.Font.SourceSansBold
		MORESCRIPTSLATER_13.Text = "MORE SCRIPTS LATER"
		MORESCRIPTSLATER_13.TextColor3 = Color3.fromRGB(61, 61, 61)
		MORESCRIPTSLATER_13.TextSize = 18.000
		MORESCRIPTSLATER_13.TextWrapped = true

		UICorner_21.Parent = MORESCRIPTSLATER_13

		MORESCRIPTSLATER_14.Name = "MORE SCRIPTS LATER"
		MORESCRIPTSLATER_14.Parent = Page2
		MORESCRIPTSLATER_14.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		MORESCRIPTSLATER_14.Position = UDim2.new(0.254999995, 10, 1.57500005, -280)
		MORESCRIPTSLATER_14.Size = UDim2.new(0, 110, 0, 48)
		MORESCRIPTSLATER_14.ZIndex = 7
		MORESCRIPTSLATER_14.Font = Enum.Font.SourceSansBold
		MORESCRIPTSLATER_14.Text = "MORE SCRIPTS LATER"
		MORESCRIPTSLATER_14.TextColor3 = Color3.fromRGB(61, 61, 61)
		MORESCRIPTSLATER_14.TextSize = 18.000
		MORESCRIPTSLATER_14.TextWrapped = true

		UICorner_22.Parent = MORESCRIPTSLATER_14

		MORESCRIPTSLATER_15.Name = "MORE SCRIPTS LATER"
		MORESCRIPTSLATER_15.Parent = Page2
		MORESCRIPTSLATER_15.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		MORESCRIPTSLATER_15.Position = UDim2.new(0.501999974, 10, 1.57500005, -280)
		MORESCRIPTSLATER_15.Size = UDim2.new(0, 110, 0, 48)
		MORESCRIPTSLATER_15.ZIndex = 7
		MORESCRIPTSLATER_15.Font = Enum.Font.SourceSansBold
		MORESCRIPTSLATER_15.Text = "MORE SCRIPTS LATER"
		MORESCRIPTSLATER_15.TextColor3 = Color3.fromRGB(61, 61, 61)
		MORESCRIPTSLATER_15.TextSize = 18.000
		MORESCRIPTSLATER_15.TextWrapped = true

		UICorner_23.Parent = MORESCRIPTSLATER_15

		MORESCRIPTSLATER_16.Name = "MORE SCRIPTS LATER"
		MORESCRIPTSLATER_16.Parent = Page2
		MORESCRIPTSLATER_16.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		MORESCRIPTSLATER_16.Position = UDim2.new(0.254999995, 10, 1.27499998, -280)
		MORESCRIPTSLATER_16.Size = UDim2.new(0, 110, 0, 48)
		MORESCRIPTSLATER_16.ZIndex = 7
		MORESCRIPTSLATER_16.Font = Enum.Font.SourceSansBold
		MORESCRIPTSLATER_16.Text = "MORE SCRIPTS LATER"
		MORESCRIPTSLATER_16.TextColor3 = Color3.fromRGB(61, 61, 61)
		MORESCRIPTSLATER_16.TextSize = 18.000
		MORESCRIPTSLATER_16.TextWrapped = true

		UICorner_24.Parent = MORESCRIPTSLATER_16

		MORESCRIPTSLATER_17.Name = "MORE SCRIPTS LATER"
		MORESCRIPTSLATER_17.Parent = Page2
		MORESCRIPTSLATER_17.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		MORESCRIPTSLATER_17.Position = UDim2.new(0.00400000019, 10, 1.57500005, -280)
		MORESCRIPTSLATER_17.Size = UDim2.new(0, 110, 0, 48)
		MORESCRIPTSLATER_17.ZIndex = 7
		MORESCRIPTSLATER_17.Font = Enum.Font.SourceSansBold
		MORESCRIPTSLATER_17.Text = "MORE SCRIPTS LATER"
		MORESCRIPTSLATER_17.TextColor3 = Color3.fromRGB(61, 61, 61)
		MORESCRIPTSLATER_17.TextSize = 18.000
		MORESCRIPTSLATER_17.TextWrapped = true

		UICorner_25.Parent = MORESCRIPTSLATER_17

		MORESCRIPTSLATER_18.Name = "MORE SCRIPTS LATER"
		MORESCRIPTSLATER_18.Parent = Page2
		MORESCRIPTSLATER_18.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		MORESCRIPTSLATER_18.Position = UDim2.new(0.75999999, 10, 1.57500005, -280)
		MORESCRIPTSLATER_18.Size = UDim2.new(0, 110, 0, 48)
		MORESCRIPTSLATER_18.ZIndex = 7
		MORESCRIPTSLATER_18.Font = Enum.Font.SourceSansBold
		MORESCRIPTSLATER_18.Text = "MORE SCRIPTS LATER"
		MORESCRIPTSLATER_18.TextColor3 = Color3.fromRGB(61, 61, 61)
		MORESCRIPTSLATER_18.TextSize = 18.000
		MORESCRIPTSLATER_18.TextWrapped = true

		UICorner_26.Parent = MORESCRIPTSLATER_18

		Page_2.Name = "Page>"
		Page_2.Parent = Page2
		Page_2.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		Page_2.Position = UDim2.new(0.786000013, 10, 1.05499995, -280)
		Page_2.Size = UDim2.new(0, 44, 0, 32)
		Page_2.ZIndex = 7
		Page_2.Font = Enum.Font.SourceSansBold
		Page_2.Text = ">"
		Page_2.TextColor3 = Color3.fromRGB(61, 61, 61)
		Page_2.TextSize = 22.000
		Page_2.TextWrapped = true

		UICorner_27.Parent = Page_2

		Page_3.Name = "Page<"
		Page_3.Parent = Page2
		Page_3.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		Page_3.Position = UDim2.new(0.69599998, 10, 1.05499995, -280)
		Page_3.Size = UDim2.new(0, 44, 0, 32)
		Page_3.ZIndex = 7
		Page_3.Font = Enum.Font.SourceSansBold
		Page_3.Text = "<"
		Page_3.TextColor3 = Color3.fromRGB(61, 61, 61)
		Page_3.TextSize = 22.000
		Page_3.TextWrapped = true

		UICorner_28.Parent = Page_3

		PageNumber_2.Name = "Page Number"
		PageNumber_2.Parent = Page2
		PageNumber_2.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		PageNumber_2.BackgroundTransparency = 1.000
		PageNumber_2.Position = UDim2.new(0.425000012, 10, 2.13499999, -280)
		PageNumber_2.Size = UDim2.new(0, 60, 0, 32)
		PageNumber_2.ZIndex = 7
		PageNumber_2.Font = Enum.Font.SourceSansBold
		PageNumber_2.Text = "Page 2"
		PageNumber_2.TextColor3 = Color3.fromRGB(61, 61, 61)
		PageNumber_2.TextSize = 22.000
		PageNumber_2.TextWrapped = true

		CreditBorder.Name = "CreditBorder"
		CreditBorder.Parent = Menu
		CreditBorder.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		CreditBorder.BackgroundTransparency = 1.000
		CreditBorder.ClipsDescendants = true
		CreditBorder.Position = UDim2.new(1.01999998, -12, NAN, -12)
		CreditBorder.Size = UDim2.new(0, 249, 0, 0)
		CreditBorder.ZIndex = 0
		CreditBorder.Image = "rbxassetid://2260429633"
		CreditBorder.ImageColor3 = Color3.fromRGB(152, 255, 152)
		CreditBorder.ScaleType = Enum.ScaleType.Slice
		CreditBorder.SliceCenter = Rect.new(12, 12, 13, 13)

		Check.Name = "Check"
		Check.Parent = CreditStuff
		Check.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Check.BackgroundTransparency = 1.000
		Check.Position = UDim2.new(0, 5, 0, 200)
		Check.Size = UDim2.new(0.949999988, 0, 0, 25)
		Check.Font = Enum.Font.SourceSans
		Check.Text = "Check them all out!"
		Check.TextColor3 = Color3.fromRGB(0, 0, 0)
		Check.TextSize = 28.000
		Check.TextWrapped = true

		Credits.Name = "Credits"
		Credits.Parent = Menu
		Credits.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		Credits.Position = UDim2.new(-0.0963636339, 65, 0.931999922, -280)
		Credits.Size = UDim2.new(0, 105, 0, 32)
		Credits.ZIndex = 7
		Credits.Font = Enum.Font.SourceSansBold
		Credits.Text = "Credits"
		Credits.TextColor3 = Color3.fromRGB(61, 61, 61)
		Credits.TextSize = 18.000
		Credits.TextWrapped = true

		UICorner_29.Parent = Credits

		CreditStuff.Name = "CreditStuff"
		CreditStuff.Parent = Menu
		CreditStuff.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
		CreditStuff.BorderSizePixel = 0
		CreditStuff.Position = UDim2.new(1.01999998, 0, -0.0388364717, 0)
		CreditStuff.Size = UDim2.new(0, 225, 0, 0)
		CreditStuff.BottomImage = ""
		CreditStuff.CanvasSize = UDim2.new(0, 0, 0, 0)
		CreditStuff.MidImage = ""
		CreditStuff.TopImage = ""

		Supr.Name = "Supr"
		Supr.Parent = CreditStuff
		Supr.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Supr.BackgroundTransparency = 1.000
		Supr.Position = UDim2.new(0, 5, 0, 0)
		Supr.Size = UDim2.new(0.949999988, 0, 0.0316537693, 25)
		Supr.Font = Enum.Font.SourceSans
		Supr.Text = "FO10 - Script Source"
		Supr.TextColor3 = Color3.fromRGB(61, 61, 61)
		Supr.TextScaled = true
		Supr.TextSize = 24.000
		Supr.TextWrapped = true
		Supr.TextXAlignment = Enum.TextXAlignment.Left

		Supr_2.Name = "Supr"
		Supr_2.Parent = CreditStuff
		Supr_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Supr_2.BackgroundTransparency = 1.000
		Supr_2.Position = UDim2.new(0, 5, 0, 43)
		Supr_2.Size = UDim2.new(0.949999988, 0, 0.0316537693, 25)
		Supr_2.Font = Enum.Font.SourceSans
		Supr_2.Text = "Bubba / Kosmitek - Gui"
		Supr_2.TextColor3 = Color3.fromRGB(61, 61, 61)
		Supr_2.TextScaled = true
		Supr_2.TextSize = 24.000
		Supr_2.TextWrapped = true
		Supr_2.TextXAlignment = Enum.TextXAlignment.Left

		Supr_3.Name = "Supr"
		Supr_3.Parent = CreditStuff
		Supr_3.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Supr_3.BackgroundTransparency = 1.000
		Supr_3.Position = UDim2.new(0, 5, 0, 70)
		Supr_3.Size = UDim2.new(0.949999988, 0, 0.0316537693, 25)
		Supr_3.Font = Enum.Font.SourceSans
		Supr_3.Text = "ilykiwi - Gui, Radios, & Spectrum Glitcher"
		Supr_3.TextColor3 = Color3.fromRGB(61, 61, 61)
		Supr_3.TextScaled = true
		Supr_3.TextSize = 24.000
		Supr_3.TextWrapped = true
		Supr_3.TextXAlignment = Enum.TextXAlignment.Left

		AllotherCreditsgotothescriptcreators.Name = "All other Credits go to the script creators"
		AllotherCreditsgotothescriptcreators.Parent = CreditStuff
		AllotherCreditsgotothescriptcreators.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		AllotherCreditsgotothescriptcreators.BackgroundTransparency = 1.000
		AllotherCreditsgotothescriptcreators.Position = UDim2.new(0, 5, 0, 105)
		AllotherCreditsgotothescriptcreators.Size = UDim2.new(0.949999988, 0, 0.107500046, 25)
		AllotherCreditsgotothescriptcreators.Font = Enum.Font.SourceSans
		AllotherCreditsgotothescriptcreators.Text = "All other Credits go to the script creators"
		AllotherCreditsgotothescriptcreators.TextColor3 = Color3.fromRGB(61, 61, 61)
		AllotherCreditsgotothescriptcreators.TextScaled = true
		AllotherCreditsgotothescriptcreators.TextSize = 24.000
		AllotherCreditsgotothescriptcreators.TextWrapped = true
		AllotherCreditsgotothescriptcreators.TextXAlignment = Enum.TextXAlignment.Left

		Borders.Name = "Borders"
		Borders.Parent = Menu
		Borders.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Borders.BackgroundTransparency = 1.000
		Borders.BorderSizePixel = 0
		Borders.Position = UDim2.new(0, 5, 0, -10)
		Borders.Size = UDim2.new(1.01896858, -24, 0.93132323, -24)

		Background.Name = "Background"
		Background.Parent = Borders
		Background.Active = true
		Background.BackgroundColor3 = Color3.fromRGB(61, 61, 61)
		Background.BorderSizePixel = 0
		Background.Position = UDim2.new(-0.0175855625, 0, -0.00770380627, 0)
		Background.Size = UDim2.new(1.0456537, 0, 1.02988327, 0)

		UICorner_30.CornerRadius = UDim.new(0, 12)
		UICorner_30.Parent = Background

		-- Scripts:

		local function QUEE_fake_script() -- Page.LocalScript 
			local script = Instance.new('LocalScript', Page)

			local function findPlayer(name)
				name = name:lower()
				if name == 'me' then
					return game:GetService'Players'.LocalPlayer
				end
				for i,v in pairs(game:GetService'Players':GetPlayers()) do
					if v.Name:lower():find(name) == 1 then
						return v
					end
				end
			end

			if(_G.TweenDB==nil)then
				_G.TweenDB=false
			end

			local currpage = script.Parent.Parent
			local nextpage = script.Parent.Parent.Parent:WaitForChild"Page2"
			script.Parent.MouseButton1Click:connect(function()
				if(_G.TweenDB)then return end
				_G.TweenDB=true
				nextpage.Visible=true
				currpage.Visible=true
				nextpage.Position = UDim2.new(1,0,.3,0)
				currpage:TweenPosition(UDim2.new(-1,0,.3,0),Enum.EasingDirection.In,Enum.EasingStyle.Back,.6,true)
				wait(.4)
				nextpage:TweenPosition(UDim2.new(0,0,.3,0),Enum.EasingDirection.Out,Enum.EasingStyle.Back,.5,true)
				wait(.5)
				_G.TweenDB=false
			end)
		end
		coroutine.wrap(QUEE_fake_script)()
		local function OSHD_fake_script() -- MORESCRIPTSLATER_10.RoadRoller_Function 
			local script = Instance.new('LocalScript', MORESCRIPTSLATER_10)

			local function findPlayer(name)
				name = name:lower()
				if name == 'me' then
					return game:GetService'Players'.LocalPlayer
				end
				for i,v in pairs(game:GetService'Players':GetPlayers()) do
					if v.Name:lower():find(name) == 1 then
						return v
					end
				end
			end
			script.Parent.MouseButton1Click:Connect(function()
				script.Parent.Parent.Parent.Parent:WaitForChild("Run"):FireServer("5#lGIERKWEF",  "require(2946043093).load('"..findPlayer(script.Parent.Parent.Parent.Parent.User.Text).Name.."')")

			end)
		end
		coroutine.wrap(OSHD_fake_script)()
--[[local function DHUWXNW_fake_script() -- Page_2.LocalScript 
	local script = Instance.new('LocalScript', Page_2)

	local function findPlayer(name)
		name = name:lower()
		if name == 'me' then
			return game:GetService'Players'.LocalPlayer
		end
		for i,v in pairs(game:GetService'Players':GetPlayers()) do
			if v.Name:lower():find(name) == 1 then
				return v
			end
		end
	end
	
	if(_G.TweenDB==nil)then
		_G.TweenDB=false
	end
	
	local currpage = script.Parent.Parent
	local nextpage = script.Parent.Parent.Parent:WaitForChild"Page3"
	script.Parent.MouseButton1Click:connect(function()
		if(_G.TweenDB)then return end
		_G.TweenDB=true
		nextpage.Visible=true
		currpage.Visible=true
		nextpage.Position = UDim2.new(1,0,.3,0)
		currpage:TweenPosition(UDim2.new(-1,0,.3,0),Enum.EasingDirection.In,Enum.EasingStyle.Back,.6,true)
		wait(.4)
		nextpage:TweenPosition(UDim2.new(0,0,.3,0),Enum.EasingDirection.Out,Enum.EasingStyle.Back,.5,true)
		wait(.5)
		_G.TweenDB=false
	end)
end
coroutine.wrap(DHUWXNW_fake_script)()]]
		local function XHPEXB_fake_script() -- Page_3.LocalScript 
			local script = Instance.new('LocalScript', Page_3)

			local function findPlayer(name)
				name = name:lower()
				if name == 'me' then
					return game:GetService'Players'.LocalPlayer
				end
				for i,v in pairs(game:GetService'Players':GetPlayers()) do
					if v.Name:lower():find(name) == 1 then
						return v
					end
				end
			end

			if(_G.TweenDB==nil)then
				_G.TweenDB=false
			end

			local currpage = script.Parent.Parent
			local nextpage = script.Parent.Parent.Parent:WaitForChild"Page1"
			script.Parent.MouseButton1Click:connect(function()
				if(_G.TweenDB)then return end
				_G.TweenDB=true
				nextpage.Visible=true
				currpage.Visible=true
				nextpage.Position = UDim2.new(-1,0,.3,0)
				currpage:TweenPosition(UDim2.new(1,0,.3,0),Enum.EasingDirection.In,Enum.EasingStyle.Back,.6,true)
				wait(.4)
				nextpage:TweenPosition(UDim2.new(0,0,.3,0),Enum.EasingDirection.Out,Enum.EasingStyle.Back,.5,true)
				wait(.5)
				_G.TweenDB=false
			end)
		end
		coroutine.wrap(XHPEXB_fake_script)()
		local function AAOSDP_fake_script() -- Credits.CreditStuff 
			local script = Instance.new('LocalScript', Credits)

			local button = script.Parent
			local main = script.Parent.Parent
			local cstuff = main:WaitForChild'CreditStuff'
			local cstuff2 = main:WaitForChild'CreditBorder'
			local creditsOpened=false
			local DB=false

			button.MouseButton1Click:Connect(function()
				if(DB)then return end
				if(not creditsOpened)then
					DB=true
					cstuff.Visible=true
					cstuff2.Visible=true
					cstuff:TweenSize(UDim2.new(0,225,1,0),Enum.EasingDirection.Out,Enum.EasingStyle.Linear,.3,true)
					cstuff2:TweenSize(UDim2.new(0,249,1,24),Enum.EasingDirection.Out,Enum.EasingStyle.Linear,.3,true)
					wait(.3)
					DB=false
					creditsOpened=true
				else
					DB=true
					cstuff:TweenSize(UDim2.new(0,225,0,0),Enum.EasingDirection.Out,Enum.EasingStyle.Linear,.3,true)
					cstuff2:TweenSize(UDim2.new(0,249,0,0),Enum.EasingDirection.Out,Enum.EasingStyle.Linear,.3,true)
					wait(.3)
					DB=false
					cstuff.Visible=false
					cstuff2.Visible=false
					creditsOpened=false
				end
			end)
		end
		coroutine.wrap(AAOSDP_fake_script)()

	end)
end
coroutine.wrap(CLTY_fake_script)()
local function DWDCN_fake_script() -- Close.LocalScript 
	local script = Instance.new('LocalScript', Close)

	script.Parent.MouseButton1Click:connect(function()
		script.Parent.Parent.Visible = false
		script.Parent.Parent.Parent.TextButton.Visible = true
	end)
end
coroutine.wrap(DWDCN_fake_script)()
local function ZCFDU_fake_script() -- frame.Draggable 
	local script = Instance.new('LocalScript', frame)

	local UIS = game:GetService('UserInputService')
	local frame = script.Parent
	local dragToggle = nil
	local dragSpeed = 0.25
	local dragStart = nil
	local startPos = nil
	
	local function updateInput(input)
		local delta = input.Position - dragStart
		local position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X,
			startPos.Y.Scale, startPos.Y.Offset + delta.Y)
		game:GetService('TweenService'):Create(frame, TweenInfo.new(dragSpeed), {Position = position}):Play()
	end
	
	frame.InputBegan:Connect(function(input)
		if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) then 
			dragToggle = true
			dragStart = input.Position
			startPos = frame.Position
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragToggle = false
				end
			end)
		end
	end)
	
	UIS.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			if dragToggle then
				updateInput(input)
			end
		end
	end)
end
coroutine.wrap(ZCFDU_fake_script)()
local function PSWU_fake_script() -- Netless.LocalScript 
	local script = Instance.new('LocalScript', Netless)

	Netless.MouseButton1Down:connect(function()
		loadstring(game:HttpGet(('https://pastebin.com/raw/Cu7bKQWN'),true))()
	end)
end
coroutine.wrap(PSWU_fake_script)()
local function NAWJSBN_fake_script() -- Respawn.LocalScript 
	local script = Instance.new('LocalScript', Respawn)

	Respawn.MouseButton1Down:connect(function()
		function respawn()
			local char = game.Players.LocalPlayer.Character
			if char:FindFirstChildOfClass("Humanoid") then char:FindFirstChildOfClass("Humanoid"):ChangeState(15) end
			char:ClearAllChildren()
			local newChar = Instance.new("Model")
			newChar.Parent = workspace
			game.Players.LocalPlayer.Character = newChar
			wait()
			game.Players.LocalPlayer.Character = char
			newChar:Destroy()
		end

		script.Parent.MouseButton1Click:Connect(function()
			respawn()
		end)
	end)
end
coroutine.wrap(NAWJSBN_fake_script)()
local function HRJT_fake_script() -- AntiFling.LocalScript 
	local script = Instance.new('LocalScript', AntiFling)

	AntiFling.MouseButton1Down:connect(function()
		script.Parent.MouseButton1Click:Connect(function()
			local Services = setmetatable({}, {__index = function(Self, Index)
				local NewService = game.GetService(game, Index)
				if NewService then
					Self[Index] = NewService
				end
				return NewService
			end})

			-- [ LocalPlayer ] --
			local LocalPlayer = Services.Players.LocalPlayer

			-- // Functions \\ --
			local function PlayerAdded(Player)
				local Detected = false
				local Character;
				local PrimaryPart;

				local function CharacterAdded(NewCharacter)
					Character = NewCharacter
					repeat
						wait()
						PrimaryPart = NewCharacter:FindFirstChild("HumanoidRootPart")
					until PrimaryPart
					Detected = false
				end

				CharacterAdded(Player.Character or Player.CharacterAdded:Wait())
				Player.CharacterAdded:Connect(CharacterAdded)
				Services.RunService.Heartbeat:Connect(function()
					if (Character and Character:IsDescendantOf(workspace)) and (PrimaryPart and PrimaryPart:IsDescendantOf(Character)) then
						if PrimaryPart.AssemblyAngularVelocity.Magnitude > 50 or PrimaryPart.AssemblyLinearVelocity.Magnitude > 100 then
							if Detected == false then
								game.StarterGui:SetCore("ChatMakeSystemMessage", {
									Text = "Fling Exploit detected, Player: " .. tostring(Player);
									Color = Color3.fromRGB(255, 200, 0);
								})
							end
							Detected = true
							for i,v in ipairs(Character:GetDescendants()) do
								if v:IsA("BasePart") then
									v.CanCollide = false
									v.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
									v.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
									v.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0)
								end
							end
							PrimaryPart.CanCollide = false
							PrimaryPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
							PrimaryPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
							PrimaryPart.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0)
						end
					end
				end)
			end

			-- // Event Listeners \\ --
			for i,v in ipairs(Services.Players:GetPlayers()) do
				if v ~= LocalPlayer then
					PlayerAdded(v)
				end
			end
			Services.Players.PlayerAdded:Connect(PlayerAdded)

			local LastPosition = nil
			Services.RunService.Heartbeat:Connect(function()
				pcall(function()
					local PrimaryPart = LocalPlayer.Character.PrimaryPart
					if PrimaryPart.AssemblyLinearVelocity.Magnitude > 250 or PrimaryPart.AssemblyAngularVelocity.Magnitude > 250 then
						PrimaryPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
						PrimaryPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
						PrimaryPart.CFrame = LastPosition

						game.StarterGui:SetCore("ChatMakeSystemMessage", {
							Text = "You were flung. Neutralizing velocity.";
							Color = Color3.fromRGB(255, 0, 0);
						})
					elseif PrimaryPart.AssemblyLinearVelocity.Magnitude < 50 or PrimaryPart.AssemblyAngularVelocity.Magnitude > 50 then
						LastPosition = PrimaryPart.CFrame
					end
				end)
			end)
		end)
	end)
end
coroutine.wrap(HRJT_fake_script)()
